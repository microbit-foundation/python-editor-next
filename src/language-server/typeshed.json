{
  "files": {
    "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 (currently 3.5 and lower) are\n# generally accurate but we do not guarantee their correctness.\n\nantigravity: 3.0-\narray: 3.0-\naudio: 3.0-\nbuiltins: 3.0-\nerrno: 3.0-\ngc: 3.0-\nlove: 3.0-\nmachine: 3.0-\nmath: 3.0-\nmicrobit: 3.0-\nmicropython: 3.0-\nmusic: 3.0-\nneopixel: 3.0-\nos: 3.0-\nradio: 3.0-\nrandom: 3.0-\nspeech: 3.0-\nstruct: 3.0-\nsys: 3.0-\nthis: 3.0-\ntime: 3.0-\ntyping_extensions: 3.0-\ntyping: 3.0-\nuarray: 3.0-\nucollections: 3.0-\nuerrno: 3.0-\nuos: 3.0-\nurandom: 3.0-\nustruct: 3.0-\nusys: 3.0-\nutime: 3.0-",
    "/typeshed/stdlib/abc.pyi": "from _typeshed import SupportsWrite\nfrom typing import Any, Callable, Tuple, Type, TypeVar\n\n_T = TypeVar(\"_T\")\n_FuncT = TypeVar(\"_FuncT\", bound=Callable[..., Any])\n\n# These definitions have special processing in mypy\nclass ABCMeta(type):\n    __abstractmethods__: frozenset[str]\n    def __init__(self, name: str, bases: Tuple[type, ...], namespace: dict[str, Any]) -> None: ...\n    def __instancecheck__(cls: ABCMeta, instance: Any) -> Any: ...\n    def __subclasscheck__(cls: ABCMeta, subclass: Any) -> Any: ...\n    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = ...) -> None: ...\n    def register(cls: ABCMeta, subclass: Type[_T]) -> Type[_T]: ...\n\ndef abstractmethod(funcobj: _FuncT) -> _FuncT: ...\n\nclass abstractproperty(property): ...\n\n# These two are deprecated and not supported by mypy\ndef abstractstaticmethod(callable: _FuncT) -> _FuncT: ...\ndef abstractclassmethod(callable: _FuncT) -> _FuncT: ...\n\nclass ABC(metaclass=ABCMeta): ...\n\ndef get_cache_token() -> object: ...\n",
    "/typeshed/stdlib/antigravity.pyi": "",
    "/typeshed/stdlib/array.pyi": "from uarray import *\n",
    "/typeshed/stdlib/audio.pyi": "\"\"\"This module allows you to play your own sounds. If you are using a micro:bit\n**V2**, ``audio`` is also part of the ``microbit`` module.\n\nBy default sound output will be via the edge connector on pin 0 and the\n:doc:`built-in speaker <speaker>` **V2**. You can connect wired headphones or\na speaker to pin 0 and GND on the edge connector to hear the sounds.\n\"\"\"\n\nfrom .microbit import MicroBitDigitalPin, Sound\nfrom typing import Iterable, Union\n\ndef play(\n    source: Union[Iterable[AudioFrame], Sound],\n    wait: bool = True,\n    pin: MicroBitDigitalPin = ...,\n    return_pin: MicroBitDigitalPin = ...,\n) -> None:\n    \"\"\"Play the source to completion.\n\n    * **source**: ``Sound`` - The ``microbit`` module contains a list of\n      built-in sounds that your can pass to ``audio.play()``.\n\n    * **source**: ``AudioFrame`` - The source agrument can also be an iterable\n      of ``AudioFrame`` elements as described below.\n\n    * **wait**: If ``wait`` is ``True``, this function will block until the\n      source is exhausted.\n\n    * **pin**: An optional argument to specify the output pin can be used to\n    override the default of ``pin0``. If we do not want any sound to play\n    we can use ``pin=None``.\n\n    * **return_pin**: specifies a differential edge connector pin to connect\n      to an external speaker instead of ground. This is ignored for the **V2**\n      revision.\n    \"\"\"\n\ndef is_playing() -> bool:\n    \"\"\"Return ``True`` if audio is playing, otherwise return ``False``.\"\"\"\n    ...\n\ndef stop() -> None:\n    \"\"\"Stops all audio playback.\"\"\"\n    ...\n\nclass AudioFrame:\n    \"\"\"An ``AudioFrame`` object is a list of 32 samples each of which is a signed byte\n    (whole number between -128 and 127).\n\n    It takes just over 4 ms to play a single frame.\n    \"\"\"\n\n    def __len__(self) -> int: ...\n    def __setitem__(self, key: int, value: int) -> None: ...\n    def __getitem__(self, key: int) -> int: ...\n",
    "/typeshed/stdlib/builtins.pyi": "import sys\nimport types\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenTextMode,\n    ReadableBuffer,\n    Self,\n    StrOrBytesPath,\n    SupportsDivMod,\n    SupportsKeysAndGetItem,\n    SupportsLenAndGetItem,\n    SupportsLessThan,\n    SupportsLessThanT,\n    SupportsRDivMod,\n    SupportsWrite,\n)\nfrom types import CodeType, TracebackType\nfrom typing import (\n    IO,\n    AbstractSet,\n    Any,\n    AsyncIterable,\n    AsyncIterator,\n    BinaryIO,\n    ByteString,\n    Callable,\n    FrozenSet,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    MutableMapping,\n    MutableSequence,\n    MutableSet,\n    NoReturn,\n    Protocol,\n    Reversible,\n    Sequence,\n    Set,\n    Sized,\n    SupportsAbs,\n    SupportsBytes,\n    SupportsComplex,\n    SupportsFloat,\n    SupportsInt,\n    SupportsRound,\n    TextIO,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, SupportsIndex, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nclass _SupportsTrunc(Protocol):\n    def __trunc__(self) -> int: ...\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_S = TypeVar(\"_S\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_TT = TypeVar(\"_TT\", bound=\"type\")\n_TBE = TypeVar(\"_TBE\", bound=\"BaseException\")\n\nclass object:\n    __doc__: str | None\n    __dict__: dict[str, Any]\n    __slots__: str | Iterable[str]\n    __module__: str\n    __annotations__: dict[str, Any]\n    @property\n    def __class__(self: _T) -> Type[_T]: ...\n    # Ignore errors about type mismatch between property getter and setter\n    @__class__.setter\n    def __class__(self, __type: Type[object]) -> None: ...  # type: ignore # noqa: F811\n    def __init__(self) -> None: ...\n    def __new__(cls: Type[_T]) -> _T: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __eq__(self, o: object) -> bool: ...\n    def __ne__(self, o: object) -> bool: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    def __format__(self, format_spec: str) -> str: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __delattr__(self, name: str) -> None: ...\n    def __sizeof__(self) -> int: ...\n    def __reduce__(self) -> str | Tuple[Any, ...]: ...\n    if sys.version_info >= (3, 8):\n        def __reduce_ex__(self, protocol: SupportsIndex) -> str | Tuple[Any, ...]: ...\n    else:\n        def __reduce_ex__(self, protocol: int) -> str | Tuple[Any, ...]: ...\n    def __dir__(self) -> Iterable[str]: ...\n    def __init_subclass__(cls) -> None: ...\n\nclass staticmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass classmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass type(object):\n    __base__: type\n    __bases__: Tuple[type, ...]\n    __basicsize__: int\n    __dict__: dict[str, Any]\n    __dictoffset__: int\n    __flags__: int\n    __itemsize__: int\n    __module__: str\n    __mro__: Tuple[type, ...]\n    __name__: str\n    __qualname__: str\n    __text_signature__: str | None\n    __weakrefoffset__: int\n    @overload\n    def __init__(self, o: object) -> None: ...\n    @overload\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], dict: dict[str, Any], **kwds: Any\n    ) -> None: ...\n    @overload\n    def __new__(cls, o: object) -> type: ...\n    @overload\n    def __new__(\n        cls: Type[_TT],\n        name: str,\n        bases: Tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwds: Any,\n    ) -> _TT: ...\n    def __call__(self, *args: Any, **kwds: Any) -> Any: ...\n    def __subclasses__(self: _TT) -> list[_TT]: ...\n    # Note: the documentation doesnt specify what the return type is, the standard\n    # implementation seems to be returning a list.\n    def mro(self) -> list[type]: ...\n    def __instancecheck__(self, instance: Any) -> bool: ...\n    def __subclasscheck__(self, subclass: type) -> bool: ...\n    @classmethod\n    def __prepare__(\n        metacls, __name: str, __bases: Tuple[type, ...], **kwds: Any\n    ) -> Mapping[str, Any]: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, t: Any) -> types.UnionType: ...\n        def __ror__(self, t: Any) -> types.UnionType: ...\n\nclass super(object):\n    @overload\n    def __init__(self, t: Any, obj: Any) -> None: ...\n    @overload\n    def __init__(self, t: Any) -> None: ...\n    @overload\n    def __init__(self) -> None: ...\n\nclass int:\n    @overload\n    def __new__(\n        cls: Type[_T],\n        x: str | bytes | SupportsInt | SupportsIndex | _SupportsTrunc = ...,\n    ) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], x: str | bytes | bytearray, base: SupportsIndex\n    ) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def as_integer_ratio(self) -> Tuple[int, Literal[1]]: ...\n    @property\n    def real(self) -> int: ...\n    @property\n    def imag(self) -> int: ...\n    @property\n    def numerator(self) -> int: ...\n    @property\n    def denominator(self) -> int: ...\n    def conjugate(self) -> int: ...\n    def bit_length(self) -> int: ...\n    if sys.version_info >= (3, 10):\n        def bit_count(self) -> int: ...\n    def to_bytes(\n        self,\n        length: SupportsIndex,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> bytes: ...\n    @classmethod\n    def from_bytes(\n        cls,\n        bytes: Iterable[SupportsIndex] | SupportsBytes,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> int: ...  # TODO buffer object argument\n    def __add__(self, x: int) -> int: ...\n    def __sub__(self, x: int) -> int: ...\n    def __mul__(self, x: int) -> int: ...\n    def __floordiv__(self, x: int) -> int: ...\n    def __truediv__(self, x: int) -> float: ...\n    def __mod__(self, x: int) -> int: ...\n    def __divmod__(self, x: int) -> Tuple[int, int]: ...\n    def __radd__(self, x: int) -> int: ...\n    def __rsub__(self, x: int) -> int: ...\n    def __rmul__(self, x: int) -> int: ...\n    def __rfloordiv__(self, x: int) -> int: ...\n    def __rtruediv__(self, x: int) -> float: ...\n    def __rmod__(self, x: int) -> int: ...\n    def __rdivmod__(self, x: int) -> Tuple[int, int]: ...\n    @overload\n    def __pow__(self, __x: Literal[2], __modulo: int | None = ...) -> int: ...\n    @overload\n    def __pow__(\n        self, __x: int, __modulo: int | None = ...\n    ) -> Any: ...  # Return type can be int or float, depending on x.\n    def __rpow__(self, x: int, mod: int | None = ...) -> Any: ...\n    def __and__(self, n: int) -> int: ...\n    def __or__(self, n: int) -> int: ...\n    def __xor__(self, n: int) -> int: ...\n    def __lshift__(self, n: int) -> int: ...\n    def __rshift__(self, n: int) -> int: ...\n    def __rand__(self, n: int) -> int: ...\n    def __ror__(self, n: int) -> int: ...\n    def __rxor__(self, n: int) -> int: ...\n    def __rlshift__(self, n: int) -> int: ...\n    def __rrshift__(self, n: int) -> int: ...\n    def __neg__(self) -> int: ...\n    def __pos__(self) -> int: ...\n    def __invert__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    def __round__(self, ndigits: SupportsIndex = ...) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: int) -> bool: ...\n    def __le__(self, x: int) -> bool: ...\n    def __gt__(self, x: int) -> bool: ...\n    def __ge__(self, x: int) -> bool: ...\n    def __str__(self) -> str: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __abs__(self) -> int: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __index__(self) -> int: ...\n\nclass float:\n    def __new__(\n        cls: Type[_T], x: SupportsFloat | SupportsIndex | str | bytes | bytearray = ...\n    ) -> _T: ...\n    def as_integer_ratio(self) -> Tuple[int, int]: ...\n    def hex(self) -> str: ...\n    def is_integer(self) -> bool: ...\n    @classmethod\n    def fromhex(cls, __s: str) -> float: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def conjugate(self) -> float: ...\n    def __add__(self, x: float) -> float: ...\n    def __sub__(self, x: float) -> float: ...\n    def __mul__(self, x: float) -> float: ...\n    def __floordiv__(self, x: float) -> float: ...\n    def __truediv__(self, x: float) -> float: ...\n    def __mod__(self, x: float) -> float: ...\n    def __divmod__(self, x: float) -> Tuple[float, float]: ...\n    def __pow__(\n        self, x: float, mod: None = ...\n    ) -> float: ...  # In Python 3, returns complex if self is negative and x is not whole\n    def __radd__(self, x: float) -> float: ...\n    def __rsub__(self, x: float) -> float: ...\n    def __rmul__(self, x: float) -> float: ...\n    def __rfloordiv__(self, x: float) -> float: ...\n    def __rtruediv__(self, x: float) -> float: ...\n    def __rmod__(self, x: float) -> float: ...\n    def __rdivmod__(self, x: float) -> Tuple[float, float]: ...\n    def __rpow__(self, x: float, mod: None = ...) -> float: ...\n    def __getnewargs__(self) -> Tuple[float]: ...\n    def __trunc__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __ceil__(self) -> int: ...\n        def __floor__(self) -> int: ...\n    @overload\n    def __round__(self, ndigits: None = ...) -> int: ...\n    @overload\n    def __round__(self, ndigits: SupportsIndex) -> float: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: float) -> bool: ...\n    def __le__(self, x: float) -> bool: ...\n    def __gt__(self, x: float) -> bool: ...\n    def __ge__(self, x: float) -> bool: ...\n    def __neg__(self) -> float: ...\n    def __pos__(self) -> float: ...\n    def __str__(self) -> str: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass complex:\n    @overload\n    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], real: str | SupportsComplex | SupportsIndex | complex\n    ) -> _T: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def conjugate(self) -> complex: ...\n    def __add__(self, x: complex) -> complex: ...\n    def __sub__(self, x: complex) -> complex: ...\n    def __mul__(self, x: complex) -> complex: ...\n    def __pow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __truediv__(self, x: complex) -> complex: ...\n    def __radd__(self, x: complex) -> complex: ...\n    def __rsub__(self, x: complex) -> complex: ...\n    def __rmul__(self, x: complex) -> complex: ...\n    def __rpow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __rtruediv__(self, x: complex) -> complex: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __neg__(self) -> complex: ...\n    def __pos__(self) -> complex: ...\n    def __str__(self) -> str: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass _FormatMapMapping(Protocol):\n    def __getitem__(self, __key: str) -> Any: ...\n\nclass str(Sequence[str]):\n    @overload\n    def __new__(cls: Type[_T], o: object = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], o: bytes, encoding: str = ..., errors: str = ...\n    ) -> _T: ...\n    def capitalize(self) -> str: ...\n    def casefold(self) -> str: ...\n    def center(self, __width: SupportsIndex, __fillchar: str = ...) -> str: ...\n    def count(\n        self,\n        x: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def encode(self, encoding: str = ..., errors: str = ...) -> bytes: ...\n    def endswith(\n        self,\n        __suffix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def expandtabs(self, tabsize: SupportsIndex = ...) -> str: ...\n    else:\n        def expandtabs(self, tabsize: int = ...) -> str: ...\n    def find(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def format(self, *args: object, **kwargs: object) -> str: ...\n    def format_map(self, map: _FormatMapMapping) -> str: ...\n    def index(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    if sys.version_info >= (3, 7):\n        def isascii(self) -> bool: ...\n    def isdecimal(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def isidentifier(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isnumeric(self) -> bool: ...\n    def isprintable(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable: Iterable[str]) -> str: ...\n    def ljust(self, __width: SupportsIndex, __fillchar: str = ...) -> str: ...\n    def lower(self) -> str: ...\n    def lstrip(self, __chars: str | None = ...) -> str: ...\n    def partition(self, __sep: str) -> Tuple[str, str, str]: ...\n    def replace(self, __old: str, __new: str, __count: SupportsIndex = ...) -> str: ...\n    if sys.version_info >= (3, 9):\n        def removeprefix(self, __prefix: str) -> str: ...\n        def removesuffix(self, __suffix: str) -> str: ...\n    def rfind(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rjust(self, __width: SupportsIndex, __fillchar: str = ...) -> str: ...\n    def rpartition(self, __sep: str) -> Tuple[str, str, str]: ...\n    def rsplit(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def rstrip(self, __chars: str | None = ...) -> str: ...\n    def split(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def splitlines(self, keepends: bool = ...) -> list[str]: ...\n    def startswith(\n        self,\n        __prefix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __chars: str | None = ...) -> str: ...\n    def swapcase(self) -> str: ...\n    def title(self) -> str: ...\n    def translate(\n        self, __table: Mapping[int, int | str | None] | Sequence[int | str | None]\n    ) -> str: ...\n    def upper(self) -> str: ...\n    def zfill(self, __width: SupportsIndex) -> str: ...\n    @staticmethod\n    @overload\n    def maketrans(\n        __x: dict[int, _T] | dict[str, _T] | dict[str | int, _T]\n    ) -> dict[int, _T]: ...\n    @staticmethod\n    @overload\n    def maketrans(\n        __x: str, __y: str, __z: str | None = ...\n    ) -> dict[int, int | None]: ...\n    def __add__(self, s: str) -> str: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: str) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ge__(self, x: str) -> bool: ...\n    def __getitem__(self, i: int | slice) -> str: ...\n    def __gt__(self, x: str) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __le__(self, x: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def __lt__(self, x: str) -> bool: ...\n    def __mod__(self, x: Any) -> str: ...\n    def __mul__(self, n: SupportsIndex) -> str: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __repr__(self) -> str: ...\n    def __rmul__(self, n: SupportsIndex) -> str: ...\n    def __str__(self) -> str: ...\n    def __getnewargs__(self) -> Tuple[str]: ...\n\nclass bytes(ByteString):\n    @overload\n    def __new__(cls: Type[_T], ints: Iterable[SupportsIndex]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], string: str, encoding: str, errors: str = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], length: SupportsIndex) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], o: SupportsBytes) -> _T: ...\n    def capitalize(self) -> bytes: ...\n    def center(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytes: ...\n    def count(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def endswith(\n        self,\n        __suffix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def expandtabs(self, tabsize: SupportsIndex = ...) -> bytes: ...\n    else:\n        def expandtabs(self, tabsize: int = ...) -> bytes: ...\n    def find(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    if sys.version_info >= (3, 8):\n        def hex(\n            self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...\n        ) -> str: ...\n    else:\n        def hex(self) -> str: ...\n    def index(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    if sys.version_info >= (3, 7):\n        def isascii(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[ByteString | memoryview]) -> bytes: ...\n    def ljust(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytes: ...\n    def lower(self) -> bytes: ...\n    def lstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def partition(self, __sep: bytes) -> Tuple[bytes, bytes, bytes]: ...\n    def replace(\n        self, __old: bytes, __new: bytes, __count: SupportsIndex = ...\n    ) -> bytes: ...\n    if sys.version_info >= (3, 9):\n        def removeprefix(self, __prefix: bytes) -> bytes: ...\n        def removesuffix(self, __suffix: bytes) -> bytes: ...\n    def rfind(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rjust(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytes: ...\n    def rpartition(self, __sep: bytes) -> Tuple[bytes, bytes, bytes]: ...\n    def rsplit(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def rstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def split(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def splitlines(self, keepends: bool = ...) -> list[bytes]: ...\n    def startswith(\n        self,\n        __prefix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def swapcase(self) -> bytes: ...\n    def title(self) -> bytes: ...\n    def translate(self, __table: bytes | None, delete: bytes = ...) -> bytes: ...\n    def upper(self) -> bytes: ...\n    def zfill(self, __width: SupportsIndex) -> bytes: ...\n    @classmethod\n    def fromhex(cls, __s: str) -> bytes: ...\n    @staticmethod\n    def maketrans(__frm: bytes, __to: bytes) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytes: ...\n    def __add__(self, s: bytes) -> bytes: ...\n    def __mul__(self, n: SupportsIndex) -> bytes: ...\n    def __rmul__(self, n: SupportsIndex) -> bytes: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n    def __getnewargs__(self) -> Tuple[bytes]: ...\n\nclass bytearray(MutableSequence[int], ByteString):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, ints: Iterable[SupportsIndex]) -> None: ...\n    @overload\n    def __init__(self, string: str, encoding: str, errors: str = ...) -> None: ...\n    @overload\n    def __init__(self, length: SupportsIndex) -> None: ...\n    def append(self, __item: SupportsIndex) -> None: ...\n    def capitalize(self) -> bytearray: ...\n    def center(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytearray: ...\n    def count(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def copy(self) -> bytearray: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def endswith(\n        self,\n        __suffix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def expandtabs(self, tabsize: SupportsIndex = ...) -> bytearray: ...\n    else:\n        def expandtabs(self, tabsize: int = ...) -> bytearray: ...\n    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...\n    def find(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    if sys.version_info >= (3, 8):\n        def hex(\n            self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...\n        ) -> str: ...\n    else:\n        def hex(self) -> str: ...\n    def index(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def insert(self, __index: SupportsIndex, __item: SupportsIndex) -> None: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    if sys.version_info >= (3, 7):\n        def isascii(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(\n        self, __iterable_of_bytes: Iterable[ByteString | memoryview]\n    ) -> bytearray: ...\n    def ljust(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytearray: ...\n    def lower(self) -> bytearray: ...\n    def lstrip(self, __bytes: bytes | None = ...) -> bytearray: ...\n    def partition(self, __sep: bytes) -> Tuple[bytearray, bytearray, bytearray]: ...\n    if sys.version_info >= (3, 9):\n        def removeprefix(self, __prefix: bytes) -> bytearray: ...\n        def removesuffix(self, __suffix: bytes) -> bytearray: ...\n    def replace(\n        self, __old: bytes, __new: bytes, __count: SupportsIndex = ...\n    ) -> bytearray: ...\n    def rfind(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rjust(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytearray: ...\n    def rpartition(self, __sep: bytes) -> Tuple[bytearray, bytearray, bytearray]: ...\n    def rsplit(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytearray]: ...\n    def rstrip(self, __bytes: bytes | None = ...) -> bytearray: ...\n    def split(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytearray]: ...\n    def splitlines(self, keepends: bool = ...) -> list[bytearray]: ...\n    def startswith(\n        self,\n        __prefix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: bytes | None = ...) -> bytearray: ...\n    def swapcase(self) -> bytearray: ...\n    def title(self) -> bytearray: ...\n    def translate(self, __table: bytes | None, delete: bytes = ...) -> bytearray: ...\n    def upper(self) -> bytearray: ...\n    def zfill(self, __width: SupportsIndex) -> bytearray: ...\n    @classmethod\n    def fromhex(cls, __string: str) -> bytearray: ...\n    @staticmethod\n    def maketrans(__frm: bytes, __to: bytes) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytearray: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, x: SupportsIndex) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, x: Iterable[SupportsIndex] | bytes) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, s: bytes) -> bytearray: ...\n    def __iadd__(self, s: Iterable[int]) -> bytearray: ...\n    def __mul__(self, n: SupportsIndex) -> bytearray: ...\n    def __rmul__(self, n: SupportsIndex) -> bytearray: ...\n    def __imul__(self, n: SupportsIndex) -> bytearray: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n\nclass memoryview(Sized, Sequence[int]):\n    format: str\n    itemsize: int\n    shape: Tuple[int, ...] | None\n    strides: Tuple[int, ...] | None\n    suboffsets: Tuple[int, ...] | None\n    readonly: bool\n    ndim: int\n\n    obj: bytes | bytearray\n    c_contiguous: bool\n    f_contiguous: bool\n    contiguous: bool\n    nbytes: int\n    def __init__(self, obj: ReadableBuffer) -> None: ...\n    def __enter__(self: Self) -> Self: ...\n    def __exit__(\n        self,\n        exc_type: Type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> None: ...\n    def cast(\n        self, format: str, shape: list[int] | Tuple[int, ...] = ...\n    ) -> memoryview: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> memoryview: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __setitem__(self, s: slice, o: bytes) -> None: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: SupportsIndex) -> None: ...\n    if sys.version_info >= (3, 8):\n        def tobytes(self, order: Literal[\"C\", \"F\", \"A\"] | None = ...) -> bytes: ...\n    else:\n        def tobytes(self) -> bytes: ...\n    def tolist(self) -> list[int]: ...\n    if sys.version_info >= (3, 8):\n        def toreadonly(self) -> memoryview: ...\n    def release(self) -> None: ...\n    if sys.version_info >= (3, 8):\n        def hex(\n            self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...\n        ) -> str: ...\n    else:\n        def hex(self) -> str: ...\n\n@final\nclass bool(int):\n    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...\n    @overload\n    def __and__(self, x: bool) -> bool: ...\n    @overload\n    def __and__(self, x: int) -> int: ...\n    @overload\n    def __or__(self, x: bool) -> bool: ...\n    @overload\n    def __or__(self, x: int) -> int: ...\n    @overload\n    def __xor__(self, x: bool) -> bool: ...\n    @overload\n    def __xor__(self, x: int) -> int: ...\n    @overload\n    def __rand__(self, x: bool) -> bool: ...\n    @overload\n    def __rand__(self, x: int) -> int: ...\n    @overload\n    def __ror__(self, x: bool) -> bool: ...\n    @overload\n    def __ror__(self, x: int) -> int: ...\n    @overload\n    def __rxor__(self, x: bool) -> bool: ...\n    @overload\n    def __rxor__(self, x: int) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n\nclass slice(object):\n    start: Any\n    step: Any\n    stop: Any\n    @overload\n    def __init__(self, stop: Any) -> None: ...\n    @overload\n    def __init__(self, start: Any, stop: Any, step: Any = ...) -> None: ...\n    __hash__: None  # type: ignore\n    def indices(self, len: SupportsIndex) -> Tuple[int, int, int]: ...\n\nclass tuple(Sequence[_T_co], Generic[_T_co]):\n    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    @overload\n    def __getitem__(self, x: int) -> _T_co: ...\n    @overload\n    def __getitem__(self, x: slice) -> Tuple[_T_co, ...]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __lt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __le__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __gt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __ge__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    @overload\n    def __add__(self, x: Tuple[_T_co, ...]) -> Tuple[_T_co, ...]: ...\n    @overload\n    def __add__(self, x: Tuple[_T, ...]) -> Tuple[_T_co | _T, ...]: ...\n    def __mul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def __rmul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def count(self, __value: Any) -> int: ...\n    def index(\n        self, __value: Any, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass function:\n    # TODO not defined in builtins!\n    __name__: str\n    __module__: str\n    __code__: CodeType\n    __qualname__: str\n    __annotations__: dict[str, Any]\n\nclass list(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T]) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> list[_T]: ...\n    def append(self, __object: _T) -> None: ...\n    def extend(self, __iterable: Iterable[_T]) -> None: ...\n    def pop(self, __index: SupportsIndex = ...) -> _T: ...\n    def index(\n        self, __value: _T, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n    def count(self, __value: _T) -> int: ...\n    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...\n    def remove(self, __value: _T) -> None: ...\n    def reverse(self) -> None: ...\n    @overload\n    def sort(\n        self: list[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n    ) -> None: ...\n    @overload\n    def sort(\n        self, *, key: Callable[[_T], SupportsLessThan], reverse: bool = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> list[_T]: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, x: list[_T]) -> list[_T]: ...\n    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...\n    def __mul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __rmul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __imul__(self: _S, n: SupportsIndex) -> _S: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __gt__(self, x: list[_T]) -> bool: ...\n    def __ge__(self, x: list[_T]) -> bool: ...\n    def __lt__(self, x: list[_T]) -> bool: ...\n    def __le__(self, x: list[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass dict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    @overload\n    def __init__(self: dict[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(\n        self, map: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT\n    ) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...\n    def clear(self) -> None: ...\n    def copy(self) -> dict[_KT, _VT]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, __key: _KT, __default: _VT = ...) -> _VT: ...\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT]: ...\n    def items(self) -> ItemsView[_KT, _VT]: ...\n    @classmethod\n    @overload\n    def fromkeys(\n        cls, __iterable: Iterable[_T], __value: None = ...\n    ) -> dict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, k: _KT) -> _VT: ...\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    def __delitem__(self, v: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ior__(self, __value: Mapping[_KT, _VT]) -> dict[_KT, _VT]: ...  # type: ignore\n\nclass set(MutableSet[_T], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...\n    def add(self, element: _T) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> Set[_T]: ...\n    def difference(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def difference_update(self, *s: Iterable[Any]) -> None: ...\n    def discard(self, element: _T) -> None: ...\n    def intersection(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def intersection_update(self, *s: Iterable[Any]) -> None: ...\n    def isdisjoint(self, s: Iterable[Any]) -> bool: ...\n    def issubset(self, s: Iterable[Any]) -> bool: ...\n    def issuperset(self, s: Iterable[Any]) -> bool: ...\n    def pop(self) -> _T: ...\n    def remove(self, element: _T) -> None: ...\n    def symmetric_difference(self, s: Iterable[_T]) -> Set[_T]: ...\n    def symmetric_difference_update(self, s: Iterable[_T]) -> None: ...\n    def union(self, *s: Iterable[_T]) -> Set[_T]: ...\n    def update(self, *s: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __iand__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __or__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ior__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __sub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __isub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass frozenset(AbstractSet[_T_co], Generic[_T_co]):\n    def __init__(self, iterable: Iterable[_T_co] = ...) -> None: ...\n    def copy(self) -> FrozenSet[_T_co]: ...\n    def difference(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def intersection(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def isdisjoint(self, s: Iterable[_T_co]) -> bool: ...\n    def issubset(self, s: Iterable[object]) -> bool: ...\n    def issuperset(self, s: Iterable[object]) -> bool: ...\n    def symmetric_difference(self, s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def union(self, *s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __sub__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass enumerate(Iterator[Tuple[int, _T]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], start: int = ...) -> None: ...\n    def __iter__(self) -> Iterator[Tuple[int, _T]]: ...\n    def __next__(self) -> Tuple[int, _T]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass range(Sequence[int]):\n    start: int\n    stop: int\n    step: int\n    @overload\n    def __init__(self, stop: SupportsIndex) -> None: ...\n    @overload\n    def __init__(\n        self, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ...\n    ) -> None: ...\n    def count(self, value: int) -> int: ...\n    def index(self, value: int) -> int: ...  # type: ignore\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> range: ...\n    def __repr__(self) -> str: ...\n    def __reversed__(self) -> Iterator[int]: ...\n\nclass property(object):\n    fget: Callable[[Any], Any] | None\n    fset: Callable[[Any, Any], None] | None\n    fdel: Callable[[Any], None] | None\n    def __init__(\n        self,\n        fget: Callable[[Any], Any] | None = ...,\n        fset: Callable[[Any, Any], None] | None = ...,\n        fdel: Callable[[Any], None] | None = ...,\n        doc: str | None = ...,\n    ) -> None: ...\n    def getter(self, fget: Callable[[Any], Any]) -> property: ...\n    def setter(self, fset: Callable[[Any, Any], None]) -> property: ...\n    def deleter(self, fdel: Callable[[Any], None]) -> property: ...\n    def __get__(self, obj: Any, type: type | None = ...) -> Any: ...\n    def __set__(self, obj: Any, value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nclass _NotImplementedType(Any):  # type: ignore\n    # A little weird, but typing the __call__ as NotImplemented makes the error message\n    # for NotImplemented() much better\n    __call__: NotImplemented  # type: ignore\n\nNotImplemented: _NotImplementedType\n\ndef abs(__x: SupportsAbs[_T]) -> _T: ...\ndef all(__iterable: Iterable[object]) -> bool: ...\ndef any(__iterable: Iterable[object]) -> bool: ...\ndef bin(__number: int | SupportsIndex) -> str: ...\n\nif sys.version_info >= (3, 7):\n    def breakpoint(*args: Any, **kws: Any) -> None: ...\n\ndef callable(__obj: object) -> bool: ...\ndef chr(__i: int) -> str: ...\n\n# We define this here instead of using os.PathLike to avoid import cycle issues.\n# See https://github.com/python/typeshed/pull/991#issuecomment-288160993\n_AnyStr_co = TypeVar(\"_AnyStr_co\", str, bytes, covariant=True)\n\nclass _PathLike(Protocol[_AnyStr_co]):\n    def __fspath__(self) -> _AnyStr_co: ...\n\nif sys.version_info >= (3, 10):\n    def aiter(__iterable: AsyncIterable[_T]) -> AsyncIterator[_T]: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T]) -> _T: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T], default: _VT) -> _T | _VT: ...\n\ndef delattr(__obj: Any, __name: str) -> None: ...\ndef dir(__o: object = ...) -> list[str]: ...\n@overload\ndef divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...\n@overload\ndef divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...\ndef eval(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\ndef exec(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\ndef exit(code: object = ...) -> NoReturn: ...\n\nclass filter(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __function: None, __iterable: Iterable[_T | None]) -> None: ...\n    @overload\n    def __init__(\n        self, __function: Callable[[_T], Any], __iterable: Iterable[_T]\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\n@overload\ndef getattr(__o: object, name: str) -> Any: ...\n\n# While technically covered by the last overload, spelling out the types for None and bool\n# help mypy out in some tricky situations involving type context (aka bidirectional inference)\n@overload\ndef getattr(__o: object, name: str, __default: None) -> Any | None: ...\n@overload\ndef getattr(__o: object, name: str, __default: bool) -> Any | bool: ...\n@overload\ndef getattr(__o: object, name: str, __default: _T) -> Any | _T: ...\ndef globals() -> dict[str, Any]: ...\ndef hasattr(__obj: object, __name: str) -> bool: ...\ndef hash(__obj: object) -> int: ...\ndef help(*args: Any, **kwds: Any) -> None: ...\ndef hex(__number: int | SupportsIndex) -> str: ...\ndef id(__obj: object) -> int: ...\ndef input(__prompt: Any = ...) -> str: ...\n@overload\ndef iter(__iterable: Iterable[_T]) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T | None], __sentinel: None) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T], __sentinel: Any) -> Iterator[_T]: ...\n\nif sys.version_info >= (3, 10):\n    def isinstance(\n        __obj: object,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n    def issubclass(\n        __cls: type,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n\nelse:\n    def isinstance(\n        __obj: object, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n    def issubclass(\n        __cls: type, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n\ndef len(__obj: Sized) -> int: ...\ndef locals() -> dict[str, Any]: ...\n\nclass map(Iterator[_S], Generic[_S]):\n    @overload\n    def __init__(self, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[..., _S],\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_S]: ...\n    def __next__(self) -> _S: ...\n\n@overload\ndef max(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef max(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef max(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef min(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef min(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef min(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef next(__i: Iterator[_T]) -> _T: ...\n@overload\ndef next(__i: Iterator[_T], default: _VT) -> _T | _VT: ...\ndef oct(__number: int | SupportsIndex) -> str: ...\n\n_OpenFile = Union[StrOrBytesPath, int]\n_Opener = Callable[[str, int], int]\n\n# Text mode: always returns a TextIOWrapper\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenTextMode = ...,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> TextIO: ...\n\n# Unbuffered binary mode: returns a FileIO\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryMode,\n    buffering: int = ...,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BinaryIO: ...\n\n# Fallback if mode is not specified\n@overload\ndef open(\n    file: _OpenFile,\n    mode: str,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> IO[Any]: ...\ndef ord(__c: str | bytes) -> int: ...\ndef print(\n    *values: object,\n    sep: str | None = ...,\n    end: str | None = ...,\n    file: SupportsWrite[str] | None = ...,\n    flush: bool = ...,\n) -> None: ...\n\n_E = TypeVar(\"_E\", contravariant=True)\n_M = TypeVar(\"_M\", contravariant=True)\n\nclass _SupportsPow2(Protocol[_E, _T_co]):\n    def __pow__(self, __other: _E) -> _T_co: ...\n\nclass _SupportsPow3(Protocol[_E, _M, _T_co]):\n    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def pow(\n        base: int, exp: int, mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(base: int, exp: int, mod: int) -> int: ...\n    @overload\n    def pow(base: float, exp: float, mod: None = ...) -> float: ...\n    @overload\n    def pow(base: _SupportsPow2[_E, _T_co], exp: _E) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsPow3[_E, _M, _T_co], exp: _E, mod: _M) -> _T_co: ...\n\nelse:\n    @overload\n    def pow(\n        __base: int, __exp: int, __mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(__base: int, __exp: int, __mod: int) -> int: ...\n    @overload\n    def pow(__base: float, __exp: float, __mod: None = ...) -> float: ...\n    @overload\n    def pow(__base: _SupportsPow2[_E, _T_co], __exp: _E) -> _T_co: ...\n    @overload\n    def pow(__base: _SupportsPow3[_E, _M, _T_co], __exp: _E, __mod: _M) -> _T_co: ...\n\nclass reversed(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __sequence: Reversible[_T]) -> None: ...\n    @overload\n    def __init__(self, __sequence: SupportsLenAndGetItem[_T]) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\ndef repr(__obj: object) -> str: ...\n@overload\ndef round(number: SupportsRound[Any]) -> int: ...\n@overload\ndef round(number: SupportsRound[Any], ndigits: None) -> int: ...\n@overload\ndef round(number: SupportsRound[_T], ndigits: SupportsIndex) -> _T: ...\ndef setattr(__obj: object, __name: str, __value: Any) -> None: ...\n@overload\ndef sorted(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n) -> list[SupportsLessThanT]: ...\n@overload\ndef sorted(\n    __iterable: Iterable[_T],\n    *,\n    key: Callable[[_T], SupportsLessThan],\n    reverse: bool = ...,\n) -> list[_T]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], start: _S) -> _T | _S: ...\n\nelse:\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], __start: _S) -> _T | _S: ...\n\nclass zip(Iterator[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1]) -> zip[Tuple[_T1]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]\n    ) -> zip[Tuple[_T1, _T2]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]\n    ) -> zip[Tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> zip[Tuple[Any, ...]]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __next__(self) -> _T_co: ...\n\ndef __import__(\n    name: str,\n    globals: Mapping[str, Any] | None = ...,\n    locals: Mapping[str, Any] | None = ...,\n    fromlist: Sequence[str] = ...,\n    level: int = ...,\n) -> Any: ...\n\n# Actually the type of Ellipsis is <type 'ellipsis'>, but since it's\n# not exposed anywhere under that name, we make it private here.\nclass ellipsis: ...\n\nEllipsis: ellipsis\n\nclass BaseException(object):\n    args: Tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def with_traceback(self: _TBE, tb: TracebackType | None) -> _TBE: ...\n\nclass GeneratorExit(BaseException): ...\nclass KeyboardInterrupt(BaseException): ...\n\nclass SystemExit(BaseException):\n    code: int\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n\n_StandardError = Exception\n\nclass OSError(Exception):\n    errno: int\n    strerror: str\n    # filename, filename2 are actually str | bytes | None\n    filename: Any\n    filename2: Any\n    if sys.platform == \"win32\":\n        winerror: int\n\nif sys.platform == \"win32\":\n    WindowsError = OSError\n\nclass ArithmeticError(_StandardError): ...\nclass AssertionError(_StandardError): ...\n\nclass AttributeError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n        obj: object\n\nclass EOFError(_StandardError): ...\n\nclass ImportError(_StandardError):\n    def __init__(\n        self, *args: object, name: str | None = ..., path: str | None = ...\n    ) -> None: ...\n    name: str | None\n    path: str | None\n    msg: str  # undocumented\n\nclass LookupError(_StandardError): ...\nclass MemoryError(_StandardError): ...\n\nclass NameError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n\nclass RuntimeError(_StandardError): ...\n\nclass StopAsyncIteration(Exception):\n    value: Any\n\nclass SyntaxError(_StandardError):\n    msg: str\n    lineno: int | None\n    offset: int | None\n    text: str | None\n    filename: str | None\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n        end_offset: int | None\n\nclass TypeError(_StandardError): ...\nclass ValueError(_StandardError): ...\nclass FloatingPointError(ArithmeticError): ...\nclass OverflowError(ArithmeticError): ...\nclass ZeroDivisionError(ArithmeticError): ...\nclass IndexError(LookupError): ...\nclass KeyError(LookupError): ...\nclass NotImplementedError(RuntimeError): ...\nclass IndentationError(SyntaxError): ...\nclass TabError(IndentationError): ...\n",
    "/typeshed/stdlib/errno.pyi": "from uerrno import *\n",
    "/typeshed/stdlib/gc.pyi": "\"\"\"Control the garbage collector\"\"\"\n\nfrom typing import overload\n\ndef enable() -> None:\n    \"\"\"Enable automatic garbage collection.\"\"\"\n    ...\n\ndef disable() -> None:\n    \"\"\"Disable automatic garbage collection.  Heap memory can still be allocated,\n    and garbage collection can still be initiated manually using :meth:`gc.collect`.\"\"\"\n\ndef collect() -> None:\n    \"\"\"Run a garbage collection.\"\"\"\n    ...\n\ndef mem_alloc() -> int:\n    \"\"\"Return the number of bytes of heap RAM that are allocated.\n\n    .. admonition:: Difference to CPython\n        :class: attention\n\n        This function is MicroPython extension.\n    \"\"\"\n    ...\n\ndef mem_free() -> int:\n    \"\"\"Return the number of bytes of available heap RAM, or -1 if this amount\n    is not known.\n\n    .. admonition:: Difference to CPython\n        :class: attention\n\n        This function is MicroPython extension.\n    \"\"\"\n    ...\n\n@overload\ndef threshold() -> int:\n    \"\"\"Query the additional GC allocation threshold.\n\n    .. admonition:: Difference to CPython\n        :class: attention\n\n        This function is a MicroPython extension. CPython has a similar\n        function - ``set_threshold()``, but due to different GC\n        implementations, its signature and semantics are different.\n    \"\"\"\n    ...\n\n@overload\ndef threshold(amount: int) -> None:\n    \"\"\"Set the additional GC allocation threshold. Normally, a collection\n    is triggered only when a new allocation cannot be satisfied, i.e. on an\n    out-of-memory (OOM) condition. If this function is called, in addition to\n    OOM, a collection will be triggered each time after *amount* bytes have been\n    allocated (in total, since the previous time such an amount of bytes\n    have been allocated). *amount* is usually specified as less than the\n    full heap size, with the intention to trigger a collection earlier than when the\n    heap becomes exhausted, and in the hope that an early collection will prevent\n    excessive memory fragmentation. This is a heuristic measure, the effect\n    of which will vary from application to application, as well as\n    the optimal value of the *amount* parameter.\n\n    A value of -1 means a disabled allocation threshold.\n\n    .. admonition:: Difference to CPython\n        :class: attention\n\n        This function is a MicroPython extension. CPython has a similar\n        function - ``set_threshold()``, but due to different GC\n        implementations, its signature and semantics are different.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/love.pyi": "def badaboom() -> None: ...\n",
    "/typeshed/stdlib/machine.pyi": "\"\"\"The machine module contains specific functions related to the micro:bit \nhardware. Most functions in this module allow to achieve direct and \nunrestricted access to and control of hardware blocks on a system (like CPU, \ntimers, buses, etc.). Used incorrectly, this can lead to malfunction, lockups, \ncrashes of your board, and in extreme cases, hardware damage.\n\"\"\"\nfrom .microbit import MicroBitDigitalPin\n\ndef unique_id() -> bytes:\n    \"\"\"Returns a byte string with a unique identifier of a board. It will vary\n    from one board instance to another.\n    \"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Resets the device in a manner similar to pushing the external RESET button.\"\"\"\n    ...\n\ndef freq() -> int:\n    \"\"\"Returns CPU frequency in hertz.\"\"\"\n    ...\n\ndef disable_irq() -> None:\n    \"\"\"Disable interrupt requests. Returns the previous IRQ state which should be\n    considered an opaque value. This return value should be passed to the\n    :func:`machine.enable_irq()` function to restore interrupts to their\n    original state, before :func:`machine.disable_irq()` was called.\n    \"\"\"\n    ...\n\ndef enable_irq() -> None:\n    \"\"\"Re-enable interrupt requests. The *state* parameter should be the value\n    that was returned from the most recent call to the\n    :func:`machine.disable_irq()` function.\n    \"\"\"\n    ...\n\ndef time_pulse_us(\n    pin: MicroBitDigitalPin, pulse_level: int, timeout_us: int = 1000000\n) -> int:\n    \"\"\"Time a pulse on the given *pin*, and return the duration of the pulse in\n    microseconds. The *pulse_level* argument should be 0 to time a low pulse or\n    1 to time a high pulse.\n\n    If the current input value of the pin is different to *pulse_level*, the\n    function first (*) waits until the pin input becomes equal to\n    *pulse_level*, then (**) times the duration that the pin is equal to\n    *pulse_level*. If the pin is already equal to *pulse_level* then timing\n    starts straight away.\n\n    The function will return -2 if there was timeout waiting for condition\n    marked (*) above, and -1 if there was timeout during the main measurement,\n    marked (**) above. The timeout is the same for both cases and given by\n    *timeout_us* (which is in microseconds).\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/math.pyi": "\"\"\"The ``math`` module provides some basic mathematical functions for\nworking with floating-point numbers.\n\"\"\"\n\nfrom typing import Tuple\n\ndef acos(x: float) -> float:\n    \"\"\"Return the inverse cosine of ``x``.\"\"\"\n    ...\n\ndef asin(x: float) -> float:\n    \"\"\"Return the inverse sine of ``x``.\"\"\"\n    ...\n\ndef atan(x: float) -> float:\n    \"\"\"Return the inverse tangent of ``x``.\"\"\"\n    ...\n\ndef atan2(y: float, x: float) -> float:\n    \"\"\"Return the principal value of the inverse tangent of ``y/x``.\"\"\"\n    ...\n\ndef ceil(x: float) -> int:\n    \"\"\"Return an integer, being ``x`` rounded towards positive infinity.\"\"\"\n    ...\n\ndef copysign(x: float, y: float) -> float:\n    \"\"\"Return ``x`` with the sign of ``y``.\"\"\"\n    ...\n\ndef cos(x: float) -> float:\n    \"\"\"Return the cosine of ``x``.\"\"\"\n    ...\n\ndef degrees(x: float) -> float:\n    \"\"\"Return radians ``x`` converted to degrees.\"\"\"\n    ...\n\ndef exp(x: float) -> float:\n    \"\"\"Return the exponential of ``x``.\"\"\"\n    ...\n\ndef fabs(x: float) -> float:\n    \"\"\"Return the absolute value of ``x``.\"\"\"\n    ...\n\ndef floor(x: float) -> int:\n    \"\"\"Return an integer, being ``x`` rounded towards negative infinity.\"\"\"\n    ...\n\ndef fmod(x: float, y: float) -> float:\n    \"\"\"Return the remainder of ``x/y``.\"\"\"\n    ...\n\ndef frexp(x: float) -> Tuple[float, int]:\n    \"\"\"Decomposes a floating-point number into its mantissa and exponent.\n    The returned value is the tuple ``(m, e)`` such that ``x == m * 2**e``\n    exactly.  If ``x == 0`` then the function returns ``(0.0, 0)``, otherwise\n    the relation ``0.5 <= abs(m) < 1`` holds.\n    \"\"\"\n    ...\n\ndef isfinite(x: float) -> bool:\n    \"\"\"Return ``True`` if ``x`` is finite.\"\"\"\n    ...\n\ndef isinf(x: float) -> bool:\n    \"\"\"Return ``True`` if ``x`` is infinite.\"\"\"\n    ...\n\ndef isnan(x: float) -> bool:\n    \"\"\"Return ``True`` if ``x`` is not-a-number\"\"\"\n    ...\n\ndef ldexp(x: float, i: int) -> float:\n    \"\"\"Return ``x * (2**exp)``.\"\"\"\n    ...\n\ndef log(x: float) -> float:\n    \"\"\"Return the natural logarithm of ``x``.\"\"\"\n    ...\n\ndef modf(x: float) -> Tuple[float, float]:\n    \"\"\"Return a tuple of two floats, being the fractional and integral parts of\n    ``x``.  Both return values have the same sign as ``x``.\n    \"\"\"\n    ...\n\ndef pow(x: float, y: float) -> float:\n    \"\"\"Returns ``x`` to the power of ``y``.\"\"\"\n    ...\n\ndef radians(x: float) -> float:\n    \"\"\"Return degrees ``x`` converted to radians.\"\"\"\n    ...\n\ndef sin(x: float) -> float:\n    \"\"\"Return the sine of ``x``.\"\"\"\n    ...\n\ndef sqrt(x: float) -> float:\n    \"\"\"Return the square root of ``x``.\"\"\"\n    ...\n\ndef tan(x: float) -> float:\n    \"\"\"Return the tangent of ``x``.\"\"\"\n    ...\n\ndef trunc(x: float) -> int:\n    \"\"\"Return an integer, being ``x`` rounded towards 0.\"\"\"\n    ...\n\ne: float\n\"\"\"base of the natural logarithm\"\"\"\n\npi: float\n\"\"\"the ratio of a circle's circumference to its diameter\"\"\"\n",
    "/typeshed/stdlib/micropython.pyi": "\"\"\"Access and control MicroPython internals.\"\"\"\n\nfrom typing import Any, overload\n\ndef const(expr: Any) -> Any:\n    \"\"\"Used to declare that the expression is a constant so that the compiler can\n    optimise it. The use of this function should be as follows:\n\n    .. code-block:: python\n\n        from micropython import const\n        CONST_X = const(123)\n        CONST_Y = const(2 * CONST_X + 1)\n\n    Constants declared this way are still accessible as global variables from\n    outside the module they are declared in. On the other hand, if a constant\n    begins with an underscore then it is hidden, it is not available as a\n    global variable, and does not take up any memory during execution.\n    \"\"\"\n    ...\n\n@overload\ndef opt_level() -> int:\n    \"\"\"Returns the current optimisation level for the compilation of scripts.\n\n    The optimisation level controls the following compilation features:\n\n    *   Assertions: at level 0 assertion statements are enabled and compiled\n        into the bytecode; at levels 1 and higher assertions are not compiled.\n\n    *   Built-in ``__debug__`` variable: at level 0 this variable expands to\n        True; at levels 1 and higher it expands to False.\n\n    *   Source-code line numbers: at levels 0, 1 and 2 source-code line number\n        are stored along with the bytecode so that exceptions can report the\n        line number they occurred at; at levels 3 and higher line numbers are\n        not stored.\n    \"\"\"\n    ...\n\n@overload\ndef opt_level(level: int) -> None:\n    \"\"\"Sets the optimisation level for subsequent compilation of scripts.\n\n    The optimisation level controls the following compilation features:\n\n    *   Assertions: at level 0 assertion statements are enabled and compiled\n        into the bytecode; at levels 1 and higher assertions are not compiled.\n\n    *   Built-in ``__debug__`` variable: at level 0 this variable expands to\n        True; at levels 1 and higher it expands to False.\n\n    *   Source-code line numbers: at levels 0, 1 and 2 source-code line number\n        are stored along with the bytecode so that exceptions can report the\n        line number they occurred at; at levels 3 and higher line numbers are\n        not stored.\n\n    The default optimisation level is usually level 0.\n    \"\"\"\n    ...\n\n@overload\ndef mem_info() -> None:\n    \"\"\"Print information about currently used memory.  If the *verbose* argument\n    is given then extra information is printed.\"\"\"\n    ...\n\n@overload\ndef mem_info(verbose: Any) -> None: ...\n@overload\ndef qstr_info() -> None:\n    \"\"\"Print information about currently interned strings.  If the *verbose*\n    argument is given then extra information is printed.\n\n    The information that is printed is implementation dependent, but currently\n    includes the number of interned strings and the amount of RAM they use.  In\n    verbose mode it prints out the names of all RAM-interned strings.\n    \"\"\"\n    ...\n\n@overload\ndef qstr_info(verbose: Any) -> None: ...\ndef stack_use() -> int:\n    \"\"\"Return an integer representing the current amount of stack that is being\n    used.  The absolute value of this is not particularly useful, rather it\n    should be used to compute differences in stack usage at different points.\n    \"\"\"\n    ...\n\ndef heap_lock() -> None:\n    \"\"\"Lock the heap.  When locked no memory allocation can occur and a\n    `MemoryError` will be raised if any heap allocation is attempted.\n    \"\"\"\n    ...\n\ndef heap_unlock() -> None:\n    \"\"\"Unlock the heap.  When locked no memory allocation can occur and a\n    `MemoryError` will be raised if any heap allocation is attempted.\n    \"\"\"\n    ...\n\ndef kbd_intr(chr: int) -> None:\n    \"\"\"Set the character that will raise a `KeyboardInterrupt` exception.  By\n    default this is set to 3 during script execution, corresponding to Ctrl-C.\n    Passing -1 to this function will disable capture of Ctrl-C, and passing 3\n    will restore it.\n\n    This function can be used to prevent the capturing of Ctrl-C on the\n    incoming stream of characters that is usually used for the REPL, in case\n    that stream is used for other purposes.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/music.pyi": "\"\"\"This is the ``music`` module and you can use it to create and play melodies.\nBy default sound output will be via the edge connector on pin 0 and the\n:doc:`built-in speaker <speaker>` **V2**. You can connect wired headphones or\na speaker to pin 0 and GND on the edge connector to hear the sound:\n\"\"\"\nfrom typing import Tuple, Union, List\n\nfrom .microbit import MicroBitDigitalPin, pin0\n\nDADADADUM: Tuple[str, ...]\nENTERTAINER: Tuple[str, ...]\nPRELUDE: Tuple[str, ...]\nODE: Tuple[str, ...]\nNYAN: Tuple[str, ...]\nRINGTONE: Tuple[str, ...]\nFUNK: Tuple[str, ...]\nBLUES: Tuple[str, ...]\nBIRTHDAY: Tuple[str, ...]\nWEDDING: Tuple[str, ...]\nFUNERAL: Tuple[str, ...]\nPUNCHLINE: Tuple[str, ...]\nPYTHON: Tuple[str, ...]\nBADDY: Tuple[str, ...]\nCHASE: Tuple[str, ...]\nBA_DING: Tuple[str, ...]\nWAWAWAWAA: Tuple[str, ...]\nJUMP_UP: Tuple[str, ...]\nJUMP_DOWN: Tuple[str, ...]\nPOWER_UP: Tuple[str, ...]\nPOWER_DOWN: Tuple[str, ...]\n\ndef set_tempo(ticks: int = ..., bpm: int = ...) -> None:\n    \"\"\"\n    Sets the approximate tempo for playback.\n\n    A number of ticks (expressed as an integer) constitute a beat.\n    Each beat is to be played at a certain frequency per minute\n    (expressed as the more familiar BPM - beats per minute -\n     also as an integer).\n\n    Suggested default values allow the following useful behaviour:\n\n        music.set_tempo() - reset the tempo to default of ticks = 4, bpm = 120\n        music.set_tempo(ticks=8) - change the \u201cdefinition\u201d of a beat\n        music.set_tempo(bpm=180) - just change the tempo\n\n    To work out the length of a tick in milliseconds is very simple arithmetic:\n    60000/bpm/ticks_per_beat . For the default values that\u2019s\n    60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.\n    \"\"\"\n    ...\n\ndef get_tempo(self) -> Tuple[int, int]:\n    \"\"\"\n    Gets the current tempo as a tuple of integers: (ticks, bpm).\n    \"\"\"\n    ...\n\ndef play(\n    music: Union[str, List[str], Tuple[str, ...]],\n    pin: MicroBitDigitalPin = ...,\n    wait: bool = True,\n    loop: bool = False,\n) -> None:\n    \"\"\"Plays ``music`` containing the musical DSL defined above.\n\n    If ``music`` is a string it is expected to be a single note such as,\n    ``'c1:4'``.\n\n    If ``music`` is specified as a list of notes (as defined in the section on\n    the musical DSL, above) then they are played one after the other to perform\n    a melody.\n\n    In both cases, the ``duration`` and ``octave`` values are reset to\n    their defaults before the music (whatever it may be) is played.\n\n    An optional argument to specify the output pin can be used to override the\n    default of ``microbit.pin0``. If we do not want any sound to play we can\n    use ``pin=None``.\n\n    If ``wait`` is set to ``True``, this function is blocking.\n\n    If ``loop`` is set to ``True``, the tune repeats until ``stop`` is called\n    (see below) or the blocking call is interrupted.\n    \"\"\"\n    ...\n\ndef pitch(\n    frequency: int, duration=..., pin: MicroBitDigitalPin = ..., wait: bool = ...\n) -> None:\n    \"\"\"Plays a pitch at the integer frequency given for the specified number of\n    milliseconds. For example, if the frequency is set to 440 and the length to\n    1000 then we hear a standard concert A for one second.\n\n    Note that you can only play one pitch on one pin at any one time.\n\n    An optional argument to specify the output pin can be used to override the\n    default of ``microbit.pin0``. If we do not want any sound to play out of\n    the pins we can use ``pin=None``.\n\n    If ``wait`` is set to ``True``, this function is blocking.\n\n    If ``duration`` is negative the pitch is played continuously until either\n    the blocking call is interrupted or, in the case of a background call, a\n    new frequency is set or ``stop`` is called (see below).\n    \"\"\"\n    ...\n\ndef stop(pin: MicroBitDigitalPin = pin0) -> None:\n    \"\"\"Stops all music playback on the built-in speaker and any pin outputting\n    sound. An optional argument can be provided to specify a pin, eg.\n    ``music.stop(pin1)``.\n    \"\"\"\n\ndef reset() -> None:\n    \"\"\"Resets the state of the following attributes in the following way:\n\n    * ``ticks = 4``\n    * ``bpm = 120``\n    * ``duration = 4``\n    * ``octave = 4``\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/neopixel.pyi": "\"\"\"\nThe ``neopixel`` module lets you use NeoPixel (WS2812) individually addressable\nRGB and RGBW **V2** LED strips with the micro:bit. Note to use the ``neopixel`` module, you\nneed to import it separately with::\n\n    import neopixel\n\n.. note::\n\n    From our tests, the Microbit NeoPixel module can drive up to around 256\n    NeoPixels. Anything above that and you may experience weird bugs and\n    issues. The micro:bit can only supply 90mA **V1** or 190mA **V2**  to\n    external devices,larger numbers of NeoPixels require an external power\n    supply with common ground.\n\n    NeoPixels are designed to work at 5V, but luckily they still function using\n    the 3V supply of the BBC micro:bit. Please note that the micro:bit edge\n    connector should not be connected to anything supplying 5V.\n\nNeoPixels are fun strips of multi-coloured programmable LEDs. This module\ncontains everything to plug them into a micro:bit and create funky displays,\nart and games.\n\nTo connect a strip of neopixels you'll need to attach the micro:bit as shown\nbelow (assuming you want to drive the pixels from pin 0 - you can connect\nneopixels to pins 1 and 2 too). The label on the crocodile clip tells you where\nto attach the other end on the neopixel strip. The VDD pin may be labelled\nas something else on some variants of neopixels - for example \"V+\". In some\ncases it may be called \"+5V\" and it is only safe to use this if you have no\nother 5V devices connected.\n\n.. warning::\n\n    Do not use the 3v connector on the micro:bit to power any more than 8\n    Neopixels at a time.\n\n    If you wish to use more than 8 Neopixels, you must use a separate 3v-5v\n    power supply for the Neopixel power pin.\n\"\"\"\nfrom .microbit import MicroBitDigitalPin\nfrom typing import Tuple\n\nclass NeoPixel:\n    def __init__(self, pin: MicroBitDigitalPin, n: int, bpp: int = ...) -> None:\n        \"\"\"\n        Initialise a new strip of ``n`` number of neopixel LEDs controlled via pin\n        ``pin``. The **V2** micro:bit can also support RGBW neopixels, so a third\n        argument can be passed to ``NeoPixel`` to indicate the number of bytes per\n        pixel (bpp). For RGBW, this is is ``4`` rather than the default of ``3`` for\n        RGB and GRB.\n        \"\"\"\n        ...\n    def clear(self) -> None:\n        \"\"\"\n        Clear all the pixels.\n        \"\"\"\n        ...\n    def show(self) -> None:\n        \"\"\"\n        Show the pixels. Must be called for any updates to become visible.\n        \"\"\"\n        ...\n    def write(self) -> None:\n        \"\"\"\n        **V2** Show the pixels. Must be called for any updates to become visible.\n\n        Equivalent to ``show``.\n        \"\"\"\n        ...\n    def fill(self, colour: Tuple[int, ...]) -> None:\n        \"\"\"\n        **V2** Colour all pixels a given RGB/RGBW value. The `colour` argument\n        should be a tuple of the same length as the mumber of bytes per pixel\n        (bpp). For example ``fill((0,0,255))``. Use in conjunction with\n        ``show()`` to update the Neopixels.\n        \"\"\"\n        ...\n    def __setitem__(self, key: int, value: Tuple[int, ...]) -> None: ...\n    def __getitem__(self, key: int) -> Tuple[int, ...]: ...\n    def __len__(self) -> int: ...\n",
    "/typeshed/stdlib/os.pyi": "from uos import *\n",
    "/typeshed/stdlib/radio.pyi": "\"\"\"The ``radio`` module allows devices to work together via simple wireless\nnetworks.\n\nThe radio module is conceptually very simple:\n\n* Broadcast messages are of a certain configurable length (up to 251 bytes).\n* Messages received are read from a queue of configurable size (the larger the queue the more RAM is used). If the queue is full, new messages are ignored. Reading a message removes it from the queue.\n* Messages are broadcast and received on a preselected channel (numbered 0-83).\n* Broadcasts are at a certain level of power - more power means more range.\n* Messages are filtered by address (like a house number) and group (like a named recipient at the specified address).\n* The rate of throughput can be one of three pre-determined settings.\n* Send and receive bytes to work with arbitrary data.\n* Use `receive_full` to obtain full details about an incoming message: the data, receiving signal strength, and a microsecond timestamp when the message arrived.\n* As a convenience for children, it's easy to send and receive messages as strings.\n* The default configuration is both sensible and compatible with other platforms that target the BBC micro:bit.\n\nTo access this module you need to::\n\n    import radio\n\"\"\"\n\nfrom typing import Optional, Tuple\n\nRATE_250KBIT: int\n\"\"\"Constant used to indicate a throughput of 256 Kbit a second. Not available on **V2**.\"\"\"\n\nRATE_1MBIT: int\n\"\"\"Constant used to indicate a throughput of 1 MBit a second.\"\"\"\n\nRATE_2MBIT: int\n\"\"\"Constant used to indicate a throughput of 2 MBit a second.\"\"\"\n\ndef on() -> None:\n    \"\"\"Turns the radio on. This needs to be explicitly called since the radio\n    draws power and takes up memory that you may otherwise need.\n    \"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Turns off the radio, thus saving power and memory.\"\"\"\n    ...\n\ndef config(\n    length: int = 32,\n    queue: int = 3,\n    channel: int = 7,\n    power: int = 6,\n    address: int = 0x75626974,\n    group: int = 0,\n    data_rate: int = RATE_1MBIT,\n) -> None:\n    \"\"\"Configures various keyword based settings relating to the radio. The\n    available settings and their sensible default values are listed below.\n\n    The ``length`` (default=32) defines the maximum length, in bytes, of a\n    message sent via the radio. It can be up to 251 bytes long (254 - 3 bytes\n    for S0, LENGTH and S1 preamble).\n\n    The ``queue`` (default=3) specifies the number of messages that can be\n    stored on the incoming message queue. If there are no spaces left on the\n    queue for incoming messages, then the incoming message is dropped.\n\n    The ``channel`` (default=7) can be an integer value from 0 to 83\n    (inclusive) that defines an arbitrary \"channel\" to which the radio is\n    tuned. Messages will be sent via this channel and only messages received\n    via this channel will be put onto the incoming message queue. Each step is\n    1MHz wide, based at 2400MHz.\n\n    The ``power`` (default=6) is an integer value from 0 to 7 (inclusive) to\n    indicate the strength of signal used when broadcasting a message. The\n    higher the value the stronger the signal, but the more power is consumed\n    by the device. The numbering translates to positions in the following list\n    of dBm (decibel milliwatt) values: -30, -20, -16, -12, -8, -4, 0, 4.\n\n    The ``address`` (default=0x75626974) is an arbitrary name, expressed as a\n    32-bit address, that's used to filter incoming packets at the hardware\n    level, keeping only those that match the address you set. The default used\n    by other micro:bit related platforms is the default setting used here.\n\n    The ``group`` (default=0) is an 8-bit value (0-255) used with the\n    ``address`` when filtering messages. Conceptually, \"address\" is like a\n    house/office address and \"group\" is like the person at that address to\n    which you want to send your message.\n\n    The ``data_rate`` (default=radio.RATE_1MBIT) indicates the speed at which\n    data throughput takes place. Can be one of the following contants defined\n    in the ``radio`` module : ``RATE_250KBIT``, ``RATE_1MBIT`` or\n    ``RATE_2MBIT``.\n\n    If ``config`` is not called then the defaults described above are assumed.\n    \"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Reset the settings to their default values (as listed in the documentation\n    for the ``config`` function above).\n    \"\"\"\n    ...\n\ndef send_bytes(message: bytes) -> None:\n    \"\"\"Sends a message containing bytes.\"\"\"\n    ...\n\ndef receive_bytes() -> Optional[bytes]:\n    \"\"\"Receive the next incoming message on the message queue. Returns ``None`` if\n    there are no pending messages. Messages are returned as bytes.\n    \"\"\"\n    ...\n\ndef receive_bytes_into(buffer: bytearray) -> Optional[int]:\n    \"\"\"Receive the next incoming message on the message queue. Copies the message\n    into ``buffer``, trimming the end of the message if necessary.\n    Returns ``None`` if there are no pending messages, otherwise it returns the length\n    of the message (which might be more than the length of the buffer).\n    \"\"\"\n    ...\n\ndef send(message: str) -> None:\n    \"\"\"Sends a message string. This is the equivalent of\n    ``send_bytes(bytes(message, 'utf8'))`` but with ``b'\\x01\\x00\\x01'``\n    prepended to the front (to make it compatible with other platforms that\n    target the micro:bit).\n    \"\"\"\n    ...\n\ndef receive() -> Optional[str]:\n    \"\"\"Works in exactly the same way as ``receive_bytes`` but returns\n    whatever was sent.\n\n    Currently, it's equivalent to ``str(receive_bytes(), 'utf8')`` but with a\n    check that the the first three bytes are ``b'\\x01\\x00\\x01'`` (to make it\n    compatible with other platforms that may target the micro:bit). It strips\n    the prepended bytes before converting to a string.\n\n    A ``ValueError`` exception is raised if conversion to string fails.\n    \"\"\"\n    ...\n\ndef receive_full() -> Tuple[bytes, int, int]:\n    \"\"\"Returns a tuple containing three values representing the next incoming\n    message on the message queue. If there are no pending messages then\n    ``None`` is returned.\n\n    The three values in the tuple represent:\n\n    * the next incoming message on the message queue as bytes.\n    * the RSSI (signal strength): a value between 0 (strongest) and -255 (weakest) as measured in dBm.\n    * a microsecond timestamp: the value returned by ``time.ticks_us()`` when the message was received.\n\n    For example::\n\n        details = radio.receive_full()\n        if details:\n            msg, rssi, timestamp = details\n\n    This function is useful for providing information needed for triangulation\n    and/or triliteration with other micro:bit devices.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/random.pyi": "from urandom import *\n",
    "/typeshed/stdlib/speech.pyi": "\"\"\"This module makes the micro:bit talk, sing and make other speech like sounds.\nBy default sound output will be via the edge connector on pin 0 and the\n:doc:`built-in speaker <speaker>` **V2**. You can connect wired headphones or\na speaker to pin 0 and GND on the edge connector to hear the sound:\n\n.. note::\n\n    This work is based upon the amazing reverse engineering efforts of\n    Sebastian Macke based upon an old text-to-speech (TTS) program called SAM\n    (Software Automated Mouth) originally released in 1982 for the\n    Commodore 64. The result is a small C library that we have adopted and\n    adapted for the micro:bit. You can find out more from\n    `his homepage <http://simulationcorner.net/index.php?page=sam>`_. Much of\n    the information in this document was gleaned from the original user's\n    manual which can be found\n    `here <http://www.apple-iigs.info/newdoc/sam.pdf>`_.\n\nThe speech synthesiser can produce around 2.5 seconds worth of sound from up to\n255 characters of textual input.\n\nTo access this module you need to::\n\n    import speech\n\"\"\"\n\nfrom .microbit import MicroBitDigitalPin, pin0\n\ndef translate(words: str) -> str:\n    \"\"\"Given English words in the string ``words``, return a string containing\n    a best guess at the appropriate phonemes to pronounce. The output is\n    generated from this\n    `text to phoneme translation table <https://github.com/s-macke/SAM/wiki/Text-to-phoneme-translation-table>`_.\n\n    This function should be used to generate a first approximation of phonemes\n    that can be further hand-edited to improve accuracy, inflection and\n    emphasis.\n    \"\"\"\n    ...\n\ndef pronounce(\n    phonemes: str,\n    pitch: int = 64,\n    speed: int = 72,\n    mouth: int = 128,\n    throat: int = 128,\n    pin: MicroBitDigitalPin = pin0,\n) -> None:\n    \"\"\"Pronounce the phonemes in the string ``phonemes``. See below for details of\n    how to use phonemes to finely control the output of the speech synthesiser.\n    Override the optional pitch, speed, mouth and throat settings to change the\n    timbre (quality) of the voice.\n\n    For micro:bit **V2** an optional argument to specify the output pin can be\n    used to override the default of ``pin0``. If we do not want any sound to\n    play out of the pins can use ``pin=None``.\n    \"\"\"\n    ...\n\ndef say(\n    words: str,\n    pitch: int = 64,\n    speed: int = 72,\n    mouth: int = 128,\n    throat: int = 128,\n    pin: MicroBitDigitalPin = pin0,\n) -> None:\n    \"\"\"Say the English words in the string ``words``. The result is semi-accurate\n    for English. Override the optional pitch, speed, mouth and throat\n    settings to change the timbre (quality) of the voice. This is a short-hand\n    equivalent of: ``speech.pronounce(speech.translate(words))``\n    \"\"\"\n    ...\n\ndef sing(\n    phonemes: str,\n    pitch: int = 64,\n    speed: int = 72,\n    mouth: int = 128,\n    throat: int = 128,\n    pin: MicroBitDigitalPin = pin0,\n) -> None:\n    \"\"\"Sing the phonemes contained in the string ``phonemes``. Changing the pitch\n    and duration of the note is described below. Override the optional pitch,\n    speed, mouth and throat settings to change the timbre (quality) of the\n    voice.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/struct.pyi": "from ustruct import *\n",
    "/typeshed/stdlib/sys.pyi": "from usys import *\n",
    "/typeshed/stdlib/this.pyi": "def authors() -> str: ...\n",
    "/typeshed/stdlib/time.pyi": "from utime import *\n",
    "/typeshed/stdlib/types.pyi": "import sys\nfrom typing import (\n    Any,\n    AsyncGenerator,\n    Awaitable,\n    Callable,\n    Generator,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    Tuple,\n    Type,\n    TypeVar,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, final\n\n# Note, all classes \"defined\" here require special handling.\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_V_co = TypeVar(\"_V_co\", covariant=True)\n\n@final\nclass _Cell:\n    __hash__: None  # type: ignore\n    cell_contents: Any\n\n@final\nclass FunctionType:\n    __closure__: Tuple[_Cell, ...] | None\n    __code__: CodeType\n    __defaults__: Tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    __globals__: dict[str, Any]\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, Any]\n    __kwdefaults__: dict[str, Any]\n    def __init__(\n        self,\n        code: CodeType,\n        globals: dict[str, Any],\n        name: str | None = ...,\n        argdefs: Tuple[object, ...] | None = ...,\n        closure: Tuple[_Cell, ...] | None = ...,\n    ) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, obj: object | None, type: type | None) -> MethodType: ...\n\nLambdaType = FunctionType\n\n@final\nclass CodeType:\n    \"\"\"Create a code object.  Not for the faint of heart.\"\"\"\n\n    co_argcount: int\n    if sys.version_info >= (3, 8):\n        co_posonlyargcount: int\n    co_kwonlyargcount: int\n    co_nlocals: int\n    co_stacksize: int\n    co_flags: int\n    co_code: bytes\n    co_consts: Tuple[Any, ...]\n    co_names: Tuple[str, ...]\n    co_varnames: Tuple[str, ...]\n    co_filename: str\n    co_name: str\n    co_firstlineno: int\n    co_lnotab: bytes\n    co_freevars: Tuple[str, ...]\n    co_cellvars: Tuple[str, ...]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            argcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def replace(\n            self,\n            *,\n            co_argcount: int = ...,\n            co_posonlyargcount: int = ...,\n            co_kwonlyargcount: int = ...,\n            co_nlocals: int = ...,\n            co_stacksize: int = ...,\n            co_flags: int = ...,\n            co_firstlineno: int = ...,\n            co_code: bytes = ...,\n            co_consts: Tuple[Any, ...] = ...,\n            co_names: Tuple[str, ...] = ...,\n            co_varnames: Tuple[str, ...] = ...,\n            co_freevars: Tuple[str, ...] = ...,\n            co_cellvars: Tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_lnotab: bytes = ...,\n        ) -> CodeType: ...\n\n@final\nclass MappingProxyType(Mapping[_KT, _VT_co], Generic[_KT, _VT_co]):\n    __hash__: None  # type: ignore\n    def __init__(self, mapping: Mapping[_KT, _VT_co]) -> None: ...\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def copy(self) -> dict[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __reversed__(self) -> Iterator[_KT]: ...\n        def __or__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n        def __ror__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n\nclass SimpleNamespace:\n    __hash__: None  # type: ignore\n    def __init__(self, **kwargs: Any) -> None: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __delattr__(self, name: str) -> None: ...\n\nclass ModuleType:\n    __name__: str\n    __file__: str\n    __dict__: dict[str, Any]\n    __package__: str | None\n    def __init__(self, name: str, doc: str | None = ...) -> None: ...\n\n@final\nclass GeneratorType(Generator[_T_co, _T_contra, _V_co]):\n    gi_code: CodeType\n    gi_frame: FrameType\n    gi_running: bool\n    gi_yieldfrom: GeneratorType[_T_co, _T_contra, Any] | None\n    def __iter__(self) -> GeneratorType[_T_co, _T_contra, _V_co]: ...\n    def __next__(self) -> _T_co: ...\n    def close(self) -> None: ...\n    def send(self, __arg: _T_contra) -> _T_co: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> _T_co: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> _T_co: ...\n\n@final\nclass AsyncGeneratorType(AsyncGenerator[_T_co, _T_contra]):\n    ag_await: Awaitable[Any] | None\n    ag_frame: FrameType\n    ag_running: bool\n    ag_code: CodeType\n    def __aiter__(self) -> AsyncGeneratorType[_T_co, _T_contra]: ...\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def asend(self, __val: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Awaitable[_T_co]: ...\n    def aclose(self) -> Awaitable[None]: ...\n\n@final\nclass CoroutineType:\n    cr_await: Any | None\n    cr_code: CodeType\n    cr_frame: FrameType\n    cr_running: bool\n    def close(self) -> None: ...\n    def send(self, __arg: Any) -> Any: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Any: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Any: ...\n\nclass _StaticFunctionType:\n    \"\"\"Fictional type to correct the type of MethodType.__func__.\n\n    FunctionType is a descriptor, so mypy follows the descriptor protocol and\n    converts MethodType.__func__ back to MethodType (the return type of\n    FunctionType.__get__). But this is actually a special case; MethodType is\n    implemented in C and its attribute access doesn't go through\n    __getattribute__.\n\n    By wrapping FunctionType in _StaticFunctionType, we get the right result;\n    similar to wrapping a function in staticmethod() at runtime to prevent it\n    being bound as a method.\n    \"\"\"\n\n    def __get__(self, obj: object | None, type: type | None) -> FunctionType: ...\n\n@final\nclass MethodType:\n    __closure__: Tuple[_Cell, ...] | None  # inherited from the added function\n    __defaults__: Tuple[Any, ...] | None  # inherited from the added function\n    __func__: _StaticFunctionType\n    __self__: object\n    __name__: str  # inherited from the added function\n    __qualname__: str  # inherited from the added function\n    def __init__(self, func: Callable[..., Any], obj: object) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\n@final\nclass BuiltinFunctionType:\n    __self__: object | ModuleType\n    __name__: str\n    __qualname__: str\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nBuiltinMethodType = BuiltinFunctionType\n\nif sys.version_info >= (3, 7):\n    @final\n    class WrapperDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class MethodWrapperType:\n        __self__: object\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __ne__(self, other: Any) -> bool: ...\n    @final\n    class MethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class ClassMethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n\n@final\nclass TracebackType:\n    if sys.version_info >= (3, 7):\n        def __init__(\n            self,\n            tb_next: TracebackType | None,\n            tb_frame: FrameType,\n            tb_lasti: int,\n            tb_lineno: int,\n        ) -> None: ...\n        tb_next: TracebackType | None\n    else:\n        @property\n        def tb_next(self) -> TracebackType | None: ...\n    # the rest are read-only even in 3.7\n    @property\n    def tb_frame(self) -> FrameType: ...\n    @property\n    def tb_lasti(self) -> int: ...\n    @property\n    def tb_lineno(self) -> int: ...\n\n@final\nclass FrameType:\n    f_back: FrameType | None\n    f_builtins: dict[str, Any]\n    f_code: CodeType\n    f_globals: dict[str, Any]\n    f_lasti: int\n    f_lineno: int\n    f_locals: dict[str, Any]\n    f_trace: Callable[[FrameType, str, Any], Any] | None\n    if sys.version_info >= (3, 7):\n        f_trace_lines: bool\n        f_trace_opcodes: bool\n    def clear(self) -> None: ...\n\n@final\nclass GetSetDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\n@final\nclass MemberDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nif sys.version_info >= (3, 7):\n    def new_class(\n        name: str,\n        bases: Iterable[object] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n    def resolve_bases(bases: Iterable[object]) -> Tuple[Any, ...]: ...\n\nelse:\n    def new_class(\n        name: str,\n        bases: Tuple[type, ...] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n\ndef prepare_class(\n    name: str, bases: Tuple[type, ...] = ..., kwds: dict[str, Any] | None = ...\n) -> Tuple[type, dict[str, Any], dict[str, Any]]: ...\n\n# Actually a different type, but `property` is special and we want that too.\nDynamicClassAttribute = property\n\ndef coroutine(func: Callable[..., Any]) -> CoroutineType: ...\n\nif sys.version_info >= (3, 8):\n    CellType = _Cell\n\nif sys.version_info >= (3, 9):\n    class GenericAlias:\n        __origin__: type\n        __args__: Tuple[Any, ...]\n        __parameters__: Tuple[Any, ...]\n        def __init__(self, origin: type, args: Any) -> None: ...\n        def __getattr__(self, name: str) -> Any: ...  # incomplete\n\nif sys.version_info >= (3, 10):\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n    EllipsisType = ellipsis  # noqa F811 from builtins\n    from builtins import _NotImplementedType\n\n    NotImplementedType = _NotImplementedType  # noqa F811 from builtins\n    @final\n    class UnionType:\n        __args__: Tuple[Any, ...]\n        def __or__(self, obj: Any) -> UnionType: ...\n        def __ror__(self, obj: Any) -> UnionType: ...\n",
    "/typeshed/stdlib/typing.pyi": "import collections  # Needed by aliases like DefaultDict, see mypy issue 2986\nimport sys\nfrom abc import ABCMeta, abstractmethod\nfrom types import BuiltinFunctionType, CodeType, FrameType, FunctionType, MethodType, ModuleType, TracebackType\nfrom typing_extensions import Literal as _Literal\n\nif sys.version_info >= (3, 7):\n    from types import MethodDescriptorType, MethodWrapperType, WrapperDescriptorType\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n# Definitions of special type checking related constructs.  Their definitions\n# are not used, so their value does not matter.\n\nAny = object()\n\nclass TypeVar:\n    __name__: str\n    __bound__: Optional[Type[Any]]\n    __constraints__: Tuple[Type[Any], ...]\n    __covariant__: bool\n    __contravariant__: bool\n    def __init__(\n        self,\n        name: str,\n        *constraints: Type[Any],\n        bound: Union[None, Type[Any], str] = ...,\n        covariant: bool = ...,\n        contravariant: bool = ...,\n    ) -> None: ...\n\n_promote = object()\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> object: ...\n\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n\ndef overload(func: _F) -> _F: ...\n\nUnion: _SpecialForm = ...\nOptional: _SpecialForm = ...\nTuple: _SpecialForm = ...\nGeneric: _SpecialForm = ...\n# Protocol is only present in 3.8 and later, but mypy needs it unconditionally\nProtocol: _SpecialForm = ...\nCallable: _SpecialForm = ...\nType: _SpecialForm = ...\nClassVar: _SpecialForm = ...\nif sys.version_info >= (3, 8):\n    Final: _SpecialForm = ...\n    def final(f: _F) -> _F: ...\n    Literal: _SpecialForm = ...\n    # TypedDict is a (non-subscriptable) special form.\n    TypedDict: object\n\nif sys.version_info < (3, 7):\n    class GenericMeta(type): ...\n\nif sys.version_info >= (3, 10):\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Optional[Type[Any]]\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: Union[None, Type[Any], str] = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n\n# Return type that indicates a function does not return.\n# This type is equivalent to the None type, but the no-op Union is necessary to\n# distinguish the None type from the None value.\nNoReturn = Union[None]\n\n# These type variables are used by the container types.\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_KT = TypeVar(\"_KT\")  # Key type.\n_VT = TypeVar(\"_VT\")  # Value type.\n_T_co = TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_V_co = TypeVar(\"_V_co\", covariant=True)  # Any type covariant containers.\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)  # Ditto contravariant.\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\ndef no_type_check(arg: _F) -> _F: ...\ndef no_type_check_decorator(decorator: _F) -> _F: ...\n\n# Type aliases and type constructors\n\nclass _Alias:\n    # Class for defining generic aliases for library types.\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\nList = _Alias()\nDict = _Alias()\nDefaultDict = _Alias()\nSet = _Alias()\nFrozenSet = _Alias()\nCounter = _Alias()\nDeque = _Alias()\nChainMap = _Alias()\n\nif sys.version_info >= (3, 7):\n    OrderedDict = _Alias()\n\nif sys.version_info >= (3, 9):\n    Annotated: _SpecialForm = ...\n\n# Predefined type variables.\nAnyStr = TypeVar(\"AnyStr\", str, bytes)\n\n# Abstract base classes.\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n@runtime_checkable\nclass SupportsInt(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __int__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsFloat(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __float__(self) -> float: ...\n\n@runtime_checkable\nclass SupportsComplex(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n\n@runtime_checkable\nclass SupportsBytes(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __bytes__(self) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    @runtime_checkable\n    class SupportsIndex(Protocol, metaclass=ABCMeta):\n        @abstractmethod\n        def __index__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsAbs(Protocol[_T_co]):\n    @abstractmethod\n    def __abs__(self) -> _T_co: ...\n\n@runtime_checkable\nclass SupportsRound(Protocol[_T_co]):\n    @overload\n    @abstractmethod\n    def __round__(self) -> int: ...\n    @overload\n    @abstractmethod\n    def __round__(self, ndigits: int) -> _T_co: ...\n\n@runtime_checkable\nclass Sized(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n@runtime_checkable\nclass Hashable(Protocol, metaclass=ABCMeta):\n    # TODO: This is special, in that a subclass of a hashable class may not be hashable\n    #   (for example, list vs. object). It's not obvious how to represent this. This class\n    #   is currently mostly useless for static checking.\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\n@runtime_checkable\nclass Iterable(Protocol[_T_co]):\n    @abstractmethod\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Iterator(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __next__(self) -> _T_co: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Reversible(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass Generator(Iterator[_T_co], Generic[_T_co, _T_contra, _V_co]):\n    def __next__(self) -> _T_co: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    def close(self) -> None: ...\n    def __iter__(self) -> Generator[_T_co, _T_contra, _V_co]: ...\n    @property\n    def gi_code(self) -> CodeType: ...\n    @property\n    def gi_frame(self) -> FrameType: ...\n    @property\n    def gi_running(self) -> bool: ...\n    @property\n    def gi_yieldfrom(self) -> Optional[Generator[Any, Any, Any]]: ...\n\n@runtime_checkable\nclass Awaitable(Protocol[_T_co]):\n    @abstractmethod\n    def __await__(self) -> Generator[Any, None, _T_co]: ...\n\nclass Coroutine(Awaitable[_V_co], Generic[_T_co, _T_contra, _V_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_await(self) -> Optional[Any]: ...\n    @property\n    def cr_code(self) -> CodeType: ...\n    @property\n    def cr_frame(self) -> FrameType: ...\n    @property\n    def cr_running(self) -> bool: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    @abstractmethod\n    def close(self) -> None: ...\n\n# NOTE: This type does not exist in typing.py or PEP 484.\n# The parameters correspond to Generator, but the 4th is the original type.\nclass AwaitableGenerator(\n    Awaitable[_V_co], Generator[_T_co, _T_contra, _V_co], Generic[_T_co, _T_contra, _V_co, _S], metaclass=ABCMeta\n): ...\n\n@runtime_checkable\nclass AsyncIterable(Protocol[_T_co]):\n    @abstractmethod\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\nclass AsyncGenerator(AsyncIterator[_T_co], Generic[_T_co, _T_contra]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def asend(self, __value: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def aclose(self) -> Awaitable[None]: ...\n    @abstractmethod\n    def __aiter__(self) -> AsyncGenerator[_T_co, _T_contra]: ...\n    @property\n    def ag_await(self) -> Any: ...\n    @property\n    def ag_code(self) -> CodeType: ...\n    @property\n    def ag_frame(self) -> FrameType: ...\n    @property\n    def ag_running(self) -> bool: ...\n\n@runtime_checkable\nclass Container(Protocol[_T_co]):\n    @abstractmethod\n    def __contains__(self, __x: object) -> bool: ...\n\n@runtime_checkable\nclass Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):\n    # Implement Sized (but don't have it as a base class).\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n_Collection = Collection[_T_co]\n\nclass Sequence(_Collection[_T_co], Reversible[_T_co], Generic[_T_co]):\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...\n    # Mixin methods\n    def index(self, value: Any, start: int = ..., stop: int = ...) -> int: ...\n    def count(self, value: Any) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass MutableSequence(Sequence[_T], Generic[_T]):\n    @abstractmethod\n    def insert(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> MutableSequence[_T]: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: int) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: slice) -> None: ...\n    # Mixin methods\n    def append(self, value: _T) -> None: ...\n    def clear(self) -> None: ...\n    def extend(self, values: Iterable[_T]) -> None: ...\n    def reverse(self) -> None: ...\n    def pop(self, index: int = ...) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __iadd__(self, x: Iterable[_T]) -> MutableSequence[_T]: ...\n\nclass AbstractSet(_Collection[_T_co], Generic[_T_co]):\n    @abstractmethod\n    def __contains__(self, x: object) -> bool: ...\n    # Mixin methods\n    def __le__(self, s: AbstractSet[Any]) -> bool: ...\n    def __lt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __gt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __ge__(self, s: AbstractSet[Any]) -> bool: ...\n    def __and__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def __sub__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def isdisjoint(self, other: Iterable[Any]) -> bool: ...\n\nclass MutableSet(AbstractSet[_T], Generic[_T]):\n    @abstractmethod\n    def add(self, value: _T) -> None: ...\n    @abstractmethod\n    def discard(self, value: _T) -> None: ...\n    # Mixin methods\n    def clear(self) -> None: ...\n    def pop(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __ior__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __iand__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __isub__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n\nclass MappingView(Sized):\n    def __init__(self, mapping: Mapping[Any, Any]) -> None: ...  # undocumented\n    def __len__(self) -> int: ...\n\nclass ItemsView(MappingView, AbstractSet[Tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, _VT_co]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n\nclass KeysView(MappingView, AbstractSet[_KT_co], Generic[_KT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, Any]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT_co]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n\nclass ValuesView(MappingView, Iterable[_VT_co], Generic[_VT_co]):\n    def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_VT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_VT_co]: ...\n\n@runtime_checkable\nclass ContextManager(Protocol[_T_co]):\n    def __enter__(self) -> _T_co: ...\n    def __exit__(\n        self,\n        __exc_type: Optional[Type[BaseException]],\n        __exc_value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n    ) -> Optional[bool]: ...\n\n@runtime_checkable\nclass AsyncContextManager(Protocol[_T_co]):\n    def __aenter__(self) -> Awaitable[_T_co]: ...\n    def __aexit__(\n        self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Awaitable[Optional[bool]]: ...\n\nclass Mapping(_Collection[_KT], Generic[_KT, _VT_co]):\n    # TODO: We wish the key type could also be covariant, but that doesn't work,\n    # see discussion in https: //github.com/python/typing/pull/273.\n    @abstractmethod\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    # Mixin methods\n    @overload\n    def get(self, key: _KT) -> Optional[_VT_co]: ...\n    @overload\n    def get(self, key: _KT, default: Union[_VT_co, _T]) -> Union[_VT_co, _T]: ...\n    def items(self) -> AbstractSet[Tuple[_KT, _VT_co]]: ...\n    def keys(self) -> AbstractSet[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def __contains__(self, o: object) -> bool: ...\n\nclass MutableMapping(Mapping[_KT, _VT], Generic[_KT, _VT]):\n    @abstractmethod\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    @abstractmethod\n    def __delitem__(self, v: _KT) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: Union[_VT, _T] = ...) -> Union[_VT, _T]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, key: _KT, default: _VT = ...) -> _VT: ...\n    # 'update' used to take a Union, but using overloading is better.\n    # The second overloaded type here is a bit too general, because\n    # Mapping[Tuple[_KT, _VT], W] is a subclass of Iterable[Tuple[_KT, _VT]],\n    # but will always have the behavior of the first overloaded type\n    # at runtime, leading to keys of a mix of types _KT and Tuple[_KT, _VT].\n    # We don't currently have any way of forcing all Mappings to use\n    # the first overload, but by using overloading rather than a Union,\n    # mypy will commit to using the first overload when the argument is\n    # known to be a Mapping with unknown type parameters, which is closer\n    # to the behavior we want. See mypy issue  #1430.\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n\nText = str\n\nTYPE_CHECKING = True\n\nclass IO(Iterator[AnyStr], Generic[AnyStr]):\n    # TODO use abstract properties\n    @property\n    def mode(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    @abstractmethod\n    def fileno(self) -> int: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def isatty(self) -> bool: ...\n    @abstractmethod\n    def read(self, n: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readable(self) -> bool: ...\n    @abstractmethod\n    def readline(self, limit: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readlines(self, hint: int = ...) -> list[AnyStr]: ...\n    @abstractmethod\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    @abstractmethod\n    def seekable(self) -> bool: ...\n    @abstractmethod\n    def tell(self) -> int: ...\n    @abstractmethod\n    def truncate(self, size: Optional[int] = ...) -> int: ...\n    @abstractmethod\n    def writable(self) -> bool: ...\n    @abstractmethod\n    def write(self, s: AnyStr) -> int: ...\n    @abstractmethod\n    def writelines(self, lines: Iterable[AnyStr]) -> None: ...\n    @abstractmethod\n    def __next__(self) -> AnyStr: ...\n    @abstractmethod\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    @abstractmethod\n    def __enter__(self) -> IO[AnyStr]: ...\n    @abstractmethod\n    def __exit__(\n        self, t: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Optional[bool]: ...\n\nclass BinaryIO(IO[bytes]):\n    @abstractmethod\n    def __enter__(self) -> BinaryIO: ...\n\nclass TextIO(IO[str]):\n    # TODO use abstractproperty\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def encoding(self) -> str: ...\n    @property\n    def errors(self) -> Optional[str]: ...\n    @property\n    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython\n    @property\n    def newlines(self) -> Any: ...  # None, str or tuple\n    @abstractmethod\n    def __enter__(self) -> TextIO: ...\n\nclass ByteString(Sequence[int], metaclass=ABCMeta): ...\n\nclass Match(Generic[AnyStr]):\n    pos: int\n    endpos: int\n    lastindex: Optional[int]\n    lastgroup: Optional[AnyStr]\n    string: AnyStr\n\n    # The regular expression object whose match() or search() method produced\n    # this match instance.\n    re: Pattern[AnyStr]\n    def expand(self, template: AnyStr) -> AnyStr: ...\n    # group() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def group(self, __group: _Literal[0] = ...) -> AnyStr: ...\n    @overload\n    def group(self, __group: str | int) -> AnyStr | Any: ...\n    @overload\n    def group(self, __group1: str | int, __group2: str | int, *groups: str | int) -> Tuple[AnyStr | Any, ...]: ...\n    # Each item of groups()'s return tuple is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groups(self) -> Tuple[AnyStr | Any, ...]: ...\n    @overload\n    def groups(self, default: _T) -> Tuple[AnyStr | _T, ...]: ...\n    # Each value in groupdict()'s return dict is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groupdict(self) -> dict[str, AnyStr | Any]: ...\n    @overload\n    def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...\n    def start(self, __group: Union[int, str] = ...) -> int: ...\n    def end(self, __group: Union[int, str] = ...) -> int: ...\n    def span(self, __group: Union[int, str] = ...) -> Tuple[int, int]: ...\n    @property\n    def regs(self) -> Tuple[Tuple[int, int], ...]: ...  # undocumented\n    # __getitem__() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def __getitem__(self, __key: _Literal[0]) -> AnyStr: ...\n    @overload\n    def __getitem__(self, __key: int | str) -> AnyStr | Any: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Pattern(Generic[AnyStr]):\n    flags: int\n    groupindex: Mapping[str, int]\n    groups: int\n    pattern: AnyStr\n    def search(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def match(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def fullmatch(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def split(self, string: AnyStr, maxsplit: int = ...) -> list[AnyStr]: ...\n    def findall(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> list[Any]: ...\n    def finditer(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Iterator[Match[AnyStr]]: ...\n    @overload\n    def sub(self, repl: AnyStr, string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def sub(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def subn(self, repl: AnyStr, string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    @overload\n    def subn(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# Functions\n\nif sys.version_info >= (3, 7):\n    _get_type_hints_obj_allowed_types = Union[\n        object,\n        Callable[..., Any],\n        FunctionType,\n        BuiltinFunctionType,\n        MethodType,\n        ModuleType,\n        WrapperDescriptorType,\n        MethodWrapperType,\n        MethodDescriptorType,\n    ]\nelse:\n    _get_type_hints_obj_allowed_types = Union[\n        object, Callable[..., Any], FunctionType, BuiltinFunctionType, MethodType, ModuleType,\n    ]\n\nif sys.version_info >= (3, 9):\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: Optional[Dict[str, Any]] = ...,\n        localns: Optional[Dict[str, Any]] = ...,\n        include_extras: bool = ...,\n    ) -> Dict[str, Any]: ...\n\nelse:\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types, globalns: Optional[Dict[str, Any]] = ..., localns: Optional[Dict[str, Any]] = ...\n    ) -> Dict[str, Any]: ...\n\nif sys.version_info >= (3, 8):\n    def get_origin(tp: Any) -> Optional[Any]: ...\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n\n@overload\ndef cast(typ: Type[_T], val: Any) -> _T: ...\n@overload\ndef cast(typ: str, val: Any) -> Any: ...\n@overload\ndef cast(typ: object, val: Any) -> Any: ...\n\n# Type constructors\n\n# NamedTuple is special-cased in the type checker\nclass NamedTuple(Tuple[Any, ...]):\n    _field_types: collections.OrderedDict[str, Type[Any]]\n    _field_defaults: Dict[str, Any] = ...\n    _fields: Tuple[str, ...]\n    _source: str\n    def __init__(self, typename: str, fields: Iterable[Tuple[str, Any]] = ..., **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def _asdict(self) -> Dict[str, Any]: ...\n    else:\n        def _asdict(self) -> collections.OrderedDict[str, Any]: ...\n    def _replace(self: _T, **kwargs: Any) -> _T: ...\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __or__(self: _T, __value: _T) -> _T: ...\n    def __ior__(self: _T, __value: _T) -> _T: ...\n\ndef NewType(name: str, tp: Type[_T]) -> Type[_T]: ...\n\n# This itself is only available during type checking\ndef type_check_only(func_or_cls: _F) -> _F: ...\n\nif sys.version_info >= (3, 7):\n    class ForwardRef:\n        __forward_arg__: str\n        __forward_code__: CodeType\n        __forward_evaluated__: bool\n        __forward_value__: Optional[Any]\n        __forward_is_argument__: bool\n        def __init__(self, arg: str, is_argument: bool = ...) -> None: ...\n        def _evaluate(self, globalns: Optional[Dict[str, Any]], localns: Optional[Dict[str, Any]]) -> Optional[Any]: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __hash__(self) -> int: ...\n        def __repr__(self) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def is_typeddict(tp: Any) -> bool: ...\n",
    "/typeshed/stdlib/typing_extensions.pyi": "import abc\nimport sys\nfrom typing import (\n    TYPE_CHECKING as TYPE_CHECKING,\n    Any,\n    AsyncContextManager as AsyncContextManager,\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    Callable,\n    ChainMap as ChainMap,\n    ClassVar as ClassVar,\n    ContextManager as ContextManager,\n    Coroutine as Coroutine,\n    Counter as Counter,\n    DefaultDict as DefaultDict,\n    Deque as Deque,\n    ItemsView,\n    KeysView,\n    Mapping,\n    NewType as NewType,\n    NoReturn as NoReturn,\n    Text as Text,\n    Tuple,\n    Type as Type,\n    TypeVar,\n    ValuesView,\n    _Alias,\n    overload as overload,\n)\n\n_T = TypeVar(\"_T\")\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n\n# This alias for above is kept here for backwards compatibility.\nruntime = runtime_checkable\nProtocol: _SpecialForm = ...\nFinal: _SpecialForm = ...\n\ndef final(f: _F) -> _F: ...\n\nLiteral: _SpecialForm = ...\n\ndef IntVar(name: str) -> Any: ...  # returns a new TypeVar\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n\n# TypedDict is a (non-subscriptable) special form.\nTypedDict: object = ...\n\nOrderedDict = _Alias()\n\ndef get_type_hints(\n    obj: Callable[..., Any],\n    globalns: dict[str, Any] | None = ...,\n    localns: dict[str, Any] | None = ...,\n    include_extras: bool = ...,\n) -> dict[str, Any]: ...\n\nif sys.version_info >= (3, 7):\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n    def get_origin(tp: Any) -> Any | None: ...\n\nAnnotated: _SpecialForm = ...\n_AnnotatedAlias: Any = ...  # undocumented\n\n@runtime_checkable\nclass SupportsIndex(Protocol, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __index__(self) -> int: ...\n\n# PEP 612 support for Python < 3.9\nif sys.version_info >= (3, 10):\n    from typing import Concatenate as Concatenate, ParamSpec as ParamSpec, TypeAlias as TypeAlias, TypeGuard as TypeGuard\nelse:\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Type[Any] | None\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: None | Type[Any] | str = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n",
    "/typeshed/stdlib/uarray.pyi": "from typing import Generic, Iterable, MutableSequence, TypeVar, Union, overload\nfrom typing_extensions import Literal\n\n_IntTypeCode = Literal[\"b\", \"B\", \"h\", \"H\", \"i\", \"I\", \"l\", \"L\", \"q\", \"Q\"]\n_FloatTypeCode = Literal[\"f\", \"d\"]\n_TypeCode = Union[_IntTypeCode, _FloatTypeCode]\n\n_T = TypeVar(\"_T\", int, float)\n\nclass array(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(\n        self: array[int],\n        typecode: _IntTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self: array[float],\n        typecode: _FloatTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self, typecode: str, __initializer: Union[bytes, Iterable[_T]] = ...\n    ) -> None: ...\n    def append(self, __v: _T) -> None: ...\n    def decode(self) -> str: ...\n    def extend(self, __bb: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> array[_T]: ...\n    @overload  # type: ignore  # Overrides MutableSequence\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: array[_T]) -> None: ...\n    def __add__(self, x: array[_T]) -> array[_T]: ...\n    def __iadd__(self, x: array[_T]) -> array[_T]: ...  # type: ignore  # Overrides MutableSequence\n\nArrayType = array\n",
    "/typeshed/stdlib/ucollections.pyi": "from collections import *\n",
    "/typeshed/stdlib/uerrno.pyi": "from typing import Mapping\n\nerrorcode: Mapping[int, str]\n\nEACCES: int\nEADDRINUSE: int\nEAGAIN: int\nEALREADY: int\nEBADF: int\nECONNABORTED: int\nECONNREFUSED: int\nECONNRESET: int\nEEXIST: int\nEHOSTUNREACH: int\nEINPROGRESS: int\nEINVAL: int\nEIO: int\nEISDIR: int\nENOBUFS: int\nENODEV: int\nENOENT: int\nENOMEM: int\nENOTCONN: int\nEOPNOTSUPP: int\nEPERM: int\nETIMEDOUT: int\n",
    "/typeshed/stdlib/uos.pyi": "\"\"\"MicroPython contains an ``os`` module based upon the ``os`` module in the\nPython standard library. It's used for accessing what would traditionally be\ntermed as operating system dependent functionality. Since there is no operating\nsystem in MicroPython the module provides functions relating to the management\nof the simple on-device persistent file system and information about the\ncurrent system.\n\nTo access this module you need to::\n\n    import os\n\"\"\"\n\nfrom typing import List\n\ndef listdir() -> List[str]:\n    \"\"\"Returns a list of the names of all the files contained within the local\n    persistent on-device file system.\n    \"\"\"\n    ...\n\ndef remove(filename: str) -> None:\n    \"\"\"Removes (deletes) the file named in the argument ``filename``. If the file\n    does not exist an ``OSError`` exception will occur.\n    \"\"\"\n    ...\n\ndef size(filename: str) -> int:\n    \"\"\"Returns the size, in bytes, of the file named in the argument ``filename``.\n    If the file does not exist an ``OSError`` exception will occur.\n    \"\"\"\n\ndef uname() -> str:\n    \"\"\"Returns information identifying the current operating system. The return\n    value is an object with five attributes:\n\n    * ``sysname`` - operating system name\n    * ``nodename`` - name of machine on network (implementation-defined)\n    * ``release`` - operating system release\n    * ``version`` - operating system version\n    * ``machine`` - hardware identifier\n\n    .. note::\n\n        There is no underlying operating system in MicroPython. As a result the\n        information returned by the ``uname`` function is mostly useful for\n        versioning details.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/urandom.pyi": "\"\"\"\nThis module is based upon the ``random`` module in the Python standard library.\nIt contains functions for generating random behaviour.\n\nTo access this module you need to::\n\n    import random\n\"\"\"\nfrom typing import TypeVar, Sequence, Union, overload\n\ndef getrandbits(n: int) -> int:\n    \"\"\"Returns an integer with ``n`` random bits.\n\n    .. warning::\n\n        Because the underlying generator function returns at most 30 bits, ``n``\n        may only be a value between 1-30 (inclusive).\"\"\"\n    ...\n\ndef seed(n: int) -> None:\n    \"\"\"Initialize the random number generator with a known integer ``n``. This\n    will give you reproducibly deterministic randomness from a given starting\n    state (``n``).\n    \"\"\"\n    ...\n\ndef randint(a: int, b: int) -> int:\n    \"\"\"Return a random integer ``N`` such that ``a <= N <= b``. Alias for\n    ``randrange(a, b+1)``.\n    \"\"\"\n    ...\n\n@overload\ndef randrange(stop: int) -> int:\n    \"\"\"Return a randomly selected integer between zero and up to (but not\n    including) ``stop``.\n    \"\"\"\n    ...\n\n@overload\ndef randrange(start: int, stop: Union[int, None] = ..., step: int = ...) -> int:\n    \"\"\"\n    Return a randomly selected element from ``range(start, stop, step)``.\n    \"\"\"\n    ...\n\n_T = TypeVar(\"_T\")\n\ndef choice(seq: Sequence[_T]) -> _T:\n    \"\"\"Return a random element from the non-empty sequence ``seq``. If ``seq`` is\n    empty, raises ``IndexError``.\n    \"\"\"\n    ...\n\ndef random() -> float:\n    \"\"\"Return the next random floating point number in the range [0.0, 1.0)\"\"\"\n    ...\n\ndef uniform(a: float, b: float) -> float:\n    \"\"\"\n    Return a random floating point number ``N`` such that ``a <= N <= b``\n    for ``a <= b`` and ``b <= N <= a`` for ``b < a``.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/ustruct.pyi": "\"\"\"pack and unpack primitive data types\n\nSupported size/byte order prefixes: ``@``, ``<``, ``>``, ``!``.\n\nSupported format codes: ``b``, ``B``, ``h``, ``H``, ``i``, ``I``, ``l``,\n``L``, ``q``, ``Q``, ``s``, ``P``, ``f``, ``d`` (the latter 2 depending\non the floating-point support).\n\n.. admonition:: Difference to CPython\n   :class: attention\n\n   Whitespace is not supported in format strings.\n\"\"\"\n\nfrom typing import Any, Tuple, Union\n\ndef calcsize(fmt: str) -> int:\n    \"\"\"Return the number of bytes needed to store the given *fmt*.\"\"\"\n    ...\n\ndef pack(fmt: str, v1: Any, *vn: Any) -> bytes:\n    \"\"\"Pack the values *v1*, *v2*, ... according to the format string *fmt*.\n    The return value is a bytes object encoding the values.\"\"\"\n    ...\n\ndef pack_into(fmt: str, buffer: bytearray, offset: int, v1: Any, *vn: Any) -> None:\n    \"\"\"Pack the values *v1*, *v2*, ... according to the format string *fmt*\n    into a *buffer* starting at *offset*. *offset* may be negative to count\n    from the end of *buffer*.\n    \"\"\"\n    ...\n\ndef unpack(fmt: str, data: Union[bytes, bytearray]) -> Tuple:\n    \"\"\"Unpack from the *data* according to the format string *fmt*.\n    The return value is a tuple of the unpacked values.\n    \"\"\"\n    ...\n\ndef unpack_from(fmt: str, buffer: Union[bytes, bytearray], offset: int = 0) -> Tuple:\n    \"\"\"Unpack from the *data* starting at *offset* according to the format string\n    *fmt*. *offset* may be negative to count from the end of *buffer*. The return\n    value is a tuple of the unpacked values.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/usys.pyi": "\"\"\"system specific functions\"\"\"\n\nfrom typing import Any, Dict, List, NoReturn, TextIO, Tuple\n\ndef exit(retval: object = ...) -> NoReturn:\n    \"\"\"Terminate current program with a given exit code. Underlyingly, this\n    function raise as `SystemExit` exception. If an argument is given, its\n    value given as an argument to `SystemExit`.\n    \"\"\"\n    ...\n\ndef print_exception(exc: Exception, file: TextIO = ...) -> None:\n    \"\"\"\n    Print exception with a traceback to a file-like object *file* (or\n    `sys.stdout` by default).\n\n    .. admonition:: Difference to CPython\n        :class: attention\n\n        This is simplified version of a function which appears in the\n        ``traceback`` module in CPython. Unlike ``traceback.print_exception()``,\n        this function takes just exception value instead of exception type,\n        exception value, and traceback object; *file* argument should be\n        positional; further arguments are not supported. CPython-compatible\n        ``traceback`` module can be found in `micropython-lib`.\n    \"\"\"\n\nargv: List[str]\n\"\"\"A mutable list of arguments the current program was started with.\"\"\"\n\nbyteorder: str\n\"\"\"The byte order of the system (``\"little\"`` or ``\"big\"``).\"\"\"\n\nclass _implementation:\n    name: str\n    version: Tuple[int, int, int]\n\nimplementation: _implementation\n\"\"\"Object with information about the current Python implementation. For\nMicroPython, it has following attributes:\n\n* *name* - string \"micropython\"\n* *version* - tuple (major, minor, micro), e.g. (1, 7, 0)\n\nThis object is the recommended way to distinguish MicroPython from other\nPython implementations (note that it still may not exist in the very\nminimal ports).\n\n.. admonition:: Difference to CPython\n    :class: attention\n\n    CPython mandates more attributes for this object, but the actual useful\n    bare minimum is implemented in MicroPython.\n\"\"\"\n\nmaxsize: int\n\"\"\"\nMaximum value which a native integer type can hold on the current platform,\nor maximum value representable by MicroPython integer type, if it's smaller\nthan platform max value (that is the case for MicroPython ports without\nlong int support).\n\nThis attribute is useful for detecting \"bitness\" of a platform (32-bit vs\n64-bit, etc.). It's recommended to not compare this attribute to some\nvalue directly, but instead count number of bits in it::\n\nbits = 0\nv = sys.maxsize\nwhile v:\n    bits += 1\n    v >>= 1\nif bits > 32:\n    # 64-bit (or more) platform\n    ...\nelse:\n    # 32-bit (or less) platform\n    # Note that on 32-bit platform, value of bits may be less than 32\n    # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n    # \"> 32\", \"> 64\" style of comparisons.\n\"\"\"\n\nmodules: Dict[str, Any]\n\"\"\"Dictionary of loaded modules. On some ports, it may not include builtin\n   modules.\"\"\"\n\npath: List[str]\n\"\"\"A mutable list of directories to search for imported modules.\"\"\"\n\nplatform: str\n\"\"\"The platform that MicroPython is running on. For OS/RTOS ports, this is\nusually an identifier of the OS, e.g. ``\"linux\"``. For baremetal ports it\nis an identifier of a board, e.g. ``\"pyboard\"`` for the original MicroPython\nreference board. It thus can be used to distinguish one board from another.\nIf you need to check whether your program runs on MicroPython (vs other\nPython implementation), use `sys.implementation` instead.\n\"\"\"\n\nversion: str\n\"\"\"Python language version that this implementation conforms to, as a string.\"\"\"\n\nversion_info: Tuple[int, int, int]\n\"\"\"Python language version that this implementation conforms to, as a tuple of ints.\n\n.. admonition:: Difference to CPython\n    :class: attention\n\n    Only the first three version numbers (major, minor, micro) are supported and\n    they can be referenced only by index, not by name.\n\"\"\"\n",
    "/typeshed/stdlib/utime.pyi": "\"\"\"\nThe ``utime`` module provides functions for getting the current time and date, \nmeasuring time intervals, and for delays.\n\n.. note::\n    The ``utime`` module is a MicroPython implementation of the standard Python \n    ``time`` module. It can be imported using both ``import utime`` and \n    ``import time``, but the module is the same.\n\"\"\"\n\nfrom typing import Union\n\ndef sleep(seconds: Union[int, float]) -> None:\n    \"\"\"\n    Sleep for the given number of seconds. You can use a floating-point number\n    to sleep for a fractional number of seconds, or use the\n    :func:`utime.sleep_ms()` and :func:`utime.sleep_us()` functions.\n    \"\"\"\n    ...\n\ndef sleep_ms(ms: int) -> None:\n    \"\"\"\n    Delay for given number of milliseconds, should be positive or 0.\n    \"\"\"\n    ...\n\ndef sleep_us(us: int) -> None:\n    \"\"\"\n    Delay for given number of microseconds, should be positive or 0.\n    \"\"\"\n    ...\n\ndef ticks_ms() -> int:\n    \"\"\"\n    Returns an increasing millisecond counter with an arbitrary reference point,\n    that wraps around after some value.\n    \"\"\"\n    ...\n\ndef ticks_us() -> int:\n    \"\"\"\n    Just like :func:`utime.ticks_ms()` above, but in microseconds.\n    \"\"\"\n    ...\n\ndef ticks_add(ticks: int, delta: int) -> int:\n    \"\"\"\n    Offset ticks value by a given number, which can be either positive or\n    negative. Given a ticks value, this function allows to calculate ticks\n    value delta ticks before or after it, following modular-arithmetic\n    definition of tick values.\n\n    Example:\n\n    .. code-block:: python\n\n        # Find out what ticks value there was 100ms ago\n        print(ticks_add(time.ticks_ms(), -100))\n\n        # Calculate deadline for operation and test for it\n        deadline = ticks_add(time.ticks_ms(), 200)\n        while ticks_diff(deadline, time.ticks_ms()) > 0:\n            do_a_little_of_something()\n\n        # Find out TICKS_MAX used by this port\n        print(ticks_add(0, -1))\n    \"\"\"\n    ...\n\ndef ticks_diff(ticks1: int, ticks2: int) -> int:\n    \"\"\"\n    Measure ticks difference between values returned from\n    :func:`utime.ticks_ms()` or :func:`ticks_us()` functions, as a signed value\n    which may wrap around.\n\n    The argument order is the same as for subtraction operator,\n    ``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - ticks2``.\n\n    :func:`utime.ticks_diff()` is designed to accommodate various usage\n    patterns, among them:\n\n    Polling with timeout. In this case, the order of events is known, and you\n    will deal only with positive results of :func:`utime.ticks_diff()`:\n\n    .. code-block:: python\n\n        # Wait for GPIO pin to be asserted, but at most 500us\n        start = time.ticks_us()\n        while pin.value() == 0:\n            if time.ticks_diff(time.ticks_us(), start) > 500:\n                raise TimeoutError\n\n\n    Scheduling events. In this case, :func:`utime.ticks_diff()` result may be\n    negative if an event is overdue:\n\n\n    .. code-block:: python\n\n        # This code snippet is not optimized\n        now = time.ticks_ms()\n        scheduled_time = task.scheduled_time()\n        if ticks_diff(scheduled_time, now) > 0:\n            print(\"Too early, let's nap\")\n            sleep_ms(ticks_diff(scheduled_time, now))\n            task.run()\n        elif ticks_diff(scheduled_time, now) == 0:\n            print(\"Right at time!\")\n            task.run()\n        elif ticks_diff(scheduled_time, now) < 0:\n            print(\"Oops, running late, tell task to run faster!\")\n            task.run(run_faster=true)\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/_typeshed/__init__.pyi": "# Utility types for typeshed\n#\n# See the README.md file in this directory for more information.\n\nimport array\nimport sys\nfrom os import PathLike\nfrom typing import AbstractSet, Any, Container, Iterable, Protocol, Tuple, TypeVar, Union\nfrom typing_extensions import Literal, final\n\n_KT = TypeVar(\"_KT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_KT_contra = TypeVar(\"_KT_contra\", contravariant=True)\n_VT = TypeVar(\"_VT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\n# Use for \"self\" annotations:\n#   def __enter__(self: Self) -> Self: ...\nSelf = TypeVar(\"Self\")  # noqa Y001\n\n# stable\nclass IdentityFunction(Protocol):\n    def __call__(self, __x: _T) -> _T: ...\n\nclass SupportsLessThan(Protocol):\n    def __lt__(self, __other: Any) -> bool: ...\n\nSupportsLessThanT = TypeVar(\"SupportsLessThanT\", bound=SupportsLessThan)  # noqa: Y001\n\nclass SupportsDivMod(Protocol[_T_contra, _T_co]):\n    def __divmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsRDivMod(Protocol[_T_contra, _T_co]):\n    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsLenAndGetItem(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __getitem__(self, __k: int) -> _T_co: ...\n\n# Mapping-like protocols\n\n# stable\nclass SupportsItems(Protocol[_KT_co, _VT_co]):\n    def items(self) -> AbstractSet[Tuple[_KT_co, _VT_co]]: ...\n\n# stable\nclass SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):\n    def keys(self) -> Iterable[_KT]: ...\n    def __getitem__(self, __k: _KT) -> _VT_co: ...\n\n# stable\nclass SupportsGetItem(Container[_KT_contra], Protocol[_KT_contra, _VT_co]):\n    def __getitem__(self, __k: _KT_contra) -> _VT_co: ...\n\n# stable\nclass SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):\n    def __setitem__(self, __k: _KT_contra, __v: _VT) -> None: ...\n    def __delitem__(self, __v: _KT_contra) -> None: ...\n\n# These aliases are simple strings in Python 2.\nStrPath = Union[str, PathLike[str]]  # stable\nBytesPath = Union[bytes, PathLike[bytes]]  # stable\nStrOrBytesPath = Union[str, bytes, PathLike[str], PathLike[bytes]]  # stable\n\nOpenTextModeUpdating = Literal[\n    \"r+\",\n    \"+r\",\n    \"rt+\",\n    \"r+t\",\n    \"+rt\",\n    \"tr+\",\n    \"t+r\",\n    \"+tr\",\n    \"w+\",\n    \"+w\",\n    \"wt+\",\n    \"w+t\",\n    \"+wt\",\n    \"tw+\",\n    \"t+w\",\n    \"+tw\",\n    \"a+\",\n    \"+a\",\n    \"at+\",\n    \"a+t\",\n    \"+at\",\n    \"ta+\",\n    \"t+a\",\n    \"+ta\",\n    \"x+\",\n    \"+x\",\n    \"xt+\",\n    \"x+t\",\n    \"+xt\",\n    \"tx+\",\n    \"t+x\",\n    \"+tx\",\n]\nOpenTextModeWriting = Literal[\"w\", \"wt\", \"tw\", \"a\", \"at\", \"ta\", \"x\", \"xt\", \"tx\"]\nOpenTextModeReading = Literal[\"r\", \"rt\", \"tr\", \"U\", \"rU\", \"Ur\", \"rtU\", \"rUt\", \"Urt\", \"trU\", \"tUr\", \"Utr\"]\nOpenTextMode = Union[OpenTextModeUpdating, OpenTextModeWriting, OpenTextModeReading]\nOpenBinaryModeUpdating = Literal[\n    \"rb+\",\n    \"r+b\",\n    \"+rb\",\n    \"br+\",\n    \"b+r\",\n    \"+br\",\n    \"wb+\",\n    \"w+b\",\n    \"+wb\",\n    \"bw+\",\n    \"b+w\",\n    \"+bw\",\n    \"ab+\",\n    \"a+b\",\n    \"+ab\",\n    \"ba+\",\n    \"b+a\",\n    \"+ba\",\n    \"xb+\",\n    \"x+b\",\n    \"+xb\",\n    \"bx+\",\n    \"b+x\",\n    \"+bx\",\n]\nOpenBinaryModeWriting = Literal[\"wb\", \"bw\", \"ab\", \"ba\", \"xb\", \"bx\"]\nOpenBinaryModeReading = Literal[\"rb\", \"br\", \"rbU\", \"rUb\", \"Urb\", \"brU\", \"bUr\", \"Ubr\"]\nOpenBinaryMode = Union[OpenBinaryModeUpdating, OpenBinaryModeReading, OpenBinaryModeWriting]\n\n# stable\nclass HasFileno(Protocol):\n    def fileno(self) -> int: ...\n\nFileDescriptor = int  # stable\nFileDescriptorLike = Union[int, HasFileno]  # stable\n\n# stable\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsReadline(Protocol[_T_co]):\n    def readline(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsNoArgReadline(Protocol[_T_co]):\n    def readline(self) -> _T_co: ...\n\n# stable\nclass SupportsWrite(Protocol[_T_contra]):\n    def write(self, __s: _T_contra) -> Any: ...\n\nReadableBuffer = Union[bytes, bytearray, memoryview, array.array[Any]]  # stable\nWriteableBuffer = Union[bytearray, memoryview, array.array[Any]]  # stable\n\n# stable\nif sys.version_info >= (3, 10):\n    from types import NoneType as NoneType\nelse:\n    # Used by type checkers for checks involving None (does not exist at runtime)\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n",
    "/typeshed/stdlib/microbit/__init__.pyi": "\"\"\"The ``microbit`` module gives you access to all the hardware that is built-in\ninto your board.\n\"\"\"\n\nfrom typing import Any, List, overload\n\nfrom . import accelerometer as accelerometer\nfrom . import compass as compass\nfrom . import display as display\nfrom . import i2c as i2c\nfrom . import microphone as microphone\nfrom . import speaker as speaker\nfrom . import spi as spi\nfrom . import uart as uart\n\n# V2 only\nfrom .. import audio as audio\n\ndef panic(n: int) -> None:\n    \"\"\"Enter a panic mode. Requires restart. Pass in an arbitrary integer <= 255\n    to indicate a status::\n\n        microbit.panic(255)\n    \"\"\"\n\ndef reset() -> None:\n    \"\"\"Restart the board.\"\"\"\n\ndef sleep(n: float) -> None:\n    \"\"\"Wait for ``n`` milliseconds. One second is 1000 milliseconds, so::\n\n        microbit.sleep(1000)\n\n    will pause the execution for one second.  ``n`` can be an integer or\n    a floating point number.\n    \"\"\"\n\ndef running_time() -> int:\n    \"\"\"Return the number of milliseconds since the board was switched on or\n    restarted.\n    \"\"\"\n\ndef temperature() -> int:\n    \"\"\"Return the temperature of the micro:bit in degrees Celcius.\"\"\"\n\ndef set_volume(v: int) -> None:\n    \"\"\"Sets the volume. ``v`` is a value between 0 and 255.\n\n    **V2** only.\n    \n    Out of range values will be clamped to 0 or 255.\n    \"\"\"\n    ...\n\nclass Button:\n    \"\"\"Represents a button.\n\n    .. note::\n        This class is not actually available to the user, it is only used by\n        the two button instances, which are provided already initialized.\n    \"\"\"\n\n    def is_pressed(self) -> bool:\n        \"\"\"Returns ``True`` if the specified button ``button`` is pressed, and\n        ``False`` otherwise.\n        \"\"\"\n        ...\n    def was_pressed(self) -> bool:\n        \"\"\"Returns ``True`` or ``False`` to indicate if the button was pressed\n        since the device started or the last time this method was called.\n\n        Calling this method will clear the press state so\n        that the button must be pressed again before this method will return\n        ``True`` again.\n        \"\"\"\n        ...\n    def get_presses(self) -> int:\n        \"\"\"Returns the running total of button presses, and resets this total\n        to zero before returning.\n        \"\"\"\n        ...\n\nbutton_a: Button\n\"\"\"A ``Button`` instance representing the left button.\"\"\"\n\nbutton_b: Button\n\"\"\"Represents the right button.\"\"\"\n\nclass MicroBitDigitalPin:\n    \"\"\"The pins are your board's way to communicate with external devices connected to\n    it. There are 19 pins for your disposal, numbered 0-16 and 19-20. Pins 17 and\n    18 are not available. There is also a ``pin_logo`` **V2** and ``pin_speaker``\n    **V2** available to use with the latest micro:bit device.\n    \"\"\"\n\n    NO_PULL: int\n    PULL_UP: int\n    PULL_DOWN: int\n    def read_digital(self) -> int:\n        \"\"\"Return 1 if the pin is high, and 0 if it's low.\"\"\"\n        ...\n    def write_digital(self, value: int) -> None:\n        \"\"\"Set the pin to high if ``value`` is 1, or to low, if it is 0.\"\"\"\n        ...\n    def set_pull(self, value: int) -> None:\n        \"\"\"Set the pull state to one of three possible values: ``pin.PULL_UP``,\n        ``pin.PULL_DOWN`` or ``pin.NO_PULL`` (where ``pin`` is an instance of\n        a pin). See below for discussion of default pull states.\n        \"\"\"\n        ...\n    def get_pull(self) -> int:\n        \"\"\"Returns the pull configuration on a pin, which can be one of three\n        possible values: ``NO_PULL``, ``PULL_DOWN``, or ``PULL_UP``. These\n        are set using the ``set_pull()`` method or automatically configured\n        when a pin mode requires it.\"\"\"\n        ...\n    def get_mode(self) -> str:\n        \"\"\"Returns the pin mode. When a pin is used for a specific function, like\n        writing a digital value, or reading an analog value, the pin mode\n        changes. Pins can have one of the following modes: ``\"unused\"``,\n        ``\"analog\"``, ``\"read_digital\"``, ``\"write_digital\"``,\n        ``\"display\"``, ``\"button\"``, ``\"music\"``, ``\"audio\"``,\n        ``\"touch\"``, ``\"i2c\"``, ``\"spi\"``.\n        \"\"\"\n        ...\n\nclass MicroBitAnalogDigitalPin(MicroBitDigitalPin):\n    def read_analog(self) -> int:\n        \"\"\"Read the voltage applied to the pin, and return it as an integer\n        between 0 (meaning 0V) and 1023 (meaning 3.3V).\n        \"\"\"\n    def write_analog(self, value: int) -> None:\n        \"\"\"Output a PWM signal on the pin, with the duty cycle proportional to\n        the provided ``value``. The ``value`` may be either an integer or a\n        floating point number between 0 (0% duty cycle) and 1023 (100% duty).\n        \"\"\"\n    def set_analog_period(self, period: int) -> None:\n        \"\"\"Set the period of the PWM signal being output to ``period`` in\n        milliseconds. The minimum valid value is 1ms.\n        \"\"\"\n    def set_analog_period_microseconds(self, period: int) -> None:\n        \"\"\"Set the period of the PWM signal being output to ``period`` in\n        microseconds. The minimum valid value is 256\u00b5s.\n        \"\"\"\n\nclass MicroBitTouchPin(MicroBitAnalogDigitalPin):\n    CAPACITIVE: int\n    RESISTIVE: int\n    def is_touched(self) -> bool:\n        \"\"\"Return ``True`` if the pin is being touched with a finger, otherwise\n        return ``False``.\n\n        .. note::\n            The default touch mode for the pins on the edge connector is\n            `resistive`. The default for the logo pin **V2** is `capacitive`.\n\n        **Resistive touch**\n        This test is done by measuring how much resistance there is between the\n        pin and ground.  A low resistance gives a reading of ``True``.  To get\n        a reliable reading using a finger you may need to touch the ground pin\n        with another part of your body, for example your other hand.\n\n        **Capacitive touch**\n        This test is done by interacting with the electric field of a capacitor\n        using a finger as a conductor. `Capacitive touch\n        <https://www.allaboutcircuits.com/technical-articles/introduction-to-capacitive-touch-sensing>`_\n        does not require you to make a ground connection as part of a circuit.\n        \"\"\"\n        ...\n        def set_touch_mode(value: int) -> None:\n            \"\"\"\n            .. note::\n                The default touch mode for the pins on the edge connector is\n                `resistive`. The default for the logo pin **V2** is `capacitive`.\n\n            Set the touch mode for the given pin. Value can be either ``CAPACITIVE``\n            or ``RESISTIVE``. For example, ``pin0.set_touch_mode(pin0.CAPACITIVE)``.\n            \"\"\"\n            ...\n\npin0: MicroBitTouchPin\npin1: MicroBitTouchPin\npin2: MicroBitTouchPin\npin3: MicroBitAnalogDigitalPin\npin4: MicroBitAnalogDigitalPin\npin5: MicroBitDigitalPin\npin6: MicroBitDigitalPin\npin7: MicroBitDigitalPin\npin8: MicroBitDigitalPin\npin9: MicroBitDigitalPin\npin10: MicroBitAnalogDigitalPin\npin11: MicroBitDigitalPin\npin12: MicroBitDigitalPin\npin13: MicroBitDigitalPin\npin14: MicroBitDigitalPin\npin15: MicroBitDigitalPin\npin16: MicroBitDigitalPin\npin19: MicroBitDigitalPin\npin20: MicroBitDigitalPin\n\npin_logo: MicroBitTouchPin\npin_speaker: MicroBitAnalogDigitalPin\n\nclass Image:\n    \"\"\"The ``Image`` class is used to create images that can be displayed easily on\n    the device's LED matrix. Given an image object it's possible to display it via\n    the ``display`` API::\n\n        display.show(Image.HAPPY)\n    \"\"\"\n\n    HEART: Image\n    HEART_SMALL: Image\n    HAPPY: Image\n    SMILE: Image\n    SAD: Image\n    CONFUSED: Image\n    ANGRY: Image\n    ASLEEP: Image\n    SURPRISED: Image\n    SILLY: Image\n    FABULOUS: Image\n    MEH: Image\n    YES: Image\n    NO: Image\n    CLOCK12: Image\n    CLOCK11: Image\n    CLOCK10: Image\n    CLOCK9: Image\n    CLOCK8: Image\n    CLOCK7: Image\n    CLOCK6: Image\n    CLOCK5: Image\n    CLOCK4: Image\n    CLOCK3: Image\n    CLOCK2: Image\n    CLOCK1: Image\n    ARROW_N: Image\n    ARROW_NE: Image\n    ARROW_E: Image\n    ARROW_SE: Image\n    ARROW_S: Image\n    ARROW_SW: Image\n    ARROW_W: Image\n    ARROW_NW: Image\n    TRIANGLE: Image\n    TRIANGLE_LEFT: Image\n    CHESSBOARD: Image\n    DIAMOND: Image\n    DIAMOND_SMALL: Image\n    SQUARE: Image\n    SQUARE_SMALL: Image\n    RABBIT: Image\n    COW: Image\n    MUSIC_CROTCHET: Image\n    MUSIC_QUAVER: Image\n    MUSIC_QUAVERS: Image\n    PITCHFORK: Image\n    XMAS: Image\n    PACMAN: Image\n    TARGET: Image\n    TSHIRT: Image\n    ROLLERSKATE: Image\n    DUCK: Image\n    HOUSE: Image\n    TORTOISE: Image\n    BUTTERFLY: Image\n    STICKFIGURE: Image\n    GHOST: Image\n    SWORD: Image\n    GIRAFFE: Image\n    SKULL: Image\n    UMBRELLA: Image\n    SNAKE: Image\n\n    ALL_CLOCKS: List[Image]\n    ALL_ARROWS: List[Image]\n    @overload\n    def __init__(self, string: str) -> None:\n        \"\"\"``string`` has to consist of digits 0-9 arranged into lines,\n        describing the image, for example::\n\n            image = Image(\"90009:\"\n                          \"09090:\"\n                          \"00900:\"\n                          \"09090:\"\n                          \"90009\")\n\n        will create a 5\u00d75 image of an X. The end of a line is indicated by a\n        colon. It's also possible to use a newline (\\n) to indicate the end of\n        a line like this::\n\n            image = Image(\"90009\\n\"\n                          \"09090\\n\"\n                          \"00900\\n\"\n                          \"09090\\n\"\n                          \"90009\")\n        \"\"\"\n        ...\n    @overload\n    def __init__(\n        self, width: int = None, height: int = None, buffer: Any = None\n    ) -> None:\n        \"\"\"Create an empty image with ``width`` columns and ``height`` rows.\n        Optionally ``buffer`` can be an array of ``width``\u00d7``height`` integers\n        in range 0-9 to initialize the image::\n\n            Image(2, 2, b'\\x08\\x08\\x08\\x08')\n\n        or::\n\n            Image(2, 2, bytearray([9,9,9,9]))\n\n        Will create a 2 x 2 pixel image at full brightness.\n\n        .. note::\n\n            Keyword arguments cannot be passed to ``buffer``.\n        \"\"\"\n        ...\n    def width(self) -> int:\n        \"\"\"Return the number of columns in the image.\"\"\"\n        ...\n    def height(self) -> int:\n        \"\"\"Return the numbers of rows in the image.\"\"\"\n        ...\n    def set_pixel(self, x: int, y: int, value: int) -> None:\n        \"\"\"Set the brightness of the pixel at column ``x`` and row ``y`` to the\n        ``value``, which has to be between 0 (dark) and 9 (bright).\n\n        This method will raise an exception when called on any of the built-in\n        read-only images, like ``Image.HEART``.\n        \"\"\"\n        ...\n    def get_pixel(self, x: int, y: int) -> int:\n        \"\"\"Return the brightness of pixel at column ``x`` and row ``y`` as an\n        integer between 0 and 9.\n        \"\"\"\n        ...\n    def shift_left(self, n: int) -> Image:\n        \"\"\"Return a new image created by shifting the picture left by ``n``\n        columns.\n        \"\"\"\n        ...\n    def shift_right(self, n: int) -> Image:\n        \"\"\"Same as ``image.shift_left(-n)``.\"\"\"\n        ...\n    def shift_up(self, n: int) -> Image:\n        \"\"\"Return a new image created by shifting the picture up by ``n``\n        rows.\n        \"\"\"\n        ...\n    def shift_down(self, n: int) -> Image:\n        \"\"\"Same as ``image.shift_up(-n)``.\"\"\"\n        ...\n    def crop(self, x: int, y: int, w: int, h: int) -> Image:\n        \"\"\"Return a new image by cropping the picture to a width of ``w`` and a\n        height of ``h``, starting with the pixel at column ``x`` and row\n        ``y``.\n        \"\"\"\n        ...\n    def copy(self) -> Image:\n        \"\"\"Return an exact copy of the image.\"\"\"\n        ...\n    def invert(self) -> Image:\n        \"\"\"Return a new image by inverting the brightness of the pixels in the\n        source image.\"\"\"\n        ...\n    def fill(self, value: int) -> None:\n        \"\"\"Set the brightness of all the pixels in the image to the\n        ``value``, which has to be between 0 (dark) and 9 (bright).\n\n        This method will raise an exception when called on any of the built-in\n        read-only images, like ``Image.HEART``.\n        \"\"\"\n        ...\n    def blit(\n        self,\n        src: Image,\n        x: int,\n        y: int,\n        w: int,\n        h: int,\n        xdest: int = ...,\n        ydest: int = ...,\n    ) -> None:\n        \"\"\"Copy the rectangle defined by ``x``, ``y``, ``w``, ``h`` from the\n        image ``src`` into this image at ``xdest``, ``ydest``. Areas in the\n        source rectangle, but outside the source image are treated as having a\n        value of 0.\n\n        ``shift_left()``, ``shift_right()``, ``shift_up()``, ``shift_down()``\n        and ``crop()`` can are all implemented by using ``blit()``.\n\n        For example, img.crop(x, y, w, h) can be implemented as::\n\n            def crop(self, x, y, w, h):\n                res = Image(w, h)\n                res.blit(self, x, y, w, h)\n                return res\n        \"\"\"\n        ...\n    def __repr__(self) -> str:\n        \"\"\"Get a compact string representation of the image.\"\"\"\n        ...\n    def __str__(self) -> str:\n        \"\"\"Get a readable string representation of the image.\"\"\"\n        ...\n    def __add__(self, other: Image) -> Image:\n        \"\"\"Create a new image by adding the brightness values from the two\n        images for each pixel.\n        \"\"\"\n        ...\n    def __sub__(self, other: Image) -> Image:\n        \"\"\"Create a new image by subtracting the brightness values of the\n        other image from this image.\n        \"\"\"\n        ...\n    def __mul__(self, n: float) -> Image:\n        \"\"\"Create a new image by multiplying the brightness of each pixel by\n        ``n``.\n        \"\"\"\n        ...\n    def __div__(self, other: float) -> Image:\n        \"\"\"Create a new image by multiplying the brightness of each pixel by\n        ``n``.\n        \"\"\"\n        ...\n\nclass SoundEvent:\n    \"\"\"Represents the transition of sound events, from ``loud`` to ``quiet`` like speaking or background music.\"\"\"\n\n    LOUD: SoundEvent\n    \"\"\"Represents the transition of sound events, from ``quiet`` to ``loud`` like clapping or shouting.\"\"\"\n    QUIET: SoundEvent\n\nclass Sound:\n    \"\"\"The built-in sounds can be called using ``audio.play(Sound.NAME)``.\"\"\"\n\n    GIGGLE: Sound\n    HAPPY: Sound\n    HELLO: Sound\n    MYSTERIOUS: Sound\n    SAD: Sound\n    SLIDE: Sound\n    SOARING: Sound\n    SPRING: Sound\n    TWINKLE: Sound\n    YAWN: Sound\n",
    "/typeshed/stdlib/microbit/accelerometer.pyi": "\"\"\"This object gives you access to the on-board accelerometer. The accelerometer\nalso provides convenience functions for detecting gestures. The\nrecognised gestures are: ``up``, ``down``, ``left``, ``right``, ``face up``,\n``face down``, ``freefall``, ``3g``, ``6g``, ``8g``, ``shake``.\n\nBy default MicroPython sets the accelerometer range to +/- 2g, changing the\naccelerometer range is currently not possible in MicroPython.\nThe accelerometer returns a value in the range 0..1024 for each axis, which is\nthen scaled accordingly.\n\"\"\"\n\nfrom typing import Tuple\n\ndef get_x() -> int:\n    \"\"\"Get the acceleration measurement in the ``x`` axis, as a positive or\n    negative integer, depending on the direction. The measurement is given in\n    milli-g. By default the accelerometer is configured with a range of +/- 2g,\n    and so this method will return within the range of +/- 2000mg.\n    \"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Get the acceleration measurement in the ``y`` axis, as a positive or\n    negative integer, depending on the direction. The measurement is given in\n    milli-g. By default the accelerometer is configured with a range of +/- 2g,\n    and so this method will return within the range of +/- 2000mg.\n    \"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Get the acceleration measurement in the ``z`` axis, as a positive or\n    negative integer, depending on the direction. The measurement is given in\n    milli-g. By default the accelerometer is configured with a range of +/- 2g,\n    and so this method will return within the range of +/- 2000mg.\n    \"\"\"\n    ...\n\ndef get_values() -> Tuple[int, int, int]:\n    \"\"\"Get the acceleration measurements in all axes at once, as a three-element\n    tuple of integers ordered as X, Y, Z.\n    By default the accelerometer is configured with a range of +/- 2g, and so\n    X, Y, and Z will be within the range of +/-2000mg.\n    \"\"\"\n    ...\n\ndef current_gesture() -> str:\n    \"\"\"Return the name of the current gesture.\n\n    .. note::\n\n        MicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n        ``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n        ``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\n        represented as strings.\n    \"\"\"\n    ...\n\ndef is_gesture(name: str) -> bool:\n    \"\"\"Return True or False to indicate if the named gesture is currently active.\"\"\"\n    ...\n\ndef was_gesture(name: str) -> bool:\n    \"\"\"Return True or False to indicate if the named gesture was active since the\n    last call.\n    \"\"\"\n\ndef get_gestures() -> Tuple[str, ...]:\n    \"\"\"Return a tuple of the gesture history. The most recent is listed last.\n    Also clears the gesture history before returning.\n\n    .. note::\n\n        Gestures are not updated in the background so there needs to be constant\n        calls to some accelerometer method to do the gesture detection. Usually\n        gestures can be detected using a loop with a small :func:`microbit.sleep` delay.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/microbit/compass.pyi": "\"\"\"This module lets you access the built-in electronic compass. Before using,\nthe compass should be calibrated, otherwise the readings may be wrong.\n\n.. warning::\n\n    Calibrating the compass will cause your program to pause until calibration\n    is complete. Calibration consists of a little game to draw a circle on the\n    LED display by rotating the device.\n\"\"\"\n\ndef calibrate() -> None:\n    \"\"\"Starts the calibration process. An instructive message will be scrolled\n    to the user after which they will need to rotate the device in order to\n    draw a circle on the LED display.\n    \"\"\"\n    ...\n\ndef is_calibrated() -> bool:\n    \"\"\"Returns ``True`` if the compass has been successfully calibrated, and\n    returns ``False`` otherwise.\n    \"\"\"\n    ...\n\ndef clear_calibration() -> None:\n    \"\"\"Undoes the calibration, making the compass uncalibrated again.\"\"\"\n    ...\n\ndef get_x() -> int:\n    \"\"\"Gives the reading of the magnetic field strength on the ``x`` axis in nano\n    tesla, as a positive or negative integer, depending on the direction of the\n    field.\n    \"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Gives the reading of the magnetic field strength on the ``y`` axis in nano\n    tesla, as a positive or negative integer, depending on the direction of the\n    field.\n    \"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Gives the reading of the magnetic field strength on the ``z`` axis in nano\n    tesla, as a positive or negative integer, depending on the direction of the\n    field.\n    \"\"\"\n    ...\n\ndef heading() -> int:\n    \"\"\"Gives the compass heading, calculated from the above readings, as an\n    integer in the range from 0 to 360, representing the angle in degrees,\n    clockwise, with north as 0.\n    \"\"\"\n    ...\n\ndef get_field_strength() -> int:\n    \"\"\"Returns an integer indication of the magnitude of the magnetic field around\n    the device in nano tesla.\"\"\"\n    ...\n",
    "/typeshed/stdlib/microbit/display.pyi": "\"\"\"This module controls the 5\u00d75 LED display on the front of your board. It can\nbe used to display images, animations and even text.\n\"\"\"\n\nfrom . import Image\nfrom typing import Union, overload, Iterable\n\ndef get_pixel(x: int, y: int) -> int:\n    \"\"\"Return the brightness of the LED at column ``x`` and row ``y`` as an\n    integer between 0 (off) and 9 (bright).\n    \"\"\"\n    ...\n\ndef set_pixel(x: int, y: int, value: int) -> None:\n    \"\"\"Set the brightness of the LED at column ``x`` and row ``y`` to ``value``,\n    which has to be an integer between 0 and 9.\n    \"\"\"\n    ...\n\ndef clear() -> None:\n    \"\"\"Set the brightness of all LEDs to 0 (off).\"\"\"\n    ...\n\n@overload\ndef show(image: Image) -> None:\n    \"\"\"Display the ``image``.\"\"\"\n    ...\n\n@overload\ndef show(\n    iterable: Union[str, float, int, Iterable[Image]],\n    delay: int = 400,\n    wait: bool = True,\n    loop: bool = False,\n    clear: bool = False,\n) -> None:\n    \"\"\"If ``value`` is a string, float or integer, display letters/digits in sequence.\n    Otherwise, if ``value`` is an iterable sequence of images, display these images in sequence.\n    Each letter, digit or image is shown with ``delay`` milliseconds between them.\n\n    If ``wait`` is ``True``, this function will block until the animation is\n    finished, otherwise the animation will happen in the background.\n\n    If ``loop`` is ``True``, the animation will repeat forever.\n\n    If ``clear`` is ``True``, the display will be cleared after the iterable has finished.\n\n    Note that the ``wait``, ``loop`` and ``clear`` arguments must be specified\n    using their keyword.\n\n    .. note::\n\n        If using a generator as the ``iterable``, then take care not to allocate any memory\n        in the generator as allocating memory in an interrupt is prohibited and will raise a\n        ``MemoryError``.\n    \"\"\"\n    ...\n\ndef scroll(\n    string: Union[str, float, int],\n    delay: int = 150,\n    wait: bool = True,\n    loop: bool = False,\n    monospace: bool = False,\n) -> None:\n    \"\"\"Scrolls ``value`` horizontally on the display. If ``value`` is an integer or float it is\n    first converted to a string using ``str()``. The ``delay`` parameter controls how fast\n    the text is scrolling.\n\n    If ``wait`` is ``True``, this function will block until the animation is\n    finished, otherwise the animation will happen in the background.\n\n    If ``loop`` is ``True``, the animation will repeat forever.\n\n    If ``monospace`` is ``True``, the characters will all take up 5 pixel-columns\n    in width, otherwise there will be exactly 1 blank pixel-column between each\n    character as they scroll.\n\n    Note that the ``wait``, ``loop`` and ``monospace`` arguments must be specified\n    using their keyword.\n    \"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Use on() to turn on the display.\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Use off() to turn off the display (thus allowing you to re-use the GPIO\n    pins associated with the display for other purposes).\n    \"\"\"\n    ...\n\ndef is_on() -> bool:\n    \"\"\"Returns ``True`` if the display is on, otherwise returns ``False``.\"\"\"\n    ...\n\ndef read_light_level():\n    \"\"\"Use the display's LEDs in reverse-bias mode to sense the amount of light\n    falling on the display.  Returns an integer between 0 and 255 representing\n    the light level, with larger meaning more light.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/microbit/i2c.pyi": "\"\"\"The ``i2c`` module lets you communicate with devices connected to your board\nusing the I\u00b2C bus protocol. There can be multiple slave devices connected at\nthe same time, and each one has its own unique address, that is either fixed\nfor the device or configured on it. Your board acts as the I\u00b2C master.\n\nWe use 7-bit addressing for devices because of the reasons stated\n`here <http://www.totalphase.com/support/articles/200349176-7-bit-8-bit-and-10-bit-I2C-Slave-Addressing>`_.\n\nThis may be different to other micro:bit related solutions.\n\nHow exactly you should communicate with the devices, that is, what bytes to\nsend and how to interpret the responses, depends on the device in question and\nshould be described separately in that device's documentation.\n\"\"\"\n\nfrom . import MicroBitDigitalPin, pin19, pin20\nfrom typing import List, Union\nfrom . import pin19, pin20\n\ndef init(\n    freq: int = 100000, sda: MicroBitDigitalPin = pin20, scl: MicroBitDigitalPin = pin19\n) -> None:\n    \"\"\"Re-initialize peripheral with the specified clock frequency ``freq`` on the\n    specified ``sda`` and ``scl`` pins.\n\n    .. warning::\n\n        On a micro:bit V1 board, changing the I\u00b2C pins from defaults will make\n        the accelerometer and compass stop working, as they are connected\n        internally to those pins. This warning does not apply to the **V2**\n        revision of the micro:bit as this has `separate I\u00b2C lines\n        <https://tech.microbit.org/hardware/i2c/>`_\n        for the motion sensors and the edge connector.\n    \"\"\"\n    ...\n\ndef scan() -> List[int]:\n    \"\"\"Scan the bus for devices.  Returns a list of 7-bit addresses corresponding\n    to those devices that responded to the scan.\"\"\"\n    ...\n\ndef read(addr: int, n: int, repeat: bool = False) -> bytes:\n    \"\"\"Read ``n`` bytes from the device with 7-bit address ``addr``. If ``repeat``\n    is ``True``, no stop bit will be sent.\n    \"\"\"\n    ...\n\ndef write(addr: int, buf: Union[bytes, bytearray], repeat=False) -> None:\n    \"\"\"Write bytes from ``buf`` to the device with 7-bit address ``addr``. If\n    ``repeat`` is ``True``, no stop bit will be sent.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/microbit/microphone.pyi": "\"\"\"This object lets you access the built-in microphone available on the\nmicro:bit **V2**. It can be used to respond to sound. The microphone input\nis located on the front of the board alongside a microphone activity LED,\nwhich is lit when the microphone is in use.\n\"\"\"\n\nfrom typing import Optional, Tuple\nfrom . import SoundEvent\n\ndef current_event() -> Optional[SoundEvent]:\n    \"\"\"\n    * **return**: the name of the last recorded sound event,\n    ``SoundEvent('loud')`` or ``SoundEvent('quiet')``.\n    \"\"\"\n    ...\n\ndef was_event(event: SoundEvent) -> bool:\n    \"\"\"\n    * **event**: a sound event,  such as ``SoundEvent.LOUD`` or\n      ``SoundEvent.QUIET``.\n    * **return**: ``true`` if sound was heard at least once since the last\n      call, otherwise ``false``. ``was_event()`` also clears the sound\n      event history before returning.\n    \"\"\"\n    ...\n\ndef is_event(event):\n    \"\"\"\n    * **event**: a sound event,  such as ``SoundEvent.LOUD`` or\n      ``SoundEvent.QUIET``.\n    * **return**: ``true`` if sound event is the most recent since the last\n      call, otherwise ``false``. It does not clear the sound event history.\n    \"\"\"\n    ...\n\ndef get_events() -> Tuple[SoundEvent, ...]:\n    \"\"\"\n    * **return**: a tuple of the event history. The most recent is listed last.\n      ``get_events()`` also clears the sound event history before returning.\n    \"\"\"\n    ...\n\ndef set_threshold(event: SoundEvent, value: int) -> None:\n    \"\"\"\n    * **event**: a sound event, such as ``SoundEvent.LOUD`` or\n      ``SoundEvent.QUIET``.\n\n    * **value**: The threshold level in the range 0-255. For example,\n      ``set_threshold(SoundEvent.LOUD, 250)`` will only trigger if the sound is\n      very loud (>= 250).\n    \"\"\"\n    ...\n\ndef sound_level() -> int:\n    \"\"\"\n    * **return**: a representation of the sound pressure level in the range 0 to\n      255.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/microbit/speaker.pyi": "\"\"\"The micro:bit **V2** has a built-in speaker located on the rear of the board.\n\nBy default sound output will be via the edge connector on pin 0 and the\nbuilt-in speaker **V2**. You can connect wired headphones or a speaker to\npin 0 and GND on the edge connector to hear the sounds.\n\nThe speaker can be turned off or on using the functions listed here.\n\"\"\"\n\ndef off() -> None:\n    \"\"\"Use ``off()`` to turn off the speaker. This does not disable sound output\n    to an edge connector pin.\n    \"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Use ``on()`` to turn on the speaker.\"\"\"\n    ...\n",
    "/typeshed/stdlib/microbit/spi.pyi": "\"\"\"The ``spi`` module lets you talk to a device connected to your board using\na serial peripheral interface (SPI) bus. SPI uses a so-called master-slave\narchitecture with a single master. You will need to specify the connections\nfor three signals:\n\n* SCLK : Serial Clock (output from master).\n* MOSI : Master Output, Slave Input (output from master).\n* MISO : Master Input, Slave Output (output from slave).\n\"\"\"\n\n\nfrom . import pin13, pin14, pin15, MicroBitDigitalPin\nfrom typing import Union\n\n\ndef init(baudrate: int = 1000000, bits: int = 8, mode: int = 0,\n         sclk: MicroBitDigitalPin = pin13,\n         mosi: MicroBitDigitalPin = pin15,\n         miso: MicroBitDigitalPin = pin14) -> None:\n    \"\"\"Initialize SPI communication with the specified parameters on the\n    specified ``pins``. Note that for correct communication, the parameters\n    have to be the same on both communicating devices.\n\n    The ``baudrate`` defines the speed of communication.\n\n    The ``bits`` defines the size of bytes being transmitted. Currently only\n    ``bits=8`` is supported. However, this may change in the future.\n\n    The ``mode`` determines the combination of clock polarity and phase\n    according to the following convention, with polarity as the high order bit\n    and phase as the low order bit:\n\n    +----------+-----------------+--------------+\n    | SPI Mode | Polarity (CPOL) | Phase (CPHA) |\n    +==========+=================+==============+\n    | 0        | 0               | 0            |\n    +----------+-----------------+--------------+\n    | 1        | 0               | 1            |\n    +----------+-----------------+--------------+\n    | 2        | 1               | 0            |\n    +----------+-----------------+--------------+\n    | 3        | 1               | 1            |\n    +----------+-----------------+--------------+\n\n    Polarity (aka CPOL) 0 means that the clock is at logic value 0 when idle\n    and goes high (logic value 1) when active; polarity 1 means the clock is\n    at logic value 1 when idle and goes low (logic value 0) when active. Phase\n    (aka CPHA) 0 means that data is sampled on the leading edge of the clock,\n    and 1 means on the trailing edge\n    (viz. https://en.wikipedia.org/wiki/Signal_edge).\n\n    The ``sclk``, ``mosi`` and ``miso`` arguments specify the pins to use for\n    each type of signal.\n    \"\"\"\n    ...\n\ndef read(nbytes: int) -> bytes:\n    \"\"\"Read at most ``nbytes``. Returns what was read.\"\"\"\n    ...\n\ndef write(buffer: Union[bytes, bytearray]) -> None:\n    \"\"\"Write the ``buffer`` of bytes to the bus.\"\"\"\n    ...\n\n\ndef write_readinto(out: Union[bytes, bytearray], in_: bytearray) -> None:\n    \"\"\"Write the ``out`` buffer to the bus and read any response into the ``in``\n   buffer. The length of the buffers should be the same. The buffers can be\n   the same object.\"\"\"\n   ...",
    "/typeshed/stdlib/microbit/uart.pyi": "\"\"\"The ``uart`` module lets you talk to a device connected to your board using\na serial interface.\n\"\"\"\n\nfrom . import MicroBitDigitalPin\nfrom typing import Optional, Union\n\nODD: int\n\"\"\"Odd partity\"\"\"\n\nEVEN: int\n\"\"\"Even parity\"\"\"\n\ndef init(\n    baudrate: int = 9600,\n    bits: int = 8,\n    parity: Optional[int] = None,\n    stop: int = 1,\n    tx: MicroBitDigitalPin = None,\n    rx: MicroBitDigitalPin = None,\n) -> None:\n    \"\"\"Initialize serial communication with the specified parameters on the\n    specified ``tx`` and ``rx`` pins. Note that for correct communication, the parameters\n    have to be the same on both communicating devices.\n\n    .. warning::\n\n        Initializing the UART on external pins will cause the Python console on\n        USB to become unaccessible, as it uses the same hardware. To bring the\n        console back you must reinitialize the UART without passing anything for\n        ``tx`` or ``rx`` (or passing ``None`` to these arguments).  This means\n        that calling ``uart.init(115200)`` is enough to restore the Python console.\n\n    The ``baudrate`` defines the speed of communication. Common baud\n    rates include:\n\n        * 9600\n        * 14400\n        * 19200\n        * 28800\n        * 38400\n        * 57600\n        * 115200\n\n    The ``bits`` defines the size of bytes being transmitted, and the board\n    only supports 8. The ``parity`` parameter defines how parity is checked,\n    and it can be ``None``, ``microbit.uart.ODD`` or ``microbit.uart.EVEN``.\n    The ``stop`` parameter tells the number of stop bits, and has to be 1 for\n    this board.\n\n    If ``tx`` and ``rx`` are not specified then the internal USB-UART TX/RX pins\n    are used which connect to the USB serial converter on the micro:bit, thus\n    connecting the UART to your PC.  You can specify any other pins you want by\n    passing the desired pin objects to the ``tx`` and ``rx`` parameters.\n\n    .. note::\n\n        When connecting the device, make sure you \"cross\" the wires -- the TX\n        pin on your board needs to be connected with the RX pin on the device,\n        and the RX pin -- with the TX pin on the device. Also make sure the\n        ground pins of both devices are connected.\n    \"\"\"\n    ...\n\ndef any() -> bool:\n    \"\"\"Return ``True`` if any data is waiting, else ``False``.\"\"\"\n    ...\n\ndef read(nbytes: int = None) -> bytes:\n    \"\"\"Read bytes.  If ``nbytes`` is specified then read at most that many\n    bytes, otherwise read as many bytes as possible.\n\n    Return value: a bytes object or ``None`` on timeout.\n\n    A bytes object contains a sequence of bytes. Because\n    `ASCII <https://en.wikipedia.org/wiki/ASCII>`_ characters can fit in\n    single bytes this type of object is often used to represent simple text\n    and offers methods to manipulate it as such, e.g. you can display the text\n    using the ``print()`` function.\n\n    You can also convert this object into a string object, and if there are\n    non-ASCII characters present the encoding can be specified::\n\n        msg_bytes = uart.read()\n        msg_str = str(msg, 'UTF-8')\n\n    .. note::\n\n        The timeout for all UART reads depends on the baudrate and is otherwise\n        not changeable via Python. The timeout, in milliseconds, is given by:\n        ``microbit_uart_timeout_char = 13000 / baudrate + 1``\n\n    .. note::\n\n        The internal UART RX buffer is 64 bytes, so make sure data is read\n        before the buffer is full or some of the data might be lost.\n\n    .. warning::\n\n        Receiving ``0x03`` will stop your program by raising a Keyboard\n        Interrupt. You can enable or disable this using\n        :func:`micropython.kbd_intr()`.\n    \"\"\"\n    ...\n\ndef readinto(buf: bytearray, nbytes: int = None) -> Optional[int]:\n    \"\"\"Read bytes into the ``buf``.  If ``nbytes`` is specified then read at most\n    that many bytes.  Otherwise, read at most ``len(buf)`` bytes.\n\n    Return value: number of bytes read and stored into ``buf`` or ``None`` on\n    timeout.\n    \"\"\"\n\ndef readline() -> Optional[bytes]:\n    \"\"\"Read a line, ending in a newline character.\n\n    Return value: the line read or ``None`` on timeout. The newline character is\n    included in the returned bytes.\n    \"\"\"\n\ndef write(buf: Union[bytes, bytearray]) -> Optional[int]:\n    \"\"\"Write the buffer to the bus, it can be a bytes object or a string::\n\n        uart.write('hello world')\n        uart.write(b'hello world')\n        uart.write(bytes([1, 2, 3]))\n\n    Return value: number of bytes written or ``None`` on timeout.\n    \"\"\"\n",
    "/typeshed/stdlib/collections/__init__.pyi": "import sys\nfrom typing import (\n    Any,\n    Dict,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Optional,\n    Reversible,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n)\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n\nif sys.version_info >= (3, 7):\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n        defaults: Optional[Iterable[Any]] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nelse:\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        verbose: bool = ...,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nclass _OrderedDictKeysView(KeysView[_KT], Reversible[_KT]):\n    def __reversed__(self) -> Iterator[_KT]: ...\n\nclass _OrderedDictItemsView(ItemsView[_KT, _VT], Reversible[Tuple[_KT, _VT]]):\n    def __reversed__(self) -> Iterator[Tuple[_KT, _VT]]: ...\n\nclass _OrderedDictValuesView(ValuesView[_VT], Reversible[_VT]):\n    def __reversed__(self) -> Iterator[_VT]: ...\n\nclass OrderedDict(Dict[_KT, _VT], Reversible[_KT], Generic[_KT, _VT]):\n    def popitem(self, last: bool = ...) -> Tuple[_KT, _VT]: ...\n    def move_to_end(self, key: _KT, last: bool = ...) -> None: ...\n    def copy(self: _S) -> _S: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    def keys(self) -> _OrderedDictKeysView[_KT]: ...\n    def items(self) -> _OrderedDictItemsView[_KT, _VT]: ...\n    def values(self) -> _OrderedDictValuesView[_VT]: ...\n",
    "/src/pyrightconfig.json": "{ \n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"reportMissingModuleSource\": false,\n  \"reportWildcardImportFromLibrary\": false,\n  \"verboseOutput\": true\n }\n"
  }
}