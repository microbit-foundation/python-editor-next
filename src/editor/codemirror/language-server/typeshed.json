{
  "files": {
    "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 (currently 3.5 and lower) are\n# generally accurate but we do not guarantee their correctness.\n\n__future__: 2.7-\n__main__: 2.7-\n_ast: 2.7-\n_bisect: 2.7-\n_bootlocale: 3.6-3.9\n_codecs: 2.7-\n_collections_abc: 3.3-\n_compat_pickle: 3.6-\n_compression: 3.6-\n_csv: 2.7-\n_curses: 2.7-\n_decimal: 3.6-\n_dummy_thread: 3.6-\n_dummy_threading: 2.7-\n_heapq: 2.7-\n_imp: 3.6-\n_json: 2.7-\n_markupbase: 2.7-\n_msi: 2.7-\n_operator: 3.6-\n_osx_support: 2.7-\n_posixsubprocess: 3.6-\n_py_abc: 3.7-\n_pydecimal: 3.6-\n_random: 2.7-\n_sitebuiltins: 3.6-\n_socket: 3.0-  # present in 2.7 at runtime, but not in typeshed\n_stat: 3.6-\n_thread: 2.7-\n_threading_local: 3.6-\n_tkinter: 2.7-\n_tracemalloc: 3.6-\n_typeshed: 2.7-  # not present at runtime, only for type checking\n_warnings: 2.7-\n_weakref: 2.7-\n_weakrefset: 2.7-\n_winapi: 3.6-\nabc: 2.7-\naifc: 2.7-\nantigravity: 2.7-\nargparse: 2.7-\narray: 2.7-\nast: 2.7-\nasynchat: 2.7-\nasyncio: 3.4-\nasyncore: 2.7-\natexit: 2.7-\naudioop: 2.7-\nbase64: 2.7-\nbdb: 2.7-\nbinascii: 2.7-\nbinhex: 2.7-\nbisect: 2.7-\nbuiltins: 3.0-\nbz2: 2.7-\ncProfile: 2.7-\ncalendar: 2.7-\ncgi: 2.7-\ncgitb: 2.7-\nchunk: 2.7-\ncmath: 2.7-\ncmd: 2.7-\ncode: 2.7-\ncodecs: 2.7-\ncodeop: 2.7-\ncollections: 2.7-\ncollections.abc: 3.3-\ncolorsys: 2.7-\ncompileall: 2.7-\nconcurrent: 3.2-\nconfigparser: 3.0-\ncontextlib: 2.7-\ncontextvars: 3.7-\ncopy: 2.7-\ncopyreg: 2.7-\ncrypt: 2.7-\ncsv: 2.7-\nctypes: 2.7-\ncurses: 2.7-\ndataclasses: 3.7-\ndatetime: 2.7-\ndbm: 2.7-\ndecimal: 2.7-\ndifflib: 2.7-\ndis: 2.7-\ndistutils: 2.7-\ndoctest: 2.7-\ndummy_threading: 2.7-\nemail: 2.7-\nencodings: 2.7-\nensurepip: 2.7-\nenum: 3.4-\nerrno: 2.7-\nfaulthandler: 3.3-\nfcntl: 2.7-\nfilecmp: 2.7-\nfileinput: 2.7-\nfnmatch: 2.7-\nformatter: 2.7-3.9\nfractions: 2.7-\nftplib: 2.7-\nfunctools: 2.7-\ngc: 2.7-\ngenericpath: 2.7-\ngetopt: 2.7-\ngetpass: 2.7-\ngettext: 2.7-\nglob: 2.7-\ngraphlib: 3.9-\ngrp: 2.7-\ngzip: 2.7-\nhashlib: 2.7-\nheapq: 2.7-\nhmac: 2.7-\nhtml: 3.0-\nhttp: 3.0-\nimaplib: 2.7-\nimghdr: 2.7-\nimp: 2.7-\nimportlib: 2.7-\nimportlib.metadata: 3.8-\nimportlib.resources: 3.7-\ninspect: 2.7-\nio: 2.7-\nipaddress: 3.3-\nitertools: 2.7-\njson: 2.7-\nkeyword: 2.7-\nlib2to3: 2.7-\nlinecache: 2.7-\nlocale: 2.7-\nlogging: 2.7-\nlzma: 3.3-\nmacpath: 2.7-3.7\nmacurl2path: 2.7-3.6\nmailbox: 2.7-\nmailcap: 2.7-\nmarshal: 2.7-\nmath: 2.7-\nmimetypes: 2.7-\nmmap: 2.7-\nmodulefinder: 2.7-\nmsilib: 2.7-\nmsvcrt: 2.7-\nmultiprocessing: 2.7-\nnetrc: 2.7-\nnis: 2.7-\nnntplib: 2.7-\nntpath: 2.7-\nnturl2path: 2.7-\nnumbers: 2.7-\nopcode: 2.7-\noperator: 2.7-\noptparse: 2.7-\nos: 2.7-\nossaudiodev: 2.7-\nparser: 2.7-3.9\npathlib: 3.4-\npdb: 2.7-\npickle: 2.7-\npickletools: 2.7-\npipes: 2.7-\npkgutil: 2.7-\nplatform: 2.7-\nplistlib: 2.7-\npoplib: 2.7-\nposix: 2.7-\nposixpath: 2.7-\npprint: 2.7-\nprofile: 2.7-\npstats: 2.7-\npty: 2.7-\npwd: 2.7-\npy_compile: 2.7-\npyclbr: 2.7-\npydoc: 2.7-\npydoc_data: 2.7-\npyexpat: 2.7-\nqueue: 3.0-\nquopri: 2.7-\nrandom: 2.7-\nre: 2.7-\nreadline: 2.7-\nreprlib: 3.0-\nresource: 2.7-\nrlcompleter: 2.7-\nrunpy: 2.7-\nsched: 2.7-\nsecrets: 3.6-\nselect: 2.7-\nselectors: 3.4-\nshelve: 2.7-\nshlex: 2.7-\nshutil: 2.7-\nsignal: 2.7-\nsite: 2.7-\nsmtpd: 2.7-\nsmtplib: 2.7-\nsndhdr: 2.7-\nsocket: 2.7-\nsocketserver: 3.0-\nspwd: 2.7-\nsqlite3: 2.7-\nsre_compile: 2.7-\nsre_constants: 2.7-\nsre_parse: 2.7-\nssl: 2.7-\nstat: 2.7-\nstatistics: 3.4-\nstring: 2.7-\nstringprep: 2.7-\nstruct: 2.7-\nsubprocess: 2.7-\nsunau: 2.7-\nsymbol: 2.7-3.9\nsymtable: 2.7-\nsys: 2.7-\nsysconfig: 2.7-\nsyslog: 2.7-\ntabnanny: 2.7-\ntarfile: 2.7-\ntelnetlib: 2.7-\ntempfile: 2.7-\ntermios: 2.7-\ntextwrap: 2.7-\nthis: 2.7-\nthreading: 2.7-\ntime: 2.7-\ntimeit: 2.7-\ntkinter: 3.0-\ntoken: 2.7-\ntokenize: 2.7-\ntrace: 2.7-\ntraceback: 2.7-\ntracemalloc: 3.4-\ntty: 2.7-\nturtle: 2.7-\ntypes: 2.7-\ntyping: 3.5-\ntyping_extensions: 2.7-\nunicodedata: 2.7-\nunittest: 2.7-\nurllib: 2.7-\nuu: 2.7-\nuuid: 2.7-\nvenv: 3.3-\nwarnings: 2.7-\nwave: 2.7-\nweakref: 2.7-\nwebbrowser: 2.7-\nwinreg: 3.0-\nwinsound: 2.7-\nwsgiref: 2.7-\nxdrlib: 2.7-\nxml: 2.7-\nxmlrpc: 3.0-\nxxlimited: 3.6-\nzipapp: 3.5-\nzipfile: 2.7-\nzipimport: 2.7-\nzlib: 2.7-\nzoneinfo: 3.9-\n",
    "/typeshed/stdlib/__main__.pyi": "from typing import Any\n\ndef __getattr__(name: str) -> Any: ...\n",
    "/typeshed/stdlib/abc.pyi": "from _typeshed import SupportsWrite\nfrom typing import Any, Callable, Dict, Tuple, Type, TypeVar\n\n_T = TypeVar(\"_T\")\n_FuncT = TypeVar(\"_FuncT\", bound=Callable[..., Any])\n\n# These definitions have special processing in mypy\nclass ABCMeta(type):\n    __abstractmethods__: frozenset[str]\n    def __init__(self, name: str, bases: Tuple[type, ...], namespace: Dict[str, Any]) -> None: ...\n    def __instancecheck__(cls: ABCMeta, instance: Any) -> Any: ...\n    def __subclasscheck__(cls: ABCMeta, subclass: Any) -> Any: ...\n    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = ...) -> None: ...\n    def register(cls: ABCMeta, subclass: Type[_T]) -> Type[_T]: ...\n\ndef abstractmethod(funcobj: _FuncT) -> _FuncT: ...\n\nclass abstractproperty(property): ...\n\n# These two are deprecated and not supported by mypy\ndef abstractstaticmethod(callable: _FuncT) -> _FuncT: ...\ndef abstractclassmethod(callable: _FuncT) -> _FuncT: ...\n\nclass ABC(metaclass=ABCMeta): ...\n\ndef get_cache_token() -> object: ...\n",
    "/typeshed/stdlib/antigravity.pyi": "def geohash(latitude: float, longitude: float, datedow: bytes) -> None: ...\n",
    "/typeshed/stdlib/array.pyi": "import sys\nfrom typing import Any, BinaryIO, Generic, Iterable, List, MutableSequence, Tuple, TypeVar, Union, overload\nfrom typing_extensions import Literal\n\n_IntTypeCode = Literal[\"b\", \"B\", \"h\", \"H\", \"i\", \"I\", \"l\", \"L\", \"q\", \"Q\"]\n_FloatTypeCode = Literal[\"f\", \"d\"]\n_UnicodeTypeCode = Literal[\"u\"]\n_TypeCode = Union[_IntTypeCode, _FloatTypeCode, _UnicodeTypeCode]\n\n_T = TypeVar(\"_T\", int, float, str)\n\ntypecodes: str\n\nclass array(MutableSequence[_T], Generic[_T]):\n    typecode: _TypeCode\n    itemsize: int\n    @overload\n    def __init__(self: array[int], typecode: _IntTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...\n    @overload\n    def __init__(self: array[float], typecode: _FloatTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...\n    @overload\n    def __init__(self: array[str], typecode: _UnicodeTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...\n    @overload\n    def __init__(self, typecode: str, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...\n    def append(self, __v: _T) -> None: ...\n    def buffer_info(self) -> Tuple[int, int]: ...\n    def byteswap(self) -> None: ...\n    def count(self, __v: Any) -> int: ...\n    def extend(self, __bb: Iterable[_T]) -> None: ...\n    def frombytes(self, __buffer: bytes) -> None: ...\n    def fromfile(self, __f: BinaryIO, __n: int) -> None: ...\n    def fromlist(self, __list: List[_T]) -> None: ...\n    def fromunicode(self, __ustr: str) -> None: ...\n    if sys.version_info >= (3, 10):\n        def index(self, __v: _T, __start: int = ..., __stop: int = ...) -> int: ...\n    else:\n        def index(self, __v: _T) -> int: ...  # type: ignore  # Overrides Sequence\n    def insert(self, __i: int, __v: _T) -> None: ...\n    def pop(self, __i: int = ...) -> _T: ...\n    def remove(self, __v: Any) -> None: ...\n    def reverse(self) -> None: ...\n    def tobytes(self) -> bytes: ...\n    def tofile(self, __f: BinaryIO) -> None: ...\n    def tolist(self) -> List[_T]: ...\n    def tounicode(self) -> str: ...\n    if sys.version_info < (3, 9):\n        def fromstring(self, __buffer: bytes) -> None: ...\n        def tostring(self) -> bytes: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> array[_T]: ...\n    @overload  # type: ignore  # Overrides MutableSequence\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: array[_T]) -> None: ...\n    def __delitem__(self, i: Union[int, slice]) -> None: ...\n    def __add__(self, x: array[_T]) -> array[_T]: ...\n    def __ge__(self, other: array[_T]) -> bool: ...\n    def __gt__(self, other: array[_T]) -> bool: ...\n    def __iadd__(self, x: array[_T]) -> array[_T]: ...  # type: ignore  # Overrides MutableSequence\n    def __imul__(self, n: int) -> array[_T]: ...\n    def __le__(self, other: array[_T]) -> bool: ...\n    def __lt__(self, other: array[_T]) -> bool: ...\n    def __mul__(self, n: int) -> array[_T]: ...\n    def __rmul__(self, n: int) -> array[_T]: ...\n\nArrayType = array\n",
    "/typeshed/stdlib/builtins.pyi": "import sys\nimport types\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenBinaryModeReading,\n    OpenBinaryModeUpdating,\n    OpenBinaryModeWriting,\n    OpenTextMode,\n    ReadableBuffer,\n    Self,\n    StrOrBytesPath,\n    SupportsDivMod,\n    SupportsKeysAndGetItem,\n    SupportsLessThan,\n    SupportsLessThanT,\n    SupportsRDivMod,\n    SupportsWrite,\n)\nfrom ast import AST, mod\nfrom io import BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapper\nfrom types import CodeType, TracebackType\nfrom typing import (\n    IO,\n    AbstractSet,\n    Any,\n    AsyncIterable,\n    AsyncIterator,\n    BinaryIO,\n    ByteString,\n    Callable,\n    Dict,\n    FrozenSet,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    List,\n    Mapping,\n    MutableMapping,\n    MutableSequence,\n    MutableSet,\n    NoReturn,\n    Optional,\n    Protocol,\n    Reversible,\n    Sequence,\n    Set,\n    Sized,\n    SupportsAbs,\n    SupportsBytes,\n    SupportsComplex,\n    SupportsFloat,\n    SupportsInt,\n    SupportsRound,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, SupportsIndex, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nclass _SupportsTrunc(Protocol):\n    def __trunc__(self) -> int: ...\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_S = TypeVar(\"_S\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_TT = TypeVar(\"_TT\", bound=\"type\")\n_TBE = TypeVar(\"_TBE\", bound=\"BaseException\")\n\nclass object:\n    __doc__: Optional[str]\n    __dict__: Dict[str, Any]\n    __slots__: Union[str, Iterable[str]]\n    __module__: str\n    __annotations__: Dict[str, Any]\n    @property\n    def __class__(self: _T) -> Type[_T]: ...\n    # Ignore errors about type mismatch between property getter and setter\n    @__class__.setter\n    def __class__(self, __type: Type[object]) -> None: ...  # type: ignore # noqa: F811\n    def __init__(self) -> None: ...\n    def __new__(cls) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __eq__(self, o: object) -> bool: ...\n    def __ne__(self, o: object) -> bool: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    def __format__(self, format_spec: str) -> str: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __delattr__(self, name: str) -> None: ...\n    def __sizeof__(self) -> int: ...\n    def __reduce__(self) -> Union[str, Tuple[Any, ...]]: ...\n    if sys.version_info >= (3, 8):\n        def __reduce_ex__(self, protocol: SupportsIndex) -> str | Tuple[Any, ...]: ...\n    else:\n        def __reduce_ex__(self, protocol: int) -> str | Tuple[Any, ...]: ...\n    def __dir__(self) -> Iterable[str]: ...\n    def __init_subclass__(cls) -> None: ...\n\nclass staticmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Optional[Type[_T]] = ...) -> Callable[..., Any]: ...\n\nclass classmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Optional[Type[_T]] = ...) -> Callable[..., Any]: ...\n\nclass type(object):\n    __base__: type\n    __bases__: Tuple[type, ...]\n    __basicsize__: int\n    __dict__: Dict[str, Any]\n    __dictoffset__: int\n    __flags__: int\n    __itemsize__: int\n    __module__: str\n    __mro__: Tuple[type, ...]\n    __name__: str\n    __qualname__: str\n    __text_signature__: Optional[str]\n    __weakrefoffset__: int\n    @overload\n    def __init__(self, o: object) -> None: ...\n    @overload\n    def __init__(self, name: str, bases: Tuple[type, ...], dict: Dict[str, Any], **kwds: Any) -> None: ...\n    @overload\n    def __new__(cls, o: object) -> type: ...\n    @overload\n    def __new__(cls: Type[_TT], name: str, bases: Tuple[type, ...], namespace: Dict[str, Any], **kwds: Any) -> _TT: ...\n    def __call__(self, *args: Any, **kwds: Any) -> Any: ...\n    def __subclasses__(self: _TT) -> List[_TT]: ...\n    # Note: the documentation doesnt specify what the return type is, the standard\n    # implementation seems to be returning a list.\n    def mro(self) -> List[type]: ...\n    def __instancecheck__(self, instance: Any) -> bool: ...\n    def __subclasscheck__(self, subclass: type) -> bool: ...\n    @classmethod\n    def __prepare__(metacls, __name: str, __bases: Tuple[type, ...], **kwds: Any) -> Mapping[str, Any]: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, t: Any) -> types.Union: ...\n        def __ror__(self, t: Any) -> types.Union: ...\n\nclass super(object):\n    @overload\n    def __init__(self, t: Any, obj: Any) -> None: ...\n    @overload\n    def __init__(self, t: Any) -> None: ...\n    @overload\n    def __init__(self) -> None: ...\n\nclass int:\n    @overload\n    def __new__(cls: Type[_T], x: Union[str, bytes, SupportsInt, SupportsIndex, _SupportsTrunc] = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], x: Union[str, bytes, bytearray], base: SupportsIndex) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def as_integer_ratio(self) -> Tuple[int, Literal[1]]: ...\n    @property\n    def real(self) -> int: ...\n    @property\n    def imag(self) -> int: ...\n    @property\n    def numerator(self) -> int: ...\n    @property\n    def denominator(self) -> int: ...\n    def conjugate(self) -> int: ...\n    def bit_length(self) -> int: ...\n    if sys.version_info >= (3, 10):\n        def bit_count(self) -> int: ...\n    def to_bytes(self, length: SupportsIndex, byteorder: Literal[\"little\", \"big\"], *, signed: bool = ...) -> bytes: ...\n    @classmethod\n    def from_bytes(\n        cls, bytes: Iterable[SupportsIndex] | SupportsBytes, byteorder: Literal[\"little\", \"big\"], *, signed: bool = ...\n    ) -> int: ...  # TODO buffer object argument\n    def __add__(self, x: int) -> int: ...\n    def __sub__(self, x: int) -> int: ...\n    def __mul__(self, x: int) -> int: ...\n    def __floordiv__(self, x: int) -> int: ...\n    def __truediv__(self, x: int) -> float: ...\n    def __mod__(self, x: int) -> int: ...\n    def __divmod__(self, x: int) -> Tuple[int, int]: ...\n    def __radd__(self, x: int) -> int: ...\n    def __rsub__(self, x: int) -> int: ...\n    def __rmul__(self, x: int) -> int: ...\n    def __rfloordiv__(self, x: int) -> int: ...\n    def __rtruediv__(self, x: int) -> float: ...\n    def __rmod__(self, x: int) -> int: ...\n    def __rdivmod__(self, x: int) -> Tuple[int, int]: ...\n    @overload\n    def __pow__(self, __x: Literal[2], __modulo: Optional[int] = ...) -> int: ...\n    @overload\n    def __pow__(self, __x: int, __modulo: Optional[int] = ...) -> Any: ...  # Return type can be int or float, depending on x.\n    def __rpow__(self, x: int, mod: Optional[int] = ...) -> Any: ...\n    def __and__(self, n: int) -> int: ...\n    def __or__(self, n: int) -> int: ...\n    def __xor__(self, n: int) -> int: ...\n    def __lshift__(self, n: int) -> int: ...\n    def __rshift__(self, n: int) -> int: ...\n    def __rand__(self, n: int) -> int: ...\n    def __ror__(self, n: int) -> int: ...\n    def __rxor__(self, n: int) -> int: ...\n    def __rlshift__(self, n: int) -> int: ...\n    def __rrshift__(self, n: int) -> int: ...\n    def __neg__(self) -> int: ...\n    def __pos__(self) -> int: ...\n    def __invert__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    def __round__(self, ndigits: SupportsIndex = ...) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: int) -> bool: ...\n    def __le__(self, x: int) -> bool: ...\n    def __gt__(self, x: int) -> bool: ...\n    def __ge__(self, x: int) -> bool: ...\n    def __str__(self) -> str: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __abs__(self) -> int: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __index__(self) -> int: ...\n\nclass float:\n    def __new__(cls: Type[_T], x: Union[SupportsFloat, SupportsIndex, str, bytes, bytearray] = ...) -> _T: ...\n    def as_integer_ratio(self) -> Tuple[int, int]: ...\n    def hex(self) -> str: ...\n    def is_integer(self) -> bool: ...\n    @classmethod\n    def fromhex(cls, __s: str) -> float: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def conjugate(self) -> float: ...\n    def __add__(self, x: float) -> float: ...\n    def __sub__(self, x: float) -> float: ...\n    def __mul__(self, x: float) -> float: ...\n    def __floordiv__(self, x: float) -> float: ...\n    def __truediv__(self, x: float) -> float: ...\n    def __mod__(self, x: float) -> float: ...\n    def __divmod__(self, x: float) -> Tuple[float, float]: ...\n    def __pow__(\n        self, x: float, mod: None = ...\n    ) -> float: ...  # In Python 3, returns complex if self is negative and x is not whole\n    def __radd__(self, x: float) -> float: ...\n    def __rsub__(self, x: float) -> float: ...\n    def __rmul__(self, x: float) -> float: ...\n    def __rfloordiv__(self, x: float) -> float: ...\n    def __rtruediv__(self, x: float) -> float: ...\n    def __rmod__(self, x: float) -> float: ...\n    def __rdivmod__(self, x: float) -> Tuple[float, float]: ...\n    def __rpow__(self, x: float, mod: None = ...) -> float: ...\n    def __getnewargs__(self) -> Tuple[float]: ...\n    def __trunc__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __ceil__(self) -> int: ...\n        def __floor__(self) -> int: ...\n    @overload\n    def __round__(self, ndigits: None = ...) -> int: ...\n    @overload\n    def __round__(self, ndigits: SupportsIndex) -> float: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: float) -> bool: ...\n    def __le__(self, x: float) -> bool: ...\n    def __gt__(self, x: float) -> bool: ...\n    def __ge__(self, x: float) -> bool: ...\n    def __neg__(self) -> float: ...\n    def __pos__(self) -> float: ...\n    def __str__(self) -> str: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass complex:\n    @overload\n    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], real: Union[str, SupportsComplex, SupportsIndex, complex]) -> _T: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def conjugate(self) -> complex: ...\n    def __add__(self, x: complex) -> complex: ...\n    def __sub__(self, x: complex) -> complex: ...\n    def __mul__(self, x: complex) -> complex: ...\n    def __pow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __truediv__(self, x: complex) -> complex: ...\n    def __radd__(self, x: complex) -> complex: ...\n    def __rsub__(self, x: complex) -> complex: ...\n    def __rmul__(self, x: complex) -> complex: ...\n    def __rpow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __rtruediv__(self, x: complex) -> complex: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __neg__(self) -> complex: ...\n    def __pos__(self) -> complex: ...\n    def __str__(self) -> str: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass _FormatMapMapping(Protocol):\n    def __getitem__(self, __key: str) -> Any: ...\n\nclass str(Sequence[str]):\n    @overload\n    def __new__(cls: Type[_T], o: object = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], o: bytes, encoding: str = ..., errors: str = ...) -> _T: ...\n    def capitalize(self) -> str: ...\n    def casefold(self) -> str: ...\n    def center(self, __width: SupportsIndex, __fillchar: str = ...) -> str: ...\n    def count(self, x: str, __start: Optional[SupportsIndex] = ..., __end: Optional[SupportsIndex] = ...) -> int: ...\n    def encode(self, encoding: str = ..., errors: str = ...) -> bytes: ...\n    def endswith(\n        self, __suffix: Union[str, Tuple[str, ...]], __start: Optional[SupportsIndex] = ..., __end: Optional[SupportsIndex] = ...\n    ) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def expandtabs(self, tabsize: SupportsIndex = ...) -> str: ...\n    else:\n        def expandtabs(self, tabsize: int = ...) -> str: ...\n    def find(self, __sub: str, __start: Optional[SupportsIndex] = ..., __end: Optional[SupportsIndex] = ...) -> int: ...\n    def format(self, *args: object, **kwargs: object) -> str: ...\n    def format_map(self, map: _FormatMapMapping) -> str: ...\n    def index(self, __sub: str, __start: Optional[SupportsIndex] = ..., __end: Optional[SupportsIndex] = ...) -> int: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    if sys.version_info >= (3, 7):\n        def isascii(self) -> bool: ...\n    def isdecimal(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def isidentifier(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isnumeric(self) -> bool: ...\n    def isprintable(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable: Iterable[str]) -> str: ...\n    def ljust(self, __width: SupportsIndex, __fillchar: str = ...) -> str: ...\n    def lower(self) -> str: ...\n    def lstrip(self, __chars: Optional[str] = ...) -> str: ...\n    def partition(self, __sep: str) -> Tuple[str, str, str]: ...\n    def replace(self, __old: str, __new: str, __count: SupportsIndex = ...) -> str: ...\n    if sys.version_info >= (3, 9):\n        def removeprefix(self, __prefix: str) -> str: ...\n        def removesuffix(self, __suffix: str) -> str: ...\n    def rfind(self, __sub: str, __start: Optional[SupportsIndex] = ..., __end: Optional[SupportsIndex] = ...) -> int: ...\n    def rindex(self, __sub: str, __start: Optional[SupportsIndex] = ..., __end: Optional[SupportsIndex] = ...) -> int: ...\n    def rjust(self, __width: SupportsIndex, __fillchar: str = ...) -> str: ...\n    def rpartition(self, __sep: str) -> Tuple[str, str, str]: ...\n    def rsplit(self, sep: Optional[str] = ..., maxsplit: SupportsIndex = ...) -> List[str]: ...\n    def rstrip(self, __chars: Optional[str] = ...) -> str: ...\n    def split(self, sep: Optional[str] = ..., maxsplit: SupportsIndex = ...) -> List[str]: ...\n    def splitlines(self, keepends: bool = ...) -> List[str]: ...\n    def startswith(\n        self, __prefix: Union[str, Tuple[str, ...]], __start: Optional[SupportsIndex] = ..., __end: Optional[SupportsIndex] = ...\n    ) -> bool: ...\n    def strip(self, __chars: Optional[str] = ...) -> str: ...\n    def swapcase(self) -> str: ...\n    def title(self) -> str: ...\n    def translate(self, __table: Union[Mapping[int, Union[int, str, None]], Sequence[Union[int, str, None]]]) -> str: ...\n    def upper(self) -> str: ...\n    def zfill(self, __width: SupportsIndex) -> str: ...\n    @staticmethod\n    @overload\n    def maketrans(__x: Union[Dict[int, _T], Dict[str, _T], Dict[Union[str, int], _T]]) -> Dict[int, _T]: ...\n    @staticmethod\n    @overload\n    def maketrans(__x: str, __y: str, __z: Optional[str] = ...) -> Dict[int, Union[int, None]]: ...\n    def __add__(self, s: str) -> str: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: str) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ge__(self, x: str) -> bool: ...\n    def __getitem__(self, i: Union[int, slice]) -> str: ...\n    def __gt__(self, x: str) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __le__(self, x: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def __lt__(self, x: str) -> bool: ...\n    def __mod__(self, x: Any) -> str: ...\n    def __mul__(self, n: SupportsIndex) -> str: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __repr__(self) -> str: ...\n    def __rmul__(self, n: SupportsIndex) -> str: ...\n    def __str__(self) -> str: ...\n    def __getnewargs__(self) -> Tuple[str]: ...\n\nclass bytes(ByteString):\n    @overload\n    def __new__(cls: Type[_T], ints: Iterable[SupportsIndex]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], string: str, encoding: str, errors: str = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], length: SupportsIndex) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], o: SupportsBytes) -> _T: ...\n    def capitalize(self) -> bytes: ...\n    def center(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytes: ...\n    def count(\n        self, __sub: bytes | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def endswith(\n        self,\n        __suffix: Union[bytes, Tuple[bytes, ...]],\n        __start: Optional[SupportsIndex] = ...,\n        __end: Optional[SupportsIndex] = ...,\n    ) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def expandtabs(self, tabsize: SupportsIndex = ...) -> bytes: ...\n    else:\n        def expandtabs(self, tabsize: int = ...) -> bytes: ...\n    def find(\n        self, __sub: bytes | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    if sys.version_info >= (3, 8):\n        def hex(self, sep: Union[str, bytes] = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...\n    else:\n        def hex(self) -> str: ...\n    def index(\n        self, __sub: bytes | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    if sys.version_info >= (3, 7):\n        def isascii(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[Union[ByteString, memoryview]]) -> bytes: ...\n    def ljust(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytes: ...\n    def lower(self) -> bytes: ...\n    def lstrip(self, __bytes: Optional[bytes] = ...) -> bytes: ...\n    def partition(self, __sep: bytes) -> Tuple[bytes, bytes, bytes]: ...\n    def replace(self, __old: bytes, __new: bytes, __count: SupportsIndex = ...) -> bytes: ...\n    if sys.version_info >= (3, 9):\n        def removeprefix(self, __prefix: bytes) -> bytes: ...\n        def removesuffix(self, __suffix: bytes) -> bytes: ...\n    def rfind(\n        self, __sub: bytes | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def rindex(\n        self, __sub: bytes | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def rjust(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytes: ...\n    def rpartition(self, __sep: bytes) -> Tuple[bytes, bytes, bytes]: ...\n    def rsplit(self, sep: Optional[bytes] = ..., maxsplit: SupportsIndex = ...) -> List[bytes]: ...\n    def rstrip(self, __bytes: Optional[bytes] = ...) -> bytes: ...\n    def split(self, sep: Optional[bytes] = ..., maxsplit: SupportsIndex = ...) -> List[bytes]: ...\n    def splitlines(self, keepends: bool = ...) -> List[bytes]: ...\n    def startswith(\n        self,\n        __prefix: Union[bytes, Tuple[bytes, ...]],\n        __start: Optional[SupportsIndex] = ...,\n        __end: Optional[SupportsIndex] = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: Optional[bytes] = ...) -> bytes: ...\n    def swapcase(self) -> bytes: ...\n    def title(self) -> bytes: ...\n    def translate(self, __table: Optional[bytes], delete: bytes = ...) -> bytes: ...\n    def upper(self) -> bytes: ...\n    def zfill(self, __width: SupportsIndex) -> bytes: ...\n    @classmethod\n    def fromhex(cls, __s: str) -> bytes: ...\n    @staticmethod\n    def maketrans(__frm: bytes, __to: bytes) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytes: ...\n    def __add__(self, s: bytes) -> bytes: ...\n    def __mul__(self, n: SupportsIndex) -> bytes: ...\n    def __rmul__(self, n: SupportsIndex) -> bytes: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n    def __getnewargs__(self) -> Tuple[bytes]: ...\n\nclass bytearray(MutableSequence[int], ByteString):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, ints: Iterable[SupportsIndex]) -> None: ...\n    @overload\n    def __init__(self, string: str, encoding: str, errors: str = ...) -> None: ...\n    @overload\n    def __init__(self, length: SupportsIndex) -> None: ...\n    def append(self, __item: SupportsIndex) -> None: ...\n    def capitalize(self) -> bytearray: ...\n    def center(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytearray: ...\n    def count(\n        self, __sub: bytes | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def copy(self) -> bytearray: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def endswith(\n        self,\n        __suffix: Union[bytes, Tuple[bytes, ...]],\n        __start: Optional[SupportsIndex] = ...,\n        __end: Optional[SupportsIndex] = ...,\n    ) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def expandtabs(self, tabsize: SupportsIndex = ...) -> bytearray: ...\n    else:\n        def expandtabs(self, tabsize: int = ...) -> bytearray: ...\n    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...\n    def find(\n        self, __sub: bytes | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    if sys.version_info >= (3, 8):\n        def hex(self, sep: Union[str, bytes] = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...\n    else:\n        def hex(self) -> str: ...\n    def index(\n        self, __sub: bytes | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def insert(self, __index: SupportsIndex, __item: SupportsIndex) -> None: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    if sys.version_info >= (3, 7):\n        def isascii(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[Union[ByteString, memoryview]]) -> bytearray: ...\n    def ljust(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytearray: ...\n    def lower(self) -> bytearray: ...\n    def lstrip(self, __bytes: Optional[bytes] = ...) -> bytearray: ...\n    def partition(self, __sep: bytes) -> Tuple[bytearray, bytearray, bytearray]: ...\n    if sys.version_info >= (3, 9):\n        def removeprefix(self, __prefix: bytes) -> bytearray: ...\n        def removesuffix(self, __suffix: bytes) -> bytearray: ...\n    def replace(self, __old: bytes, __new: bytes, __count: SupportsIndex = ...) -> bytearray: ...\n    def rfind(\n        self, __sub: bytes | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def rindex(\n        self, __sub: bytes | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def rjust(self, __width: SupportsIndex, __fillchar: bytes = ...) -> bytearray: ...\n    def rpartition(self, __sep: bytes) -> Tuple[bytearray, bytearray, bytearray]: ...\n    def rsplit(self, sep: Optional[bytes] = ..., maxsplit: SupportsIndex = ...) -> List[bytearray]: ...\n    def rstrip(self, __bytes: Optional[bytes] = ...) -> bytearray: ...\n    def split(self, sep: Optional[bytes] = ..., maxsplit: SupportsIndex = ...) -> List[bytearray]: ...\n    def splitlines(self, keepends: bool = ...) -> List[bytearray]: ...\n    def startswith(\n        self,\n        __prefix: Union[bytes, Tuple[bytes, ...]],\n        __start: Optional[SupportsIndex] = ...,\n        __end: Optional[SupportsIndex] = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: Optional[bytes] = ...) -> bytearray: ...\n    def swapcase(self) -> bytearray: ...\n    def title(self) -> bytearray: ...\n    def translate(self, __table: Optional[bytes], delete: bytes = ...) -> bytearray: ...\n    def upper(self) -> bytearray: ...\n    def zfill(self, __width: SupportsIndex) -> bytearray: ...\n    @classmethod\n    def fromhex(cls, __string: str) -> bytearray: ...\n    @staticmethod\n    def maketrans(__frm: bytes, __to: bytes) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytearray: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, x: SupportsIndex) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, x: Iterable[SupportsIndex] | bytes) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, s: bytes) -> bytearray: ...\n    def __iadd__(self, s: Iterable[int]) -> bytearray: ...\n    def __mul__(self, n: SupportsIndex) -> bytearray: ...\n    def __rmul__(self, n: SupportsIndex) -> bytearray: ...\n    def __imul__(self, n: SupportsIndex) -> bytearray: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n\nclass memoryview(Sized, Sequence[int]):\n    format: str\n    itemsize: int\n    shape: Optional[Tuple[int, ...]]\n    strides: Optional[Tuple[int, ...]]\n    suboffsets: Optional[Tuple[int, ...]]\n    readonly: bool\n    ndim: int\n\n    obj: Union[bytes, bytearray]\n    c_contiguous: bool\n    f_contiguous: bool\n    contiguous: bool\n    nbytes: int\n    def __init__(self, obj: ReadableBuffer) -> None: ...\n    def __enter__(self: Self) -> Self: ...\n    def __exit__(\n        self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[TracebackType]\n    ) -> None: ...\n    def cast(self, format: str, shape: Union[List[int], Tuple[int]] = ...) -> memoryview: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> memoryview: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __setitem__(self, s: slice, o: bytes) -> None: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: SupportsIndex) -> None: ...\n    if sys.version_info >= (3, 8):\n        def tobytes(self, order: Optional[Literal[\"C\", \"F\", \"A\"]] = ...) -> bytes: ...\n    else:\n        def tobytes(self) -> bytes: ...\n    def tolist(self) -> List[int]: ...\n    if sys.version_info >= (3, 8):\n        def toreadonly(self) -> memoryview: ...\n    def release(self) -> None: ...\n    if sys.version_info >= (3, 8):\n        def hex(self, sep: Union[str, bytes] = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...\n    else:\n        def hex(self) -> str: ...\n\n@final\nclass bool(int):\n    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...\n    @overload\n    def __and__(self, x: bool) -> bool: ...\n    @overload\n    def __and__(self, x: int) -> int: ...\n    @overload\n    def __or__(self, x: bool) -> bool: ...\n    @overload\n    def __or__(self, x: int) -> int: ...\n    @overload\n    def __xor__(self, x: bool) -> bool: ...\n    @overload\n    def __xor__(self, x: int) -> int: ...\n    @overload\n    def __rand__(self, x: bool) -> bool: ...\n    @overload\n    def __rand__(self, x: int) -> int: ...\n    @overload\n    def __ror__(self, x: bool) -> bool: ...\n    @overload\n    def __ror__(self, x: int) -> int: ...\n    @overload\n    def __rxor__(self, x: bool) -> bool: ...\n    @overload\n    def __rxor__(self, x: int) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n\nclass slice(object):\n    start: Any\n    step: Any\n    stop: Any\n    @overload\n    def __init__(self, stop: Any) -> None: ...\n    @overload\n    def __init__(self, start: Any, stop: Any, step: Any = ...) -> None: ...\n    __hash__: None  # type: ignore\n    def indices(self, len: SupportsIndex) -> Tuple[int, int, int]: ...\n\nclass tuple(Sequence[_T_co], Generic[_T_co]):\n    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    @overload\n    def __getitem__(self, x: int) -> _T_co: ...\n    @overload\n    def __getitem__(self, x: slice) -> Tuple[_T_co, ...]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __lt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __le__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __gt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __ge__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    @overload\n    def __add__(self, x: Tuple[_T_co, ...]) -> Tuple[_T_co, ...]: ...\n    @overload\n    def __add__(self, x: Tuple[_T, ...]) -> Tuple[Union[_T_co, _T], ...]: ...\n    def __mul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def __rmul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def count(self, __value: Any) -> int: ...\n    def index(self, __value: Any, __start: SupportsIndex = ..., __stop: SupportsIndex = ...) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass function:\n    # TODO not defined in builtins!\n    __name__: str\n    __module__: str\n    __code__: CodeType\n    __qualname__: str\n    __annotations__: Dict[str, Any]\n\nclass list(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T]) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> List[_T]: ...\n    def append(self, __object: _T) -> None: ...\n    def extend(self, __iterable: Iterable[_T]) -> None: ...\n    def pop(self, __index: SupportsIndex = ...) -> _T: ...\n    def index(self, __value: _T, __start: SupportsIndex = ..., __stop: SupportsIndex = ...) -> int: ...\n    def count(self, __value: _T) -> int: ...\n    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...\n    def remove(self, __value: _T) -> None: ...\n    def reverse(self) -> None: ...\n    @overload\n    def sort(self: List[SupportsLessThanT], *, key: None = ..., reverse: bool = ...) -> None: ...\n    @overload\n    def sort(self, *, key: Callable[[_T], SupportsLessThan], reverse: bool = ...) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> List[_T]: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: Union[SupportsIndex, slice]) -> None: ...\n    def __add__(self, x: List[_T]) -> List[_T]: ...\n    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...\n    def __mul__(self, n: SupportsIndex) -> List[_T]: ...\n    def __rmul__(self, n: SupportsIndex) -> List[_T]: ...\n    def __imul__(self: _S, n: SupportsIndex) -> _S: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __gt__(self, x: List[_T]) -> bool: ...\n    def __ge__(self, x: List[_T]) -> bool: ...\n    def __lt__(self, x: List[_T]) -> bool: ...\n    def __le__(self, x: List[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass dict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    @overload\n    def __init__(self: Dict[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self: Dict[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, map: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...\n    def clear(self) -> None: ...\n    def copy(self) -> Dict[_KT, _VT]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, __key: _KT, __default: _VT = ...) -> _VT: ...\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT]: ...\n    def items(self) -> ItemsView[_KT, _VT]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: None = ...) -> dict[_T, Optional[Any]]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, k: _KT) -> _VT: ...\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    def __delitem__(self, v: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> Dict[Union[_KT, _T1], Union[_VT, _T2]]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> Dict[Union[_KT, _T1], Union[_VT, _T2]]: ...\n        def __ior__(self, __value: Mapping[_KT, _VT]) -> Dict[_KT, _VT]: ...  # type: ignore\n\nclass set(MutableSet[_T], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...\n    def add(self, element: _T) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> Set[_T]: ...\n    def difference(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def difference_update(self, *s: Iterable[Any]) -> None: ...\n    def discard(self, element: _T) -> None: ...\n    def intersection(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def intersection_update(self, *s: Iterable[Any]) -> None: ...\n    def isdisjoint(self, s: Iterable[Any]) -> bool: ...\n    def issubset(self, s: Iterable[Any]) -> bool: ...\n    def issuperset(self, s: Iterable[Any]) -> bool: ...\n    def pop(self) -> _T: ...\n    def remove(self, element: _T) -> None: ...\n    def symmetric_difference(self, s: Iterable[_T]) -> Set[_T]: ...\n    def symmetric_difference_update(self, s: Iterable[_T]) -> None: ...\n    def union(self, *s: Iterable[_T]) -> Set[_T]: ...\n    def update(self, *s: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __iand__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __or__(self, s: AbstractSet[_S]) -> Set[Union[_T, _S]]: ...\n    def __ior__(self, s: AbstractSet[_S]) -> Set[Union[_T, _S]]: ...\n    def __sub__(self, s: AbstractSet[Optional[_T]]) -> Set[_T]: ...\n    def __isub__(self, s: AbstractSet[Optional[_T]]) -> Set[_T]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> Set[Union[_T, _S]]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> Set[Union[_T, _S]]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass frozenset(AbstractSet[_T_co], Generic[_T_co]):\n    def __init__(self, iterable: Iterable[_T_co] = ...) -> None: ...\n    def copy(self) -> FrozenSet[_T_co]: ...\n    def difference(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def intersection(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def isdisjoint(self, s: Iterable[_T_co]) -> bool: ...\n    def issubset(self, s: Iterable[object]) -> bool: ...\n    def issuperset(self, s: Iterable[object]) -> bool: ...\n    def symmetric_difference(self, s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def union(self, *s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_S]) -> FrozenSet[Union[_T_co, _S]]: ...\n    def __sub__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> FrozenSet[Union[_T_co, _S]]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass enumerate(Iterator[Tuple[int, _T]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], start: int = ...) -> None: ...\n    def __iter__(self) -> Iterator[Tuple[int, _T]]: ...\n    def __next__(self) -> Tuple[int, _T]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass range(Sequence[int]):\n    start: int\n    stop: int\n    step: int\n    @overload\n    def __init__(self, stop: SupportsIndex) -> None: ...\n    @overload\n    def __init__(self, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ...) -> None: ...\n    def count(self, value: int) -> int: ...\n    def index(self, value: int) -> int: ...  # type: ignore\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> range: ...\n    def __repr__(self) -> str: ...\n    def __reversed__(self) -> Iterator[int]: ...\n\nclass property(object):\n    fget: Optional[Callable[[Any], Any]]\n    fset: Optional[Callable[[Any, Any], None]]\n    fdel: Optional[Callable[[Any], None]]\n    def __init__(\n        self,\n        fget: Optional[Callable[[Any], Any]] = ...,\n        fset: Optional[Callable[[Any, Any], None]] = ...,\n        fdel: Optional[Callable[[Any], None]] = ...,\n        doc: Optional[str] = ...,\n    ) -> None: ...\n    def getter(self, fget: Callable[[Any], Any]) -> property: ...\n    def setter(self, fset: Callable[[Any, Any], None]) -> property: ...\n    def deleter(self, fdel: Callable[[Any], None]) -> property: ...\n    def __get__(self, obj: Any, type: Optional[type] = ...) -> Any: ...\n    def __set__(self, obj: Any, value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nclass _NotImplementedType(Any):  # type: ignore\n    # A little weird, but typing the __call__ as NotImplemented makes the error message\n    # for NotImplemented() much better\n    __call__: NotImplemented  # type: ignore\n\nNotImplemented: _NotImplementedType\n\ndef abs(__x: SupportsAbs[_T]) -> _T: ...\ndef all(__iterable: Iterable[object]) -> bool: ...\ndef any(__iterable: Iterable[object]) -> bool: ...\ndef ascii(__obj: object) -> str: ...\ndef bin(__number: Union[int, SupportsIndex]) -> str: ...\n\nif sys.version_info >= (3, 7):\n    def breakpoint(*args: Any, **kws: Any) -> None: ...\n\ndef callable(__obj: object) -> bool: ...\ndef chr(__i: int) -> str: ...\n\n# We define this here instead of using os.PathLike to avoid import cycle issues.\n# See https://github.com/python/typeshed/pull/991#issuecomment-288160993\n_AnyStr_co = TypeVar(\"_AnyStr_co\", str, bytes, covariant=True)\n\nclass _PathLike(Protocol[_AnyStr_co]):\n    def __fspath__(self) -> _AnyStr_co: ...\n\nif sys.version_info >= (3, 10):\n    def aiter(__iterable: AsyncIterable[_T]) -> AsyncIterator[_T]: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T]) -> _T: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T], default: _VT) -> Union[_T, _VT]: ...\n\nif sys.version_info >= (3, 8):\n    def compile(\n        source: Union[str, bytes, mod, AST],\n        filename: Union[str, bytes, _PathLike[Any]],\n        mode: str,\n        flags: int = ...,\n        dont_inherit: int = ...,\n        optimize: int = ...,\n        *,\n        _feature_version: int = ...,\n    ) -> Any: ...\n\nelse:\n    def compile(\n        source: Union[str, bytes, mod, AST],\n        filename: Union[str, bytes, _PathLike[Any]],\n        mode: str,\n        flags: int = ...,\n        dont_inherit: int = ...,\n        optimize: int = ...,\n    ) -> Any: ...\n\ndef copyright() -> None: ...\ndef credits() -> None: ...\ndef delattr(__obj: Any, __name: str) -> None: ...\ndef dir(__o: object = ...) -> List[str]: ...\n@overload\ndef divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...\n@overload\ndef divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...\ndef eval(\n    __source: Union[str, bytes, CodeType], __globals: Optional[Dict[str, Any]] = ..., __locals: Optional[Mapping[str, Any]] = ...\n) -> Any: ...\ndef exec(\n    __source: Union[str, bytes, CodeType], __globals: Optional[Dict[str, Any]] = ..., __locals: Optional[Mapping[str, Any]] = ...\n) -> Any: ...\ndef exit(code: object = ...) -> NoReturn: ...\n\nclass filter(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __function: None, __iterable: Iterable[Optional[_T]]) -> None: ...\n    @overload\n    def __init__(self, __function: Callable[[_T], Any], __iterable: Iterable[_T]) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\ndef format(__value: object, __format_spec: str = ...) -> str: ...  # TODO unicode\n@overload\ndef getattr(__o: Any, name: str) -> Any: ...\n\n# While technically covered by the last overload, spelling out the types for None and bool\n# help mypy out in some tricky situations involving type context (aka bidirectional inference)\n@overload\ndef getattr(__o: Any, name: str, __default: None) -> Optional[Any]: ...\n@overload\ndef getattr(__o: Any, name: str, __default: bool) -> Union[Any, bool]: ...\n@overload\ndef getattr(__o: Any, name: str, __default: _T) -> Union[Any, _T]: ...\ndef globals() -> Dict[str, Any]: ...\ndef hasattr(__obj: Any, __name: str) -> bool: ...\ndef hash(__obj: object) -> int: ...\ndef help(*args: Any, **kwds: Any) -> None: ...\ndef hex(__number: Union[int, SupportsIndex]) -> str: ...\ndef id(__obj: object) -> int: ...\ndef input(__prompt: Any = ...) -> str: ...\n@overload\ndef iter(__iterable: Iterable[_T]) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], Optional[_T]], __sentinel: None) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T], __sentinel: Any) -> Iterator[_T]: ...\n\nif sys.version_info >= (3, 10):\n    def isinstance(\n        __obj: object, __class_or_tuple: Union[type, types.Union, Tuple[Union[type, types.Union, Tuple[Any, ...]], ...]]\n    ) -> bool: ...\n    def issubclass(\n        __cls: type, __class_or_tuple: Union[type, types.Union, Tuple[Union[type, types.Union, Tuple[Any, ...]], ...]]\n    ) -> bool: ...\n\nelse:\n    def isinstance(__obj: object, __class_or_tuple: Union[type, Tuple[Union[type, Tuple[Any, ...]], ...]]) -> bool: ...\n    def issubclass(__cls: type, __class_or_tuple: Union[type, Tuple[Union[type, Tuple[Any, ...]], ...]]) -> bool: ...\n\ndef len(__obj: Sized) -> int: ...\ndef license() -> None: ...\ndef locals() -> Dict[str, Any]: ...\n\nclass map(Iterator[_S], Generic[_S]):\n    @overload\n    def __init__(self, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> None: ...\n    @overload\n    def __init__(self, __func: Callable[[_T1, _T2], _S], __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> None: ...\n    @overload\n    def __init__(\n        self, __func: Callable[[_T1, _T2, _T3], _S], __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[..., _S],\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_S]: ...\n    def __next__(self) -> _S: ...\n\n@overload\ndef max(\n    __arg1: SupportsLessThanT, __arg2: SupportsLessThanT, *_args: SupportsLessThanT, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef max(__arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef max(__iterable: Iterable[SupportsLessThanT], *, key: None = ...) -> SupportsLessThanT: ...\n@overload\ndef max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef max(__iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T) -> Union[SupportsLessThanT, _T]: ...\n@overload\ndef max(__iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2) -> Union[_T1, _T2]: ...\n@overload\ndef min(\n    __arg1: SupportsLessThanT, __arg2: SupportsLessThanT, *_args: SupportsLessThanT, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef min(__arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef min(__iterable: Iterable[SupportsLessThanT], *, key: None = ...) -> SupportsLessThanT: ...\n@overload\ndef min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef min(__iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T) -> Union[SupportsLessThanT, _T]: ...\n@overload\ndef min(__iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2) -> Union[_T1, _T2]: ...\n@overload\ndef next(__i: Iterator[_T]) -> _T: ...\n@overload\ndef next(__i: Iterator[_T], default: _VT) -> Union[_T, _VT]: ...\ndef oct(__number: Union[int, SupportsIndex]) -> str: ...\n\n_OpenFile = Union[StrOrBytesPath, int]\n_Opener = Callable[[str, int], int]\n\n# Text mode: always returns a TextIOWrapper\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenTextMode = ...,\n    buffering: int = ...,\n    encoding: Optional[str] = ...,\n    errors: Optional[str] = ...,\n    newline: Optional[str] = ...,\n    closefd: bool = ...,\n    opener: Optional[_Opener] = ...,\n) -> TextIOWrapper: ...\n\n# Unbuffered binary mode: returns a FileIO\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryMode,\n    buffering: Literal[0],\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: Optional[_Opener] = ...,\n) -> FileIO: ...\n\n# Buffering is on: return BufferedRandom, BufferedReader, or BufferedWriter\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryModeUpdating,\n    buffering: Literal[-1, 1] = ...,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: Optional[_Opener] = ...,\n) -> BufferedRandom: ...\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryModeWriting,\n    buffering: Literal[-1, 1] = ...,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: Optional[_Opener] = ...,\n) -> BufferedWriter: ...\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryModeReading,\n    buffering: Literal[-1, 1] = ...,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: Optional[_Opener] = ...,\n) -> BufferedReader: ...\n\n# Buffering cannot be determined: fall back to BinaryIO\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryMode,\n    buffering: int,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: Optional[_Opener] = ...,\n) -> BinaryIO: ...\n\n# Fallback if mode is not specified\n@overload\ndef open(\n    file: _OpenFile,\n    mode: str,\n    buffering: int = ...,\n    encoding: Optional[str] = ...,\n    errors: Optional[str] = ...,\n    newline: Optional[str] = ...,\n    closefd: bool = ...,\n    opener: Optional[_Opener] = ...,\n) -> IO[Any]: ...\ndef ord(__c: Union[str, bytes]) -> int: ...\ndef print(\n    *values: object,\n    sep: Optional[str] = ...,\n    end: Optional[str] = ...,\n    file: Optional[SupportsWrite[str]] = ...,\n    flush: bool = ...,\n) -> None: ...\n\n_E = TypeVar(\"_E\", contravariant=True)\n_M = TypeVar(\"_M\", contravariant=True)\n\nclass _SupportsPow2(Protocol[_E, _T_co]):\n    def __pow__(self, __other: _E) -> _T_co: ...\n\nclass _SupportsPow3(Protocol[_E, _M, _T_co]):\n    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def pow(base: int, exp: int, mod: None = ...) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(base: int, exp: int, mod: int) -> int: ...\n    @overload\n    def pow(base: float, exp: float, mod: None = ...) -> float: ...\n    @overload\n    def pow(base: _SupportsPow2[_E, _T_co], exp: _E) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsPow3[_E, _M, _T_co], exp: _E, mod: _M) -> _T_co: ...\n\nelse:\n    @overload\n    def pow(\n        __base: int, __exp: int, __mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(__base: int, __exp: int, __mod: int) -> int: ...\n    @overload\n    def pow(__base: float, __exp: float, __mod: None = ...) -> float: ...\n    @overload\n    def pow(__base: _SupportsPow2[_E, _T_co], __exp: _E) -> _T_co: ...\n    @overload\n    def pow(__base: _SupportsPow3[_E, _M, _T_co], __exp: _E, __mod: _M) -> _T_co: ...\n\ndef quit(code: object = ...) -> NoReturn: ...\n\nclass reversed(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __sequence: Sequence[_T]) -> None: ...\n    @overload\n    def __init__(self, __sequence: Reversible[_T]) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\ndef repr(__obj: object) -> str: ...\n@overload\ndef round(number: SupportsRound[Any]) -> int: ...\n@overload\ndef round(number: SupportsRound[Any], ndigits: None) -> int: ...\n@overload\ndef round(number: SupportsRound[_T], ndigits: SupportsIndex) -> _T: ...\ndef setattr(__obj: Any, __name: str, __value: Any) -> None: ...\n@overload\ndef sorted(__iterable: Iterable[SupportsLessThanT], *, key: None = ..., reverse: bool = ...) -> List[SupportsLessThanT]: ...\n@overload\ndef sorted(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan], reverse: bool = ...) -> List[_T]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def sum(__iterable: Iterable[_T]) -> Union[_T, int]: ...\n    @overload\n    def sum(__iterable: Iterable[_T], start: _S) -> Union[_T, _S]: ...\n\nelse:\n    @overload\n    def sum(__iterable: Iterable[_T]) -> Union[_T, int]: ...\n    @overload\n    def sum(__iterable: Iterable[_T], __start: _S) -> Union[_T, _S]: ...\n\ndef vars(__object: Any = ...) -> Dict[str, Any]: ...\n\nclass zip(Iterator[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1]) -> zip[Tuple[_T1]]: ...\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> zip[Tuple[_T1, _T2]]: ...\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]) -> zip[Tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], __iter4: Iterable[_T4]\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> zip[Tuple[Any, ...]]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __next__(self) -> _T_co: ...\n\ndef __import__(\n    name: str,\n    globals: Optional[Mapping[str, Any]] = ...,\n    locals: Optional[Mapping[str, Any]] = ...,\n    fromlist: Sequence[str] = ...,\n    level: int = ...,\n) -> Any: ...\n\n# Actually the type of Ellipsis is <type 'ellipsis'>, but since it's\n# not exposed anywhere under that name, we make it private here.\nclass ellipsis: ...\n\nEllipsis: ellipsis\n\nclass BaseException(object):\n    args: Tuple[Any, ...]\n    __cause__: Optional[BaseException]\n    __context__: Optional[BaseException]\n    __suppress_context__: bool\n    __traceback__: Optional[TracebackType]\n    def __init__(self, *args: object) -> None: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def with_traceback(self: _TBE, tb: Optional[TracebackType]) -> _TBE: ...\n\nclass GeneratorExit(BaseException): ...\nclass KeyboardInterrupt(BaseException): ...\n\nclass SystemExit(BaseException):\n    code: int\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n\n_StandardError = Exception\n\nclass OSError(Exception):\n    errno: int\n    strerror: str\n    # filename, filename2 are actually Union[str, bytes, None]\n    filename: Any\n    filename2: Any\n    if sys.platform == \"win32\":\n        winerror: int\n\nEnvironmentError = OSError\nIOError = OSError\nif sys.platform == \"win32\":\n    WindowsError = OSError\n\nclass ArithmeticError(_StandardError): ...\nclass AssertionError(_StandardError): ...\n\nclass AttributeError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n        obj: object\n\nclass BufferError(_StandardError): ...\nclass EOFError(_StandardError): ...\n\nclass ImportError(_StandardError):\n    def __init__(self, *args: object, name: Optional[str] = ..., path: Optional[str] = ...) -> None: ...\n    name: Optional[str]\n    path: Optional[str]\n    msg: str  # undocumented\n\nclass LookupError(_StandardError): ...\nclass MemoryError(_StandardError): ...\n\nclass NameError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n\nclass ReferenceError(_StandardError): ...\nclass RuntimeError(_StandardError): ...\n\nclass StopAsyncIteration(Exception):\n    value: Any\n\nclass SyntaxError(_StandardError):\n    msg: str\n    lineno: Optional[int]\n    offset: Optional[int]\n    text: Optional[str]\n    filename: Optional[str]\n    if sys.version_info >= (3, 10):\n        end_lineno: Optional[int]\n        end_offset: Optional[int]\n\nclass SystemError(_StandardError): ...\nclass TypeError(_StandardError): ...\nclass ValueError(_StandardError): ...\nclass FloatingPointError(ArithmeticError): ...\nclass OverflowError(ArithmeticError): ...\nclass ZeroDivisionError(ArithmeticError): ...\nclass ModuleNotFoundError(ImportError): ...\nclass IndexError(LookupError): ...\nclass KeyError(LookupError): ...\nclass UnboundLocalError(NameError): ...\n\nclass BlockingIOError(OSError):\n    characters_written: int\n\nclass ChildProcessError(OSError): ...\nclass ConnectionError(OSError): ...\nclass BrokenPipeError(ConnectionError): ...\nclass ConnectionAbortedError(ConnectionError): ...\nclass ConnectionRefusedError(ConnectionError): ...\nclass ConnectionResetError(ConnectionError): ...\nclass FileExistsError(OSError): ...\nclass FileNotFoundError(OSError): ...\nclass InterruptedError(OSError): ...\nclass IsADirectoryError(OSError): ...\nclass NotADirectoryError(OSError): ...\nclass PermissionError(OSError): ...\nclass ProcessLookupError(OSError): ...\nclass TimeoutError(OSError): ...\nclass NotImplementedError(RuntimeError): ...\nclass RecursionError(RuntimeError): ...\nclass IndentationError(SyntaxError): ...\nclass TabError(IndentationError): ...\nclass UnicodeError(ValueError): ...\n\nclass UnicodeDecodeError(UnicodeError):\n    encoding: str\n    object: bytes\n    start: int\n    end: int\n    reason: str\n    def __init__(self, __encoding: str, __object: bytes, __start: int, __end: int, __reason: str) -> None: ...\n\nclass UnicodeEncodeError(UnicodeError):\n    encoding: str\n    object: str\n    start: int\n    end: int\n    reason: str\n    def __init__(self, __encoding: str, __object: str, __start: int, __end: int, __reason: str) -> None: ...\n\nclass UnicodeTranslateError(UnicodeError): ...\nclass Warning(Exception): ...\nclass UserWarning(Warning): ...\nclass DeprecationWarning(Warning): ...\nclass SyntaxWarning(Warning): ...\nclass RuntimeWarning(Warning): ...\nclass FutureWarning(Warning): ...\nclass PendingDeprecationWarning(Warning): ...\nclass ImportWarning(Warning): ...\nclass UnicodeWarning(Warning): ...\nclass BytesWarning(Warning): ...\nclass ResourceWarning(Warning): ...\n\nif sys.version_info >= (3, 10):\n    class EncodingWarning(Warning): ...\n",
    "/typeshed/stdlib/gc.pyi": "\"\"\"Garbage Collection\n\nThis module provides control over the garbage collection process.\n\"\"\"\n\ndef collect():\n    \"\"\"\n    Run a garbage collection.\n    \"\"\"\n    pass\n\ndef disable():\n    \"\"\"\n    Disable automatic garbage collection. Heap memory can still be \n    allocated, and garbage collection can still be initiated \n    manually using ``gc.collect()``.\n    \"\"\"\n    pass\n\ndef enable():\n    \"\"\"\n    Enable automatic garbage collection.\n    \"\"\"\n    pass\n\ndef isenabled() -> bool:\n    \"\"\"\n    Returns ``true`` when garbage collection is enabled.\n    \"\"\"\n    pass\n\ndef mem_alloc() -> int:\n    \"\"\"\n    Return the number of bytes of heap RAM that are allocated.\n    \"\"\"\n    pass\n\ndef mem_free() -> int:\n    \"\"\"\n    Return the number of bytes of available heap RAM, or -1 if this \n    amount is not known.\n    \"\"\"\n    pass\n\ndef threshold(amount:int = None) -> int:\n    \"\"\"\n    Set or query the additional GC allocation threshold. Normally, a \n    collection is triggered only when a new allocation cannot be \n    satisfied, i.e. on an out-of-memory (OOM) condition. If this \n    function is called, in addition to OOM, a collection will be \n    triggered each time after amount bytes have been allocated (in \n    total, since the previous time such an amount of bytes have been \n    allocated). amount is usually specified as less than the full \n    heap size, with the intention to trigger a collection earlier \n    than when the heap becomes exhausted, and in the hope that an \n    early collection will prevent excessive memory fragmentation. \n    This is a heuristic measure, the effect of which will vary from \n    application to application, as well as the optimal value of the \n    amount parameter.\n\n    Calling the function without argument will return the current value \n    of the threshold. A value of -1 means a disabled allocation threshold.\n    \"\"\"\n    pass",
    "/typeshed/stdlib/machine.pyi": "\"\"\"\n\nFunctions related to the hardware.\n\nDescriptions taken from \n`https://raw.githubusercontent.com/micropython/micropython/master/docs/library/machine.rst`, etc.\n\n====================================================\n\n.. module:: machine\n   :synopsis: functions related to the hardware\n\n   \n\n   The ``machine`` module contains specific functions related to the hardware\n   on a particular board. Most functions in this module allow to achieve direct\n   and unrestricted access to and control of hardware blocks on a system\n   (like CPU, timers, buses, etc.). Used incorrectly, this can lead to\n   malfunction, lockups, crashes of your board, and in extreme cases, hardware\n   damage.\n   \n   .. _machine_callbacks:\n   \n   A note of callbacks used by functions and class methods of :mod:`machine` module:\n   all these callbacks should be considered as executing in an interrupt context.\n   This is true for both physical devices with IDs >= 0 and \"virtual\" devices\n   with negative IDs like -1 (these \"virtual\" devices are still thin shims on\n   top of real hardware and real hardware interrupts). See :ref:`isr_rules`.\n   \n\"\"\"\n\n\n\n__author__ = \"Howard C Lovatt\"\n__copyright__ = \"Howard C Lovatt, 2020 onwards.\"\n__license__ = \"MIT https://opensource.org/licenses/MIT (as used by MicroPython).\"\n__version__ = \"0.6.0\"  # Version set by https://github.com/hlovatt/tag2ver\n\n\n\nfrom abc import abstractmethod\nfrom typing import overload, Union, Tuple, Optional, NoReturn, List, Callable\nfrom typing import Sequence, ClassVar, Any\n\nclass ADC:\n   \"\"\"\n   The ADC class provides an interface to analog-to-digital convertors, and\n   represents a single endpoint that can sample a continuous voltage and\n   convert it to a discretised value.\n   \n   Example usage::\n   \n      import machine\n   \n      adc = machine.ADC(pin)   # create an ADC object acting on a pin\n      val = adc.read_u16()     # read a raw analog value in the range 0-65535\n   \"\"\"\n\n   def __init__(self, pin: Union[int, Pin], /):\n      \"\"\"\n      Access the ADC associated with a source identified by *id*.  This\n      *id* may be an integer (usually specifying a channel number), a\n      :ref:`Pin <machine.Pin>` object, or other value supported by the\n      underlying machine.\n      \"\"\"\n\n   def read_u16(self) -> int:\n      \"\"\"\n      Take an analog reading and return an integer in the range 0-65535.\n      The return value represents the raw reading taken by the ADC, scaled\n      such that the minimum value is 0 and the maximum value is 65535.\n      \"\"\"\n\nclass Pin:\n    \"\"\"\n    A pin is the basic object to control I/O pins.  It has methods to set\n    the mode of the pin (input, output, etc) and methods to get and set the\n    digital logic level. For analog control of a pin, see the ADC class.\n    \"\"\"\n\n    ALT = 3\n    IN = 0\n    IRQ_FALLING = 4\n    IRQ_RISING = 8\n    OPEN_DRAIN = 2\n    OUT = 1\n    PULL_DOWN = 2\n    PULL_UP = 1\n\n    def __init__(self, id: Union[int, str], /, mode: int = IN, pull: int = PULL_UP, af: Union[str, int] = -1):\n         \"\"\"\n         Create a new Pin object associated with the id.  If additional arguments are given,\n         they are used to initialise the pin.  See :meth:`pin.init`.\n         \"\"\"\n\n    def high(self):\n        \"\"\"\n        Sets the pin to high.\n        \"\"\"\n\n    def init(self):\n        \"\"\"\n        Initialises the pin.\n        \"\"\"\n\n    def irq(self, handler: Callable, trigger: int, hard: bool = False) -> Callable:\n        \"\"\"\n        Sets an interrupt for when the pin is rising or falling.\n\n            - ``handler`` the code to execute when the interrupt happens.\n            - ``trigger`` either ``IRQ_RISING`` or ``IRQ_FALLING``\n            - ``hard`` if true a hardware interrupt is used. This reduces the delay between the pin change and the handler being called.\n        \"\"\"\n\n    def low(self):\n        \"\"\"\n        Sets the pin to low.\n        \"\"\"\n\n    def off(self):\n       \"\"\"\n       Sets the pin to be off.\n       \"\"\"\n\n    def on(self):\n       \"\"\"\n       Sets the pin to be on.\n       \"\"\"\n\n    def toggle(self):\n        \"\"\"\n        Sets the pin to high if it's currently low, and vice versa.\n        \"\"\"\n\n    @overload\n    def value(self) -> int:\n        \"\"\"\n        Get or set the digital logic level of the pin:\n    \n            - With no argument, return 0 or 1 depending on the logic level of the pin.\n            - With ``value`` given, set the logic level of the pin.  ``value`` can be\n            anything that converts to a boolean.  If it converts to ``True``, the pin\n            is set high, otherwise it is set low.\n        \"\"\"\n\n    @overload\n    def value(self, value: Any, /) -> None:\n        \"\"\"\n        Get or set the digital logic level of the pin:\n    \n            - With no argument, return 0 or 1 depending on the logic level of the pin.\n            - With ``value`` given, set the logic level of the pin.  ``value`` can be\n            anything that converts to a boolean.  If it converts to ``True``, the pin\n            is set high, otherwise it is set low.\n        \"\"\"\n\nclass SPI:\n   \"\"\"\n   SPI is a synchronous serial protocol that is driven by a master. At the\n   physical level, a bus consists of 3 lines: SCK, MOSI, MISO. Multiple devices\n   can share the same bus. Each device should have a separate, 4th signal,\n   SS (Slave Select), to select a particular device on a bus with which\n   communication takes place. Management of an SS signal should happen in\n   user code (via machine.Pin class).\n   \n   Both hardware and software SPI implementations exist via the\n   :ref:`machine.SPI <machine.SPI>` and `machine.SoftSPI` classes.  Hardware SPI uses underlying\n   hardware support of the system to perform the reads/writes and is usually\n   efficient and fast but may have restrictions on which pins can be used.\n   Software SPI is implemented by bit-banging and can be used on any pin but\n   is not as efficient.  These classes have the same methods available and\n   differ primarily in the way they are constructed.\n   \"\"\"\n\n\n   MSB: ClassVar[int] = ...\n   \"\"\"\n   set the first bit to be the most significant bit\n   \"\"\"\n\n\n   LSB: ClassVar[int] = ...\n   \"\"\"\n   set the first bit to be the least significant bit\n   \"\"\"\n\n   @overload\n   def __init__(self, id: int, /):\n      \"\"\"\n      Construct an SPI object on the given bus, *id*. Values of *id* depend\n      on a particular port and its hardware. Values 0, 1, etc. are commonly used\n      to select hardware SPI block #0, #1, etc.\n   \n      With no additional parameters, the SPI object is created but not\n      initialised (it has the settings from the last initialisation of\n      the bus, if any).  If extra arguments are given, the bus is initialised.\n      See ``init`` for parameters of initialisation.\n      \"\"\"\n\n   @overload\n   def __init__(\n      self, \n      id: int, \n      /, \n      baudrate: int = 1_000_000, \n      *,\n      polarity: int = 0, \n      phase: int = 0, \n      bits: int = 8, \n      firstbit: int = MSB, \n      sck: Optional[Pin] = None, \n      mosi: Optional[Pin] = None, \n      miso: Optional[Pin] = None, \n   ):\n      \"\"\"\n      Construct an SPI object on the given bus, *id*. Values of *id* depend\n      on a particular port and its hardware. Values 0, 1, etc. are commonly used\n      to select hardware SPI block #0, #1, etc.\n   \n      With no additional parameters, the SPI object is created but not\n      initialised (it has the settings from the last initialisation of\n      the bus, if any).  If extra arguments are given, the bus is initialised.\n      See ``init`` for parameters of initialisation.\n      \"\"\"\n\n   @overload\n   def __init__(\n      self, \n      id: int, \n      /, \n      baudrate: int = 1_000_000, \n      *,\n      polarity: int = 0, \n      phase: int = 0, \n      bits: int = 8, \n      firstbit: int = MSB, \n      pins: Optional[Tuple[Pin, Pin, Pin]] = None, \n   ):\n      \"\"\"\n      Construct an SPI object on the given bus, *id*. Values of *id* depend\n      on a particular port and its hardware. Values 0, 1, etc. are commonly used\n      to select hardware SPI block #0, #1, etc.\n   \n      With no additional parameters, the SPI object is created but not\n      initialised (it has the settings from the last initialisation of\n      the bus, if any).  If extra arguments are given, the bus is initialised.\n      See ``init`` for parameters of initialisation.\n      \"\"\"\n\n   @overload\n   def init(\n      self, \n      baudrate: int = 1_000_000, \n      *,\n      polarity: int = 0, \n      phase: int = 0, \n      bits: int = 8, \n      firstbit: int = MSB, \n      sck: Optional[Pin] = None, \n      mosi: Optional[Pin] = None, \n      miso: Optional[Pin] = None, \n   ) -> None:\n      \"\"\"\n      Initialise the SPI bus with the given parameters:\n   \n        - ``baudrate`` is the SCK clock rate.\n        - ``polarity`` can be 0 or 1, and is the level the idle clock line sits at.\n        - ``phase`` can be 0 or 1 to sample data on the first or second clock edge\n          respectively.\n        - ``bits`` is the width in bits of each transfer. Only 8 is guaranteed to be supported by all hardware.\n        - ``firstbit`` can be ``SPI.MSB`` or ``SPI.LSB``.\n        - ``sck``, ``mosi``, ``miso`` are pins (machine.Pin) objects to use for bus signals. For most\n          hardware SPI blocks (as selected by ``id`` parameter to the constructor), pins are fixed\n          and cannot be changed. In some cases, hardware blocks allow 2-3 alternative pin sets for\n          a hardware SPI block. Arbitrary pin assignments are possible only for a bitbanging SPI driver\n          (``id`` = -1).\n        - ``pins`` - WiPy port doesn't ``sck``, ``mosi``, ``miso`` arguments, and instead allows to\n          specify them as a tuple of ``pins`` parameter.\n   \n      In the case of hardware SPI the actual clock frequency may be lower than the\n      requested baudrate. This is dependant on the platform hardware. The actual\n      rate may be determined by printing the SPI object.\n      \"\"\"\n\n   @overload\n   def init(\n      self, \n      baudrate: int = 1_000_000, \n      *,\n      polarity: int = 0, \n      phase: int = 0, \n      bits: int = 8, \n      firstbit: int = MSB, \n      pins: Optional[Tuple[Pin, Pin, Pin]] = None, \n   ) -> None:\n      \"\"\"\n      Initialise the SPI bus with the given parameters:\n   \n        - ``baudrate`` is the SCK clock rate.\n        - ``polarity`` can be 0 or 1, and is the level the idle clock line sits at.\n        - ``phase`` can be 0 or 1 to sample data on the first or second clock edge\n          respectively.\n        - ``bits`` is the width in bits of each transfer. Only 8 is guaranteed to be supported by all hardware.\n        - ``firstbit`` can be ``SPI.MSB`` or ``SPI.LSB``.\n        - ``sck``, ``mosi``, ``miso`` are pins (machine.Pin) objects to use for bus signals. For most\n          hardware SPI blocks (as selected by ``id`` parameter to the constructor), pins are fixed\n          and cannot be changed. In some cases, hardware blocks allow 2-3 alternative pin sets for\n          a hardware SPI block. Arbitrary pin assignments are possible only for a bitbanging SPI driver\n          (``id`` = -1).\n        - ``pins`` - WiPy port doesn't ``sck``, ``mosi``, ``miso`` arguments, and instead allows to\n          specify them as a tuple of ``pins`` parameter.\n   \n      In the case of hardware SPI the actual clock frequency may be lower than the\n      requested baudrate. This is dependant on the platform hardware. The actual\n      rate may be determined by printing the SPI object.\n      \"\"\"\n\n   def deinit(self) -> None:\n      \"\"\"\n      Turn off the SPI bus.\n      \"\"\"\n\n   def read(self, nbytes: int, write: int = 0x00, /) -> bytes:\n      \"\"\"\n       Read a number of bytes specified by ``nbytes`` while continuously writing\n       the single byte given by ``write``.\n       Returns a ``bytes`` object with the data that was read.\n      \"\"\"\n\n   def readinto(self, buf: bytes, write: int = 0x00, /) -> Optional[int]:\n      \"\"\"\n       Read into the buffer specified by ``buf`` while continuously writing the\n       single byte given by ``write``.\n       Returns ``None``.\n   \n       Note: on WiPy this function returns the number of bytes read.\n      \"\"\"\n\n   def write(self, buf: bytes, /) -> Optional[int]:\n      \"\"\"\n       Write the bytes contained in ``buf``.\n       Returns ``None``.\n   \n       Note: on WiPy this function returns the number of bytes written.\n      \"\"\"\n\n   def write_readinto(self, write_buf: bytes, read_buf: bytes, /) -> Optional[int]:\n      \"\"\"\n       Write the bytes from ``write_buf`` while reading into ``read_buf``.  The\n       buffers can be the same or different, but both buffers must have the\n       same length.\n       Returns ``None``.\n   \n       Note: on WiPy this function returns the number of bytes written.\n      \"\"\"\n\nclass SoftSPI:\n   \"\"\"\n   SPI is a synchronous serial protocol that is driven by a master. At the\n   physical level, a bus consists of 3 lines: SCK, MOSI, MISO. Multiple devices\n   can share the same bus. Each device should have a separate, 4th signal,\n   SS (Slave Select), to select a particular device on a bus with which\n   communication takes place. Management of an SS signal should happen in\n   user code (via machine.Pin class).\n   \n   Both hardware and software SPI implementations exist via the\n   :ref:`machine.SPI <machine.SPI>` and `machine.SoftSPI` classes.  Hardware SPI uses underlying\n   hardware support of the system to perform the reads/writes and is usually\n   efficient and fast but may have restrictions on which pins can be used.\n   Software SPI is implemented by bit-banging and can be used on any pin but\n   is not as efficient.  These classes have the same methods available and\n   differ primarily in the way they are constructed.\n   \"\"\"\n\n\n   MSB: ClassVar[int] = ...\n   \"\"\"\n   set the first bit to be the most significant bit\n   \"\"\"\n\n\n   LSB: ClassVar[int] = ...\n   \"\"\"\n   set the first bit to be the least significant bit\n   \"\"\"\n\n   @overload\n   def __init__(self, id: int, /):\n      \"\"\"\n      Construct an SPI object on the given bus, *id*. Values of *id* depend\n      on a particular port and its hardware. Values 0, 1, etc. are commonly used\n      to select hardware SPI block #0, #1, etc.\n   \n      With no additional parameters, the SPI object is created but not\n      initialised (it has the settings from the last initialisation of\n      the bus, if any).  If extra arguments are given, the bus is initialised.\n      See ``init`` for parameters of initialisation.\n      \"\"\"\n\n   @overload\n   def __init__(\n      self, \n      id: int, \n      /, \n      baudrate: int = 1_000_000, \n      *,\n      polarity: int = 0, \n      phase: int = 0, \n      bits: int = 8, \n      firstbit: int = MSB, \n      sck: Optional[Pin] = None, \n      mosi: Optional[Pin] = None, \n      miso: Optional[Pin] = None, \n   ):\n      \"\"\"\n      Construct an SPI object on the given bus, *id*. Values of *id* depend\n      on a particular port and its hardware. Values 0, 1, etc. are commonly used\n      to select hardware SPI block #0, #1, etc.\n   \n      With no additional parameters, the SPI object is created but not\n      initialised (it has the settings from the last initialisation of\n      the bus, if any).  If extra arguments are given, the bus is initialised.\n      See ``init`` for parameters of initialisation.\n      \"\"\"\n\n   @overload\n   def __init__(\n      self, \n      id: int, \n      /, \n      baudrate: int = 1_000_000, \n      *,\n      polarity: int = 0, \n      phase: int = 0, \n      bits: int = 8, \n      firstbit: int = MSB, \n      pins: Optional[Tuple[Pin, Pin, Pin]] = None, \n   ):\n      \"\"\"\n      Construct an SPI object on the given bus, *id*. Values of *id* depend\n      on a particular port and its hardware. Values 0, 1, etc. are commonly used\n      to select hardware SPI block #0, #1, etc.\n   \n      With no additional parameters, the SPI object is created but not\n      initialised (it has the settings from the last initialisation of\n      the bus, if any).  If extra arguments are given, the bus is initialised.\n      See ``init`` for parameters of initialisation.\n      \"\"\"\n\n   @overload\n   def init(\n      self, \n      baudrate: int = 1_000_000, \n      *,\n      polarity: int = 0, \n      phase: int = 0, \n      bits: int = 8, \n      firstbit: int = MSB, \n      sck: Optional[Pin] = None, \n      mosi: Optional[Pin] = None, \n      miso: Optional[Pin] = None, \n   ) -> None:\n      \"\"\"\n      Initialise the SPI bus with the given parameters:\n   \n        - ``baudrate`` is the SCK clock rate.\n        - ``polarity`` can be 0 or 1, and is the level the idle clock line sits at.\n        - ``phase`` can be 0 or 1 to sample data on the first or second clock edge\n          respectively.\n        - ``bits`` is the width in bits of each transfer. Only 8 is guaranteed to be supported by all hardware.\n        - ``firstbit`` can be ``SPI.MSB`` or ``SPI.LSB``.\n        - ``sck``, ``mosi``, ``miso`` are pins (machine.Pin) objects to use for bus signals. For most\n          hardware SPI blocks (as selected by ``id`` parameter to the constructor), pins are fixed\n          and cannot be changed. In some cases, hardware blocks allow 2-3 alternative pin sets for\n          a hardware SPI block. Arbitrary pin assignments are possible only for a bitbanging SPI driver\n          (``id`` = -1).\n        - ``pins`` - WiPy port doesn't ``sck``, ``mosi``, ``miso`` arguments, and instead allows to\n          specify them as a tuple of ``pins`` parameter.\n   \n      In the case of hardware SPI the actual clock frequency may be lower than the\n      requested baudrate. This is dependant on the platform hardware. The actual\n      rate may be determined by printing the SPI object.\n      \"\"\"\n\n   @overload\n   def init(\n      self, \n      baudrate: int = 1_000_000, \n      *,\n      polarity: int = 0, \n      phase: int = 0, \n      bits: int = 8, \n      firstbit: int = MSB, \n      pins: Optional[Tuple[Pin, Pin, Pin]] = None, \n   ) -> None:\n      \"\"\"\n      Initialise the SPI bus with the given parameters:\n   \n        - ``baudrate`` is the SCK clock rate.\n        - ``polarity`` can be 0 or 1, and is the level the idle clock line sits at.\n        - ``phase`` can be 0 or 1 to sample data on the first or second clock edge\n          respectively.\n        - ``bits`` is the width in bits of each transfer. Only 8 is guaranteed to be supported by all hardware.\n        - ``firstbit`` can be ``SPI.MSB`` or ``SPI.LSB``.\n        - ``sck``, ``mosi``, ``miso`` are pins (machine.Pin) objects to use for bus signals. For most\n          hardware SPI blocks (as selected by ``id`` parameter to the constructor), pins are fixed\n          and cannot be changed. In some cases, hardware blocks allow 2-3 alternative pin sets for\n          a hardware SPI block. Arbitrary pin assignments are possible only for a bitbanging SPI driver\n          (``id`` = -1).\n        - ``pins`` - WiPy port doesn't ``sck``, ``mosi``, ``miso`` arguments, and instead allows to\n          specify them as a tuple of ``pins`` parameter.\n   \n      In the case of hardware SPI the actual clock frequency may be lower than the\n      requested baudrate. This is dependant on the platform hardware. The actual\n      rate may be determined by printing the SPI object.\n      \"\"\"\n\n   def deinit(self) -> None:\n      \"\"\"\n      Turn off the SPI bus.\n      \"\"\"\n\n   def read(self, nbytes: int, write: int = 0x00, /) -> bytes:\n      \"\"\"\n       Read a number of bytes specified by ``nbytes`` while continuously writing\n       the single byte given by ``write``.\n       Returns a ``bytes`` object with the data that was read.\n      \"\"\"\n\n   def readinto(self, buf: bytes, write: int = 0x00, /) -> Optional[int]:\n      \"\"\"\n       Read into the buffer specified by ``buf`` while continuously writing the\n       single byte given by ``write``.\n       Returns ``None``.\n   \n       Note: on WiPy this function returns the number of bytes read.\n      \"\"\"\n\n   def write(self, buf: bytes, /) -> Optional[int]:\n      \"\"\"\n       Write the bytes contained in ``buf``.\n       Returns ``None``.\n   \n       Note: on WiPy this function returns the number of bytes written.\n      \"\"\"\n\n   def write_readinto(self, write_buf: bytes, read_buf: bytes, /) -> Optional[int]:\n      \"\"\"\n       Write the bytes from ``write_buf`` while reading into ``read_buf``.  The\n       buffers can be the same or different, but both buffers must have the\n       same length.\n       Returns ``None``.\n   \n       Note: on WiPy this function returns the number of bytes written.\n      \"\"\"\n\nclass I2C:\n   \"\"\"\n   I2C is a two-wire protocol for communicating between devices.  At the physical\n   level it consists of 2 wires: SCL and SDA, the clock and data lines respectively.\n   \n   I2C objects are created attached to a specific bus.  They can be initialised\n   when created, or initialised later on.\n   \n   Printing the I2C object gives you information about its configuration.\n   \n   Both hardware and software I2C implementations exist via the\n   :ref:`machine.I2C <machine.I2C>` and `machine.SoftI2C` classes.  Hardware I2C uses\n   underlying hardware support of the system to perform the reads/writes and is\n   usually efficient and fast but may have restrictions on which pins can be used.\n   Software I2C is implemented by bit-banging and can be used on any pin but is not\n   as efficient.  These classes have the same methods available and differ primarily\n   in the way they are constructed.\n   \n   Example usage::\n   \n       from machine import I2C\n   \n       i2c = I2C(freq=400000)          # create I2C peripheral at frequency of 400kHz\n                                       # depending on the port, extra parameters may be required\n                                       # to select the peripheral and/or pins to use\n   \n       i2c.scan()                      # scan for slaves, returning a list of 7-bit addresses\n   \n       i2c.writeto(42, b'123')         # write 3 bytes to slave with 7-bit address 42\n       i2c.readfrom(42, 4)             # read 4 bytes from slave with 7-bit address 42\n   \n       i2c.readfrom_mem(42, 8, 3)      # read 3 bytes from memory of slave 42,\n                                       #   starting at memory-address 8 in the slave\n       i2c.writeto_mem(42, 2, b'\\x10') # write 1 byte to memory of slave 42\n                                       #   starting at address 2 in the slave\n   \"\"\"\n\n   @overload\n   def __init__(self, id: int, /, *, freq: int = 400_000):\n      \"\"\"\n      Construct and return a new I2C object using the following parameters:\n   \n         - *id* identifies a particular I2C peripheral.  Allowed values for\n           depend on the particular port/board\n         - *scl* should be a pin object specifying the pin to use for SCL.\n         - *sda* should be a pin object specifying the pin to use for SDA.\n         - *freq* should be an integer which sets the maximum frequency\n           for SCL.\n   \n      Note that some ports/boards will have default values of *scl* and *sda*\n      that can be changed in this constructor.  Others will have fixed values\n      of *scl* and *sda* that cannot be changed.\n      \"\"\"\n\n   @overload\n   def __init__(self, id: int, /, *, scl: Pin, sda: Pin, freq: int = 400_000):\n      \"\"\"\n      Construct and return a new I2C object using the following parameters:\n   \n         - *id* identifies a particular I2C peripheral.  Allowed values for\n           depend on the particular port/board\n         - *scl* should be a pin object specifying the pin to use for SCL.\n         - *sda* should be a pin object specifying the pin to use for SDA.\n         - *freq* should be an integer which sets the maximum frequency\n           for SCL.\n   \n      Note that some ports/boards will have default values of *scl* and *sda*\n      that can be changed in this constructor.  Others will have fixed values\n      of *scl* and *sda* that cannot be changed.\n      \"\"\"\n\n   @overload\n   def init(self, *, freq: int = 400_000) -> None:\n      \"\"\"\n     Initialise the I2C bus with the given arguments:\n   \n        - *scl* is a pin object for the SCL line\n        - *sda* is a pin object for the SDA line\n        - *freq* is the SCL clock rate\n      \"\"\"\n\n   @overload\n   def init(self, *, scl: Pin, sda: Pin, freq: int = 400_000) -> None:\n      \"\"\"\n     Initialise the I2C bus with the given arguments:\n   \n        - *scl* is a pin object for the SCL line\n        - *sda* is a pin object for the SDA line\n        - *freq* is the SCL clock rate\n      \"\"\"\n\n   def scan(self) -> List[int]:\n      \"\"\"\n      Scan all I2C addresses between 0x08 and 0x77 inclusive and return a list of\n      those that respond.  A device responds if it pulls the SDA line low after\n      its address (including a write bit) is sent on the bus.\n      \"\"\"\n\n   def start(self) -> None:\n      \"\"\"\n      Generate a START condition on the bus (SDA transitions to low while SCL is high).\n   \n   \n      Primitive I2C operations\n      ------------------------\n      \n      The following methods implement the primitive I2C master bus operations and can\n      be combined to make any I2C transaction.  They are provided if you need more\n      control over the bus, otherwise the standard methods (see below) can be used.\n      \n      These methods are only available on the `machine.SoftI2C` class.\n      \"\"\"\n\n   def stop(self) -> None:\n      \"\"\"\n      Generate a STOP condition on the bus (SDA transitions to high while SCL is high).\n   \n   \n      Primitive I2C operations\n      ------------------------\n      \n      The following methods implement the primitive I2C master bus operations and can\n      be combined to make any I2C transaction.  They are provided if you need more\n      control over the bus, otherwise the standard methods (see below) can be used.\n      \n      These methods are only available on the `machine.SoftI2C` class.\n      \"\"\"\n\n   def readinto(self, buf: bytes, nack: bool = True, /) -> None:\n      \"\"\"\n      Reads bytes from the bus and stores them into *buf*.  The number of bytes\n      read is the length of *buf*.  An ACK will be sent on the bus after\n      receiving all but the last byte.  After the last byte is received, if *nack*\n      is true then a NACK will be sent, otherwise an ACK will be sent (and in this\n      case the slave assumes more bytes are going to be read in a later call).\n   \n   \n      Primitive I2C operations\n      ------------------------\n      \n      The following methods implement the primitive I2C master bus operations and can\n      be combined to make any I2C transaction.  They are provided if you need more\n      control over the bus, otherwise the standard methods (see below) can be used.\n      \n      These methods are only available on the `machine.SoftI2C` class.\n      \"\"\"\n\n   def write(self, buf: bytes, /) -> int:\n      \"\"\"\n      Write the bytes from *buf* to the bus.  Checks that an ACK is received\n      after each byte and stops transmitting the remaining bytes if a NACK is\n      received.  The function returns the number of ACKs that were received.\n   \n   \n      Primitive I2C operations\n      ------------------------\n      \n      The following methods implement the primitive I2C master bus operations and can\n      be combined to make any I2C transaction.  They are provided if you need more\n      control over the bus, otherwise the standard methods (see below) can be used.\n      \n      These methods are only available on the `machine.SoftI2C` class.\n      \"\"\"\n\n   def readfrom(self, addr: int, nbytes: int, stop: bool = True, /) -> bytes:\n      \"\"\"\n      Read *nbytes* from the slave specified by *addr*.\n      If *stop* is true then a STOP condition is generated at the end of the transfer.\n      Returns a `bytes` object with the data read.\n   \n   \n      Standard bus operations\n      -----------------------\n      \n      The following methods implement the standard I2C master read and write\n      operations that target a given slave device.\n      \"\"\"\n\n   def readfrom_into(self, addr: int, buf: bytes, stop: bool = True, /) -> None:\n      \"\"\"\n      Read into *buf* from the slave specified by *addr*.\n      The number of bytes read will be the length of *buf*.\n      If *stop* is true then a STOP condition is generated at the end of the transfer.\n   \n      The method returns ``None``.\n   \n   \n      Standard bus operations\n      -----------------------\n      \n      The following methods implement the standard I2C master read and write\n      operations that target a given slave device.\n      \"\"\"\n\n   def writeto(self, addr: int, buf: bytes, stop: bool = True, /) -> int:\n      \"\"\"\n      Write the bytes from *buf* to the slave specified by *addr*.  If a\n      NACK is received following the write of a byte from *buf* then the\n      remaining bytes are not sent.  If *stop* is true then a STOP condition is\n      generated at the end of the transfer, even if a NACK is received.\n      The function returns the number of ACKs that were received.\n   \n   \n      Standard bus operations\n      -----------------------\n      \n      The following methods implement the standard I2C master read and write\n      operations that target a given slave device.\n      \"\"\"\n\n   \n   def writevto(\n      self, \n      addr: int, \n      vector: Sequence[bytes], \n      stop: bool = True, \n      /\n   ) -> int:\n      \"\"\"\n      Write the bytes contained in *vector* to the slave specified by *addr*.\n      *vector* should be a tuple or list of objects with the buffer protocol.\n      The *addr* is sent once and then the bytes from each object in *vector*\n      are written out sequentially.  The objects in *vector* may be zero bytes\n      in length in which case they don't contribute to the output.\n   \n      If a NACK is received following the write of a byte from one of the\n      objects in *vector* then the remaining bytes, and any remaining objects,\n      are not sent.  If *stop* is true then a STOP condition is generated at\n      the end of the transfer, even if a NACK is received.  The function\n      returns the number of ACKs that were received.\n   \n   \n      Standard bus operations\n      -----------------------\n      \n      The following methods implement the standard I2C master read and write\n      operations that target a given slave device.\n      \"\"\"\n\n   def readfrom_mem(self, addr: int, memaddr: int, nbytes: int, /, *, addrsize: int = 8) -> bytes:\n      \"\"\"\n      Read *nbytes* from the slave specified by *addr* starting from the memory\n      address specified by *memaddr*.\n      The argument *addrsize* specifies the address size in bits.\n      Returns a `bytes` object with the data read.\n   \n   \n      Memory operations\n      -----------------\n      \n      Some I2C devices act as a memory device (or set of registers) that can be read\n      from and written to.  In this case there are two addresses associated with an\n      I2C transaction: the slave address and the memory address.  The following\n      methods are convenience functions to communicate with such devices.\n      \"\"\"\n\n   \n   def readfrom_mem_into(\n      self, \n      addr: int, \n      memaddr: int, \n      buf: bytes, \n      /, \n      *, \n      addrsize: int = 8\n   ) -> None:\n      \"\"\"\n      Read into *buf* from the slave specified by *addr* starting from the\n      memory address specified by *memaddr*.  The number of bytes read is the\n      length of *buf*.\n      The argument *addrsize* specifies the address size in bits (on ESP8266\n      this argument is not recognised and the address size is always 8 bits).\n   \n      The method returns ``None``.\n   \n   \n      Memory operations\n      -----------------\n      \n      Some I2C devices act as a memory device (or set of registers) that can be read\n      from and written to.  In this case there are two addresses associated with an\n      I2C transaction: the slave address and the memory address.  The following\n      methods are convenience functions to communicate with such devices.\n      \"\"\"\n\n   def writeto_mem(self, addr: int, memaddr: int, buf: bytes, /, *, addrsize: int = 8) -> None:\n      \"\"\"\n      Write *buf* to the slave specified by *addr* starting from the\n      memory address specified by *memaddr*.\n      The argument *addrsize* specifies the address size in bits (on ESP8266\n      this argument is not recognised and the address size is always 8 bits).\n   \n      The method returns ``None``.\n   \n      Memory operations\n      -----------------\n      \n      Some I2C devices act as a memory device (or set of registers) that can be read\n      from and written to.  In this case there are two addresses associated with an\n      I2C transaction: the slave address and the memory address.  The following\n      methods are convenience functions to communicate with such devices.\n      \"\"\"\n\nclass PWM:\n   \"\"\"\n   Pulse width modulation (PWM), allows you to give analogue behaviours to digital \n   devices, such as LEDs. This means that rather than an LED being simply on or \n   off, you can control its brightness.\n\n   Example usage::\n\n      from machine import PWM\n\n      pwm = PWM(pin)          # create a PWM object on a pin\n      pwm.duty_u16(32768)     # set duty to 50%\n\n      # reinitialise with a period of 200us, duty of 5us\n      pwm.init(freq=5000, duty_ns=5000)\n\n      pwm.duty_ns(3000)       # set pulse width to 3us\n\n      pwm.deinit()\n   \"\"\"\n\n   def __init__(self, pin: Pin):\n      \"\"\"\n      Construct and return a new PWM object using the following parameters:\n\n         - *pin* should be the pin to use.\n      \"\"\"\n\n   def deinit(self) -> None:\n         \"\"\"\n         Disable the PWM output.\n         \"\"\"\n         \n   def freq(self, frequency: Optional[int]):\n      \"\"\"\n      With no arguments the frequency in Hz is returned.\n\n      With a single *value* argument the frequency is set to that value in Hz.  The method may raise a ``ValueError`` if the frequency is outside the valid range.\n      \"\"\"\n\n   def duty_u16(self, duration: Optional[int]):\n      \"\"\"\n      Get or Set the current duty cycle of the PWM output, as an unsigned 16-bit value in the range 0 to 65535 inclusive.\n\n      With no arguments the duty cycle is returned.\n\n      With a single *value* argument the duty cycle is set to that value, measured as the ratio ``value / 65535``.\n      \"\"\"\n\n   def duty_ns(self, duration: Optional[int]):\n      \"\"\"\n      Get or Set the current pulse width of the PWM output, as a value in nanoseconds.\n\n      With no arguments the pulse width in nanoseconds is returned.\n\n      With a single *value* argument the pulse width is set to that value.\n      \"\"\"\n\nclass Signal:\n   \"\"\"\n   The ``Signal`` class is a simple extension of the ``Pin`` class. Unlike Pin, which can \n   be only in \u201cabsolute\u201d 0 and 1 states, a Signal can be in \u201casserted\u201d (on) or \n   \u201cdeasserted\u201d (off) states, while being inverted (active-low) or not. \n   \n   In other words, it adds logical inversion support to Pin functionality. \n   \n   While this may seem a simple addition, it is exactly what is needed to support \n   wide array of simple digital devices in a way portable across different boards, \n   which is one of the major MicroPython goals. \n   \n   Regardless of whether different users have an active-high or active-low LED, a \n   normally open or normally closed relay - you can develop a single, nicely looking \n   application which works with each of them, and capture hardware configuration \n   differences in few lines in the config file of your app.\n   \"\"\"\n\n   @overload\n   def __init__(self, pin_obj: Pin, invert: bool = False):\n      \"\"\"\n      Create a ``Signal`` object by wrapping existing ``Pin`` object.\n      \"\"\"\n\n   @overload\n   def __init__(self, id: Union[int, str], /, mode: int = Pin.IN, pull: int = Pin.PULL_UP, af: Union[str, int] = -1, invert: bool = False):\n      \"\"\"\n      Create a ``Signal`` object by passing required ``Pin`` parameters directly \n      to ``Signal`` constructor, skipping the need to create intermediate ``Pin`` object.\n      \"\"\"\n\n   def off(self):\n      \"\"\"\n      Deactivate signal.\n      \"\"\"\n\n   def on(self):\n      \"\"\"\n      Activate signal.\n      \"\"\"\n\n   def value(self, x: Any):\n      \"\"\"\n      This method allows to set and get the value of the signal, depending on whether \n      the argument ``x`` is supplied or not.\n\n      If the argument is omitted then this method gets the signal level, ``1`` meaning signal \n      is asserted (active) and ``0`` meaning signal inactive.\n\n      If the argument is supplied then this method sets the signal level. The argument ``x`` can \n      be anything that converts to a boolean. If it converts to ``True``, the signal is active, \n      otherwise it is inactive.\n\n      Correspondence between signal being active and actual logic level on the underlying pin \n      depends on whether signal is inverted (active-low) or not. For non-inverted signal, \n      active status corresponds to logical ``1``, inactive to logical ``0``. For \n      inverted/active-low signal, active status corresponds to logical ``0``, while inactive \n      corresponds to logical ``1``.\n      \"\"\"\n\nclass SoftI2C:\n   \"\"\"\n   I2C is a two-wire protocol for communicating between devices.  At the physical\n   level it consists of 2 wires: SCL and SDA, the clock and data lines respectively.\n   \n   I2C objects are created attached to a specific bus.  They can be initialised\n   when created, or initialised later on.\n   \n   Printing the I2C object gives you information about its configuration.\n   \n   Both hardware and software I2C implementations exist via the\n   :ref:`machine.I2C <machine.I2C>` and `machine.SoftI2C` classes.  Hardware I2C uses\n   underlying hardware support of the system to perform the reads/writes and is\n   usually efficient and fast but may have restrictions on which pins can be used.\n   Software I2C is implemented by bit-banging and can be used on any pin but is not\n   as efficient.  These classes have the same methods available and differ primarily\n   in the way they are constructed.\n   \n   Example usage::\n   \n       from machine import I2C\n   \n       i2c = I2C(freq=400000)          # create I2C peripheral at frequency of 400kHz\n                                       # depending on the port, extra parameters may be required\n                                       # to select the peripheral and/or pins to use\n   \n       i2c.scan()                      # scan for slaves, returning a list of 7-bit addresses\n   \n       i2c.writeto(42, b'123')         # write 3 bytes to slave with 7-bit address 42\n       i2c.readfrom(42, 4)             # read 4 bytes from slave with 7-bit address 42\n   \n       i2c.readfrom_mem(42, 8, 3)      # read 3 bytes from memory of slave 42,\n                                       #   starting at memory-address 8 in the slave\n       i2c.writeto_mem(42, 2, b'\\x10') # write 1 byte to memory of slave 42\n                                       #   starting at address 2 in the slave\n   \"\"\"\n\n   @overload\n   def __init__(self, id: int, /, *, freq: int = 400_000):\n      \"\"\"\n      Construct and return a new I2C object using the following parameters:\n   \n         - *id* identifies a particular I2C peripheral.  Allowed values for\n           depend on the particular port/board\n         - *scl* should be a pin object specifying the pin to use for SCL.\n         - *sda* should be a pin object specifying the pin to use for SDA.\n         - *freq* should be an integer which sets the maximum frequency\n           for SCL.\n   \n      Note that some ports/boards will have default values of *scl* and *sda*\n      that can be changed in this constructor.  Others will have fixed values\n      of *scl* and *sda* that cannot be changed.\n      \"\"\"\n\n   @overload\n   def __init__(self, id: int, /, *, scl: Pin, sda: Pin, freq: int = 400_000):\n      \"\"\"\n      Construct and return a new I2C object using the following parameters:\n   \n         - *id* identifies a particular I2C peripheral.  Allowed values for\n           depend on the particular port/board\n         - *scl* should be a pin object specifying the pin to use for SCL.\n         - *sda* should be a pin object specifying the pin to use for SDA.\n         - *freq* should be an integer which sets the maximum frequency\n           for SCL.\n   \n      Note that some ports/boards will have default values of *scl* and *sda*\n      that can be changed in this constructor.  Others will have fixed values\n      of *scl* and *sda* that cannot be changed.\n      \"\"\"\n\n   @overload\n   def init(self, *, freq: int = 400_000) -> None:\n      \"\"\"\n     Initialise the I2C bus with the given arguments:\n   \n        - *scl* is a pin object for the SCL line\n        - *sda* is a pin object for the SDA line\n        - *freq* is the SCL clock rate\n      \"\"\"\n\n   @overload\n   def init(self, *, scl: Pin, sda: Pin, freq: int = 400_000) -> None:\n      \"\"\"\n     Initialise the I2C bus with the given arguments:\n   \n        - *scl* is a pin object for the SCL line\n        - *sda* is a pin object for the SDA line\n        - *freq* is the SCL clock rate\n      \"\"\"\n\n   def scan(self) -> List[int]:\n      \"\"\"\n      Scan all I2C addresses between 0x08 and 0x77 inclusive and return a list of\n      those that respond.  A device responds if it pulls the SDA line low after\n      its address (including a write bit) is sent on the bus.\n      \"\"\"\n\n   def start(self) -> None:\n      \"\"\"\n      Generate a START condition on the bus (SDA transitions to low while SCL is high).\n   \n   \n      Primitive I2C operations\n      ------------------------\n      \n      The following methods implement the primitive I2C master bus operations and can\n      be combined to make any I2C transaction.  They are provided if you need more\n      control over the bus, otherwise the standard methods (see below) can be used.\n      \n      These methods are only available on the `machine.SoftI2C` class.\n      \"\"\"\n\n   def stop(self) -> None:\n      \"\"\"\n      Generate a STOP condition on the bus (SDA transitions to high while SCL is high).\n   \n   \n      Primitive I2C operations\n      ------------------------\n      \n      The following methods implement the primitive I2C master bus operations and can\n      be combined to make any I2C transaction.  They are provided if you need more\n      control over the bus, otherwise the standard methods (see below) can be used.\n      \n      These methods are only available on the `machine.SoftI2C` class.\n      \"\"\"\n\n   def readinto(self, buf: bytes, nack: bool = True, /) -> None:\n      \"\"\"\n      Reads bytes from the bus and stores them into *buf*.  The number of bytes\n      read is the length of *buf*.  An ACK will be sent on the bus after\n      receiving all but the last byte.  After the last byte is received, if *nack*\n      is true then a NACK will be sent, otherwise an ACK will be sent (and in this\n      case the slave assumes more bytes are going to be read in a later call).\n   \n   \n      Primitive I2C operations\n      ------------------------\n      \n      The following methods implement the primitive I2C master bus operations and can\n      be combined to make any I2C transaction.  They are provided if you need more\n      control over the bus, otherwise the standard methods (see below) can be used.\n      \n      These methods are only available on the `machine.SoftI2C` class.\n      \"\"\"\n\n   def write(self, buf: bytes, /) -> int:\n      \"\"\"\n      Write the bytes from *buf* to the bus.  Checks that an ACK is received\n      after each byte and stops transmitting the remaining bytes if a NACK is\n      received.  The function returns the number of ACKs that were received.\n   \n   \n      Primitive I2C operations\n      ------------------------\n      \n      The following methods implement the primitive I2C master bus operations and can\n      be combined to make any I2C transaction.  They are provided if you need more\n      control over the bus, otherwise the standard methods (see below) can be used.\n      \n      These methods are only available on the `machine.SoftI2C` class.\n      \"\"\"\n\n   def readfrom(self, addr: int, nbytes: int, stop: bool = True, /) -> bytes:\n      \"\"\"\n      Read *nbytes* from the slave specified by *addr*.\n      If *stop* is true then a STOP condition is generated at the end of the transfer.\n      Returns a `bytes` object with the data read.\n   \n   \n      Standard bus operations\n      -----------------------\n      \n      The following methods implement the standard I2C master read and write\n      operations that target a given slave device.\n      \"\"\"\n\n   def readfrom_into(self, addr: int, buf: bytes, stop: bool = True, /) -> None:\n      \"\"\"\n      Read into *buf* from the slave specified by *addr*.\n      The number of bytes read will be the length of *buf*.\n      If *stop* is true then a STOP condition is generated at the end of the transfer.\n   \n      The method returns ``None``.\n   \n   \n      Standard bus operations\n      -----------------------\n      \n      The following methods implement the standard I2C master read and write\n      operations that target a given slave device.\n      \"\"\"\n\n   def writeto(self, addr: int, buf: bytes, stop: bool = True, /) -> int:\n      \"\"\"\n      Write the bytes from *buf* to the slave specified by *addr*.  If a\n      NACK is received following the write of a byte from *buf* then the\n      remaining bytes are not sent.  If *stop* is true then a STOP condition is\n      generated at the end of the transfer, even if a NACK is received.\n      The function returns the number of ACKs that were received.\n   \n   \n      Standard bus operations\n      -----------------------\n      \n      The following methods implement the standard I2C master read and write\n      operations that target a given slave device.\n      \"\"\"\n\n   \n   def writevto(\n      self, \n      addr: int, \n      vector: Sequence[bytes], \n      stop: bool = True, \n      /\n   ) -> int:\n      \"\"\"\n      Write the bytes contained in *vector* to the slave specified by *addr*.\n      *vector* should be a tuple or list of objects with the buffer protocol.\n      The *addr* is sent once and then the bytes from each object in *vector*\n      are written out sequentially.  The objects in *vector* may be zero bytes\n      in length in which case they don't contribute to the output.\n   \n      If a NACK is received following the write of a byte from one of the\n      objects in *vector* then the remaining bytes, and any remaining objects,\n      are not sent.  If *stop* is true then a STOP condition is generated at\n      the end of the transfer, even if a NACK is received.  The function\n      returns the number of ACKs that were received.\n   \n   \n      Standard bus operations\n      -----------------------\n      \n      The following methods implement the standard I2C master read and write\n      operations that target a given slave device.\n      \"\"\"\n\n   def readfrom_mem(self, addr: int, memaddr: int, nbytes: int, /, *, addrsize: int = 8) -> bytes:\n      \"\"\"\n      Read *nbytes* from the slave specified by *addr* starting from the memory\n      address specified by *memaddr*.\n      The argument *addrsize* specifies the address size in bits.\n      Returns a `bytes` object with the data read.\n   \n   \n      Memory operations\n      -----------------\n      \n      Some I2C devices act as a memory device (or set of registers) that can be read\n      from and written to.  In this case there are two addresses associated with an\n      I2C transaction: the slave address and the memory address.  The following\n      methods are convenience functions to communicate with such devices.\n      \"\"\"\n\n   \n   def readfrom_mem_into(\n      self, \n      addr: int, \n      memaddr: int, \n      buf: bytes, \n      /, \n      *, \n      addrsize: int = 8\n   ) -> None:\n      \"\"\"\n      Read into *buf* from the slave specified by *addr* starting from the\n      memory address specified by *memaddr*.  The number of bytes read is the\n      length of *buf*.\n      The argument *addrsize* specifies the address size in bits (on ESP8266\n      this argument is not recognised and the address size is always 8 bits).\n   \n      The method returns ``None``.\n   \n   \n      Memory operations\n      -----------------\n      \n      Some I2C devices act as a memory device (or set of registers) that can be read\n      from and written to.  In this case there are two addresses associated with an\n      I2C transaction: the slave address and the memory address.  The following\n      methods are convenience functions to communicate with such devices.\n      \"\"\"\n\n   def writeto_mem(self, addr: int, memaddr: int, buf: bytes, /, *, addrsize: int = 8) -> None:\n      \"\"\"\n      Write *buf* to the slave specified by *addr* starting from the\n      memory address specified by *memaddr*.\n      The argument *addrsize* specifies the address size in bits (on ESP8266\n      this argument is not recognised and the address size is always 8 bits).\n   \n      The method returns ``None``.\n   \n      Memory operations\n      -----------------\n      \n      Some I2C devices act as a memory device (or set of registers) that can be read\n      from and written to.  In this case there are two addresses associated with an\n      I2C transaction: the slave address and the memory address.  The following\n      methods are convenience functions to communicate with such devices.\n      \"\"\"\n\nclass Timer:\n   \"\"\"\n   Hardware timers deal with timing of periods and events. Timers are perhaps\n   the most flexible and heterogeneous kind of hardware in MCUs and SoCs,\n   differently greatly from a model to a model. MicroPython's Timer class\n   defines a baseline operation of executing a callback with a given period\n   (or once after some delay), and allow specific boards to define more\n   non-standard behavior (which thus won't be portable to other boards).\n   \n   See discussion of :ref:`important constraints <machine_callbacks>` on\n   Timer callbacks.\n   \n   .. note::\n   \n       Memory can't be allocated inside irq handlers (an interrupt) and so\n       exceptions raised within a handler don't give much information.  See\n       :func:`micropython.alloc_emergency_exception_buf` for how to get around this\n       limitation.\n   \n   If you are using a WiPy board please refer to :ref:`machine.TimerWiPy <machine.TimerWiPy>`\n   instead of this class.\n   \"\"\"\n\n\n\n   ONE_SHOT: ClassVar[int] = ...\n   \"\"\"\n   Timer operating mode.\n   \"\"\"\n\n\n   PERIODIC: ClassVar[int] = ...\n   \"\"\"\n   Timer operating mode.\n   \"\"\"\n\n   @overload\n   def __init__(\n      self,\n      /\n   ):\n      \"\"\"\n      Construct a new timer object of the given id. Id of -1 constructs a\n      virtual timer (if supported by a board).\n      \n      See ``init`` for parameters of initialisation.\n      \"\"\"\n\n   @overload\n   def __init__(\n      self, \n      id: int, \n      /\n   ):\n      \"\"\"\n      Construct a new timer object of the given id. Id of -1 constructs a\n      virtual timer (if supported by a board).\n      \n      See ``init`` for parameters of initialisation.\n      \"\"\"\n\n   @overload\n   def __init__(\n      self, \n      id: int, \n      /, \n      *, \n      mode: int = PERIODIC, \n      period: int = -1, \n      callback: Optional[Callable[[\"Timer\"], None]] = None, \n   ):\n      \"\"\"\n      Construct a new timer object of the given id. Id of -1 constructs a\n      virtual timer (if supported by a board).\n      \n      See ``init`` for parameters of initialisation.\n      \"\"\"\n\n   def init(\n      self, \n      *, \n      freq: float = None,\n      mode: int = PERIODIC, \n      period: int = -1, \n      callback: Optional[Callable[[\"Timer\"], None]] = None, \n   ) -> None:\n      \"\"\"\n      Initialise the timer. Example::\n   \n          tim.init(period=100)                         # periodic with 100ms period\n          tim.init(mode=Timer.ONE_SHOT, period=1000)   # one shot firing after 1000ms\n   \n      Keyword arguments:\n   \n        - ``mode`` can be one of:\n   \n          - ``Timer.ONE_SHOT`` - The timer runs once until the configured\n            period of the channel expires.\n          - ``Timer.PERIODIC`` - The timer runs periodically at the configured\n            frequency of the channel.\n      \"\"\"\n\n   def deinit(self) -> None:\n      \"\"\"\n      Deinitialises the timer. Stops the timer, and disables the timer peripheral.\n      \"\"\"\n\nclass UART:\n   \"\"\"\n   UART implements the standard UART/USART duplex serial communications protocol.  At\n   the physical level it consists of 2 lines: RX and TX.  The unit of communication\n   is a character (not to be confused with a string character) which can be 8 or 9\n   bits wide.\n   \"\"\"\n\n   def __init__(self, id: int, baudrate: int=9600, bits: int=8, parity: int=None, stop: int=1, tx: Pin=None, rx: Pin=None):\n    \"\"\"\n    Construct a UART object of the given id and initialise the UART \n    bus with the given parameters:\n\n    - *baudrate* is the clock rate.\n    - *bits* is the number of bits per character, 7, 8 or 9.\n    - *parity* is the parity, ``None``, 0 (even) or 1 (odd).\n    - *stop* is the number of stop bits, 1 or 2.\n    - *tx* specifies the TX pin to use.\n    - *rx* specifies the RX pin to use.\n   \"\"\"\n\n   INV_TX = 1\n   INV_RX = 2\n\n   def any(self) -> int:\n      \"\"\"\n      Returns the number of bytes waiting (may be 0).\n      \"\"\"\n\n   @overload\n   def read(self) -> Optional[bytes]:\n      \"\"\"\n      Read characters.  If ``nbytes`` is specified then read at most that many bytes.\n      If ``nbytes`` are available in the buffer, returns immediately, otherwise returns\n      when sufficient characters arrive or the timeout elapses.\n   \n      If ``nbytes`` is not given then the method reads as much data as possible.  It\n      returns after the timeout has elapsed.\n   \n      *Note:* for 9 bit characters each character takes two bytes, ``nbytes`` must\n      be even, and the number of characters is ``nbytes/2``.\n   \n      Return value: a bytes object containing the bytes read in.  Returns ``None``\n      on timeout.\n      \"\"\"\n\n   @overload\n   def read(self, nbytes: int, /) -> Optional[bytes]:\n      \"\"\"\n      Read characters.  If ``nbytes`` is specified then read at most that many bytes.\n      If ``nbytes`` are available in the buffer, returns immediately, otherwise returns\n      when sufficient characters arrive or the timeout elapses.\n   \n      If ``nbytes`` is not given then the method reads as much data as possible.  It\n      returns after the timeout has elapsed.\n   \n      *Note:* for 9 bit characters each character takes two bytes, ``nbytes`` must\n      be even, and the number of characters is ``nbytes/2``.\n   \n      Return value: a bytes object containing the bytes read in.  Returns ``None``\n      on timeout.\n      \"\"\"\n\n   @overload\n   def readinto(self, buf: bytes, /) -> Optional[int]:\n      \"\"\"\n      Read bytes into the ``buf``.  If ``nbytes`` is specified then read at most\n      that many bytes.  Otherwise, read at most ``len(buf)`` bytes.\n   \n      Return value: number of bytes read and stored into ``buf`` or ``None`` on\n      timeout.\n      \"\"\"\n\n   @overload\n   def readinto(self, buf: bytes, nbytes: int, /) -> Optional[int]:\n      \"\"\"\n      Read bytes into the ``buf``.  If ``nbytes`` is specified then read at most\n      that many bytes.  Otherwise, read at most ``len(buf)`` bytes.\n   \n      Return value: number of bytes read and stored into ``buf`` or ``None`` on\n      timeout.\n      \"\"\"\n\n   def readline(self) -> Optional[str]:\n      \"\"\"\n      Read a line, ending in a newline character. If such a line exists, return is\n      immediate. If the timeout elapses, all available data is returned regardless\n      of whether a newline exists.\n   \n      Return value: the line read or ``None`` on timeout if no data is available.\n      \"\"\"\n\n   def write(self, buf: bytes, /) -> Optional[int]:\n      \"\"\"\n      Write the buffer of bytes to the bus.  If characters are 7 or 8 bits wide\n      then each byte is one character.  If characters are 9 bits wide then two\n      bytes are used for each character (little endian), and ``buf`` must contain\n      an even number of bytes.\n   \n      Return value: number of bytes written. If a timeout occurs and no bytes\n      were written returns ``None``.\n      \"\"\"\n\n   def sendbreak(self) -> None:\n      \"\"\"\n      Send a break condition on the bus.  This drives the bus low for a duration\n      of 13 bits.\n      Return value: ``None``.\n      \"\"\"\n\nclass WDT:\n   \"\"\"\n   The WDT is used to restart the system when the application crashes and ends\n   up into a non recoverable state. Once started it cannot be stopped or\n   reconfigured in any way. After enabling, the application must \"feed\" the\n   watchdog periodically to prevent it from expiring and resetting the system.\n   \n   Example usage::\n   \n       from machine import WDT\n       wdt = WDT(timeout=2000)  # enable it with a timeout of 2s\n       wdt.feed()\n   \n   Availability of this class: pyboard, WiPy, esp8266, esp32, rp2.\n   \"\"\"\n\n   def __init__(self, *, id: int = 0, timeout: int = 5000):\n      \"\"\"\n      Create a WDT object and start it. The timeout must be given in milliseconds.\n      Once it is running the timeout cannot be changed and the WDT cannot be stopped either.\n      \"\"\"\n\n   def feed(self) -> None:\n      \"\"\"\n      Feed the WDT to prevent it from resetting the system. The application\n      should place this call in a sensible place ensuring that the WDT is\n      only fed after verifying that everything is functioning correctly.\n      \"\"\"\n\nWDT_RESET = 3\n\ndef bootloader() -> NoReturn:\n   \"\"\"\n   Activate the bootloader.\n   \"\"\"\n\ndef deepsleep(time_ms: int = None) -> None:\n   \"\"\"\n   Stops execution in an attempt to enter a low power state.\n\n   If *time_ms* is specified then this will be the maximum time in milliseconds that\n   the sleep will last for.  Otherwise the sleep can last indefinitely.\n\n   With or without a timeout, execution may resume at any time if there are events\n   that require processing.  Such events, or wake sources, should be configured before\n   sleeping, like ``Pin`` change or ``RTC`` timeout.\n\n   The precise behaviour and power-saving capabilities of deepsleep are\n   highly dependent on the underlying hardware, but the general properties are:\n\n   * A deepsleep may not retain RAM or any other state of the system (for example\n     peripherals or network interfaces).  Upon wake execution is resumed from the main\n     script, similar to a hard or power-on reset. The `reset_cause()` function will\n     return `machine.DEEPSLEEP` and this can be used to distinguish a deepsleep wake\n     from other resets.\n   \"\"\"\n\ndef lightleep(time_ms: int = None) -> None:\n   \"\"\"\n   Stops execution in an attempt to enter a low power state.\n\n   If *time_ms* is specified then this will be the maximum time in milliseconds that\n   the sleep will last for.  Otherwise the sleep can last indefinitely.\n\n   With or without a timeout, execution may resume at any time if there are events\n   that require processing.  Such events, or wake sources, should be configured before\n   sleeping, like ``Pin`` change or ``RTC`` timeout.\n\n   The precise behaviour and power-saving capabilities of lightsleep are\n   highly dependent on the underlying hardware, but the general properties are:\n\n   * A lightsleep has full RAM and state retention.  Upon wake execution is resumed\n     from the point where the sleep was requested, with all subsystems operational.\n   \"\"\"\n\ndef freq():\n   \"\"\"\n   Returns CPU frequency in hertz.\n   \"\"\"\n\ndef disable_irq() -> int:\n   \"\"\"\n   Disable interrupt requests.\n   Returns the previous IRQ state which should be considered an opaque value.\n   This return value should be passed to the ``enable_irq()`` function to restore\n   interrupts to their original state, before ``disable_irq()`` was called.\n   \"\"\"\n\ndef enable_irq(state:int):\n   \"\"\"\n   Re-enable interrupt requests.\n   The *state* parameter should be the value that was returned from the most\n   recent call to the ``disable_irq()`` function.\n   \"\"\"\n\ndef idle():\n   \"\"\"\n   Gates the clock to the CPU, useful to reduce power consumption at any time during\n   short or long periods. Peripherals continue working and execution resumes as soon\n   as any interrupt is triggered (on many ports this includes system timer\n   interrupt occurring at regular intervals on the order of millisecond).\n   \"\"\"\n\nmem16 = None\nmem32 = None\nmem8 = None\n\ndef reset():\n   \"\"\"\n   Resets the device in a manner similar to pushing the external RESET\n   button.\n   \"\"\"\n\ndef reset_cause():\n   \"\"\"\n   Get the reset cause.\n   \"\"\"\n\ndef soft_reset():\n   \"\"\"\n   Performs a soft reset of the interpreter, deleting all Python objects and\n   resetting the Python heap.  It tries to retain the method by which the user\n   is connected to the MicroPython REPL (eg serial, USB, Wifi).\n   \"\"\"\n\ndef time_pulse_us(pin:Pin, pulse_level:int, timeout_us:int=1000000, /) -> int:\n   \"\"\"\n   Time a pulse on the given *pin*, and return the duration of the pulse in\n   microseconds.  The *pulse_level* argument should be 0 to time a low pulse\n   or 1 to time a high pulse.\n\n   If the current input value of the pin is different to *pulse_level*,\n   the function first (*) waits until the pin input becomes equal to *pulse_level*,\n   then (**) times the duration that the pin is equal to *pulse_level*.\n   If the pin is already equal to *pulse_level* then timing starts straight away.\n\n   The function will return -2 if there was timeout waiting for condition marked\n   (*) above, and -1 if there was timeout during the main measurement, marked (**)\n   above. The timeout is the same for both cases and given by *timeout_us* (which\n   is in microseconds).\n   \"\"\"\n\ndef unique_id() -> str:\n   \"\"\"\n   Returns a byte string with a unique identifier of a board/SoC. It will vary\n   from a board/SoC instance to another, if underlying hardware allows. Length\n   varies by hardware (so use substring of a full value if you expect a short\n   ID). In some MicroPython ports, ID corresponds to the network MAC address.\n   \"\"\"",
    "/typeshed/stdlib/math.pyi": "# Stubs for math\n# See: http://docs.python.org/2/library/math.html\n\nfrom typing import Tuple\n\ne = ...  # type: float\npi = ...  # type: float\n\ndef acos(x: float) -> float: \n    \"\"\"\n    Return the arc cosine of ``x``, in radians.\n    \"\"\"\n    ...\n\ndef acosh(x: float) -> float: \n    \"\"\"\n    Return the inverse hyperbolic cosine of ``x``, in radians.\n    \"\"\"\n    ...\n\ndef asin(x: float) -> float: \n    \"\"\"\n    Return the arc sine of ``x``, in radians.\n    \"\"\"\n    ...\n\ndef asinh(x: float) -> float: \n    \"\"\"\n    Return the inverse hyperbolic arc sine of ``x``, in radians.\n    \"\"\"\n    ...\n\ndef atan(x: float) -> float: \n    \"\"\"\n    Return the arc tangent of ``x``, in radians.\n    \"\"\"\n    ...\n\ndef atanh(x: float) -> float: \n    \"\"\"\n    Return the inverse hyperbolic arc tangent of ``x``, in radians.\n    \"\"\"\n    ...\n\ndef atan2(y: float, x: float) -> float: \n    \"\"\"\n    Return ``atan(y / x)``, in radians. The result is between ``-pi`` and ``pi``. The vector in \n    the plane from the origin to point ``(x, y)`` makes this angle with the positive X \n    axis. The point of ``atan2()`` is that the signs of both inputs are known to it, so \n    it can compute the correct quadrant for the angle. For example, ``atan(1)`` and \n    ``atan2(1, 1)`` are both ``pi/4``, but ``atan2(-1, -1)`` is ``-3*pi/4``.\n    \"\"\"\n    ...\n\ndef ceil(x: float) -> int: \n    \"\"\"\n    Return the ceiling of ``x`` as a float, the smallest integer \n    value greater than or equal to ``x``.\n    \"\"\"\n    ...\n\ndef copysign(x: float, y: float) -> float: \n    \"\"\"\n    Return ``x`` with the sign of ``y``. On a platform that supports signed \n    zeros, ``copysign(1.0, -0.0)`` returns ``-1.0``.\n    \"\"\"\n    ...\n\ndef cos(x: float) -> float: \n    \"\"\"\n    Return the cosine of ``x`` radians.\n    \"\"\"\n    ...\n\ndef cosh(x: float) -> float: \n    \"\"\"\n    Return the hyperbolic cosine of ``x`` radians.\n    \"\"\"\n    ...\n\ndef degrees(x: float) -> float: \n    \"\"\"\n    Convert angle ``x`` from radians to degrees.\n    \"\"\"\n    ...\n\ndef erf(x: float) -> float: \n    \"\"\"\n    Return the error function at ``x``.\n    \"\"\"\n    ...\ndef erfc(x: float) -> float: \n    \"\"\"\n    Return the complementary error function at ``x``. The complementary error \n    function is defined as ``1.0 - erf(x)``. It is used for large values of ``x`` where \n    a subtraction from one would cause a loss of significance.\n    \"\"\"\n    ...\n\ndef exp(x: float) -> float: \n    \"\"\"\n    Return ``e**x``.\n    \"\"\"\n    ...\n\ndef expm1(x: float) -> float: \n    \"\"\"\n    Return ``e`` raised to the power ``x``, minus 1. Here e is the base of natural logarithms. \n    For small floats ``x``, the subtraction in ``exp(x) - 1`` can result in a significant loss \n    of precision; the ``expm1()`` function provides a way to compute this quantity to full \n    precision.\n    \"\"\"\n    ...\n\ndef fabs(x: float) -> float: \n    \"\"\"\n    Return the absolute value of ``x``.\n    \"\"\"\n    ...\n\ndef factorial(x: int) -> int: \n    \"\"\"\n    Return ``x`` factorial as an integer. Raises ``ValueError`` if ``x`` is not integral or is negative.\n    \"\"\"\n    ...\n\ndef floor(x: float) -> float: \n    \"\"\"\n    Return the floor of ``x`` as a float, the largest integer value less \n    than or equal to ``x``.\n    \"\"\"\n    ...\n\ndef fmod(x: float, y: float) -> float: \n    \"\"\"\n    Return ``fmod(x, y)``, as defined by the platform C library. Note that the \n    Python expression ``x % y`` may not return the same result. The intent of \n    the C standard is that ``fmod(x, y)`` be exactly (mathematically; to infinite \n    precision) equal to ``x - n*y`` for some integer ``n`` such that the result has \n    the same sign as x and magnitude less than ``abs(y)``. Python\u2019s ``x % y`` returns \n    a result with the sign of ``y`` instead, and may not be exactly computable \n    for float arguments. For example, ``fmod(-1e-100, 1e100)`` is ``-1e-100``, but \n    the result of Python\u2019s ``-1e-100 % 1e100`` is ``1e100-1e-100``, which cannot be \n    represented exactly as a float, and rounds to the surprising ``1e100``. For \n    this reason, function ``fmod()`` is generally preferred when working with \n    floats, while Python\u2019s ``x % y`` is preferred when working with integers.\n    \"\"\"\n    ...\n\ndef frexp(x: float) -> Tuple[float, int]: \n    \"\"\"\n    Return the mantissa and exponent of ``x`` as the pair ``(m, e)``. ``m`` is a float and \n    ``e`` is an integer such that ``x == m * 2**e`` exactly. If ``x`` is zero, returns ``(0.0, 0)``, \n    otherwise ``0.5 <= abs(m) < 1``. This is used to \u201cpick apart\u201d the internal \n    representation of a float in a portable way.\n    \"\"\"\n    ...\n\ndef gamma(x: float) -> float: \n    \"\"\"\n    Return the Gamma function at ``x``.\n    \"\"\"\n    ...\n\ndef isclose(a: float, b: float, *, rel_tol: float = ..., abs_tol: float = ...) -> bool: \n    \"\"\"\n    Return ``True`` if the values ``a`` and ``b`` are close to each other and ``False`` otherwise.\n\n    Whether or not two values are considered close is determined according to given \n    absolute and relative tolerances.\n\n    ``rel_tol`` is the relative tolerance \u2013 it is the maximum allowed difference between \n    ``a`` and ``b``, relative to the larger absolute value of ``a`` or ``b``. For example, to set a \n    tolerance of 5%, pass ``rel_tol=0.05``. The default tolerance is ``1e-09``, which assures \n    that the two values are the same within about 9 decimal digits. ``rel_tol`` must be \n    greater than zero.\n\n    ``abs_tol`` is the minimum absolute tolerance \u2013 useful for comparisons near zero. \n    ``abs_tol`` must be at least zero.\n\n    If no errors occur, the result will be: ``abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)``.\n\n    The IEEE 754 special values of ``NaN``, ``inf``, and ``-inf`` will be handled according to IEEE rules. \n    Specifically, ``NaN`` is not considered close to any other value, including ``NaN``. ``inf`` and\n    ``-inf`` are only considered close to themselves.\n    \"\"\"\n    ...\n\ndef isfinite(x: float) -> bool: \n    \"\"\"\n    Check if the float ``x`` is finite.\n    \"\"\"\n    ...\n\ndef isinf(x: float) -> bool: \n    \"\"\"\n    Check if the float ``x`` is positive or negative infinity.\n    \"\"\"\n    ...\n\ndef isnan(x: float) -> bool: \n    \"\"\"\n    Check if the float ``x`` is a NaN (not a number). For more information on \n    NaNs, see the IEEE 754 standards.\n    \"\"\"\n    ...\n\ndef ldexp(x: float, i: int) -> float: \n    \"\"\"\n    Return ``x * (2**i)``. This is essentially the inverse of function ``frexp()``.\n    \"\"\"\n    ...\n\ndef lgamma(x: float) -> float: \n    \"\"\"\n    Return the natural logarithm of the absolute value of the Gamma function at ``x``.\n    \"\"\"\n    ...\n\ndef log(x: float, base: float = ...) -> float: \n    \"\"\"\n    With one argument, return the natural logarithm of ``x`` (to base ``e``).\n\n    With two arguments, return the logarithm of ``x`` to the given base, \n    calculated as ``log(x)/log(base)``.\n    \"\"\"\n    ...\n\ndef log2(__x: float) -> float: \n    \"\"\"\n    Return the base-2 logarithm of ``x``. This is usually more accurate than ``log(x, 2)``.\n    \"\"\"\n    ...\n\ndef log10(__x: float) -> float: \n    \"\"\"\n    Return the base-10 logarithm of ``x``. This is usually more accurate than ``log(x, 10)``.\n    \"\"\"\n    ...\n\ndef modf(x: float) -> Tuple[float, float]: \n    \"\"\"\n    Return the fractional and integer parts of ``x``. Both results carry the sign \n    of ``x`` and are floats.\n    \"\"\"\n    ...\n\ndef pow(x: float, y: float) -> float: \n    \"\"\"\n    Return ``x`` raised to the power ``y``. Exceptional cases follow Annex \u2018F\u2019 of \n    the C99 standard as far as possible. In particular, ``pow(1.0, x)`` and \n    ``pow(x, 0.0)`` always return ``1.0``, even when ``x`` is a zero or a NaN. If \n    both ``x`` and ``y`` are finite, ``x`` is negative, and ``y`` is not an integer then \n    ``pow(x, y)`` is undefined, and raises ``ValueError``.\n\n    Unlike the built-in ``**`` operator, ``math.pow()`` converts both its arguments to \n    type float. Use ``**`` or the built-in ``pow()`` function for computing exact integer \n    powers.\n    \"\"\"\n    ...\n\ndef radians(x: float) -> float: \n    \"\"\"\n    Convert angle ``x`` from degrees to radians.\n    \"\"\"\n    ...\n\ndef sin(x: float) -> float: \n    \"\"\"\n    Return the sine of ``x`` in radians.\n    \"\"\"\n    ...\n\ndef sinh(x: float) -> float: \n    \"\"\"\n    Return the inverse hyperbolic sine of ``x`` in radians.\n    \"\"\"\n    ...\n\ndef sqrt(x: float) -> float: \n    \"\"\"\n    Return the square root of ``x``.\n    \"\"\"\n    ...\n\ndef tan(x: float) -> float: \n    \"\"\"\n    Return the tangent of ``x`` in radians.\n    \"\"\"\n    ...\n\ndef tanh(x: float) -> float: \n    \"\"\"\n    Return the inverse hyperbolic tangent of ``x`` in radians.\n    \"\"\"\n    ...\n\ndef trunc(x: float) -> int:\n    \"\"\" \n    Return the ``Real`` value ``x`` truncated to an Integral (usually a long \n    integer). Uses the ``__trunc__`` method.\n    \"\"\"\n    ...",
    "/typeshed/stdlib/micropython.pyi": "\"\"\"Access and control MicroPython internals.\"\"\"\n\nfrom typing import Any, overload, Callable, TypeVar\n\n\n_T = TypeVar('_T')\n\n\ndef const(expr: Any) -> Any:\n    \"\"\"Used to declare that the expression is a constant so that the compile can\n    optimise it.  The use of this function should be as follows::\n\n    from micropython import const\n\n    CONST_X = const(123)\n    CONST_Y = const(2 * CONST_X + 1)\n\n    Constants declared this way are still accessible as global variables from\n    outside the module they are declared in.  On the other hand, if a constant\n    begins with an underscore then it is hidden, it is not available as a global\n    variable, and does not take up any memory during execution.\n\n    This `const` function is recognised directly by the MicroPython parser and is\n    provided as part of the :mod:`micropython` module mainly so that scripts can be\n    written which run under both CPython and MicroPython, by following the above\n    pattern.\n    \"\"\"\n    ...\n\n\n@overload\ndef opt_level() -> int:\n    \"\"\"If *level* is given then this function sets the optimisation level for subsequent\n    compilation of scripts, and returns ``None``.  Otherwise it returns the current\n    optimisation level.\n    \"\"\"\n    ...\n\n\n@overload\ndef opt_level(level: int) -> None:\n    ...\n\n\ndef alloc_emergency_exception_buf(size: int) -> None:\n    \"\"\"Allocate *size* bytes of RAM for the emergency exception buffer (a good\n    size is around 100 bytes).  The buffer is used to create exceptions in cases\n    when normal RAM allocation would fail (eg within an interrupt handler) and\n    therefore give useful traceback information in these situations.\n\n    A good way to use this function is to put it at the start of your main script\n    (eg ``boot.py`` or ``main.py``) and then the emergency exception buffer will be active\n    for all the code following it.\n    \"\"\"\n    ...\n\n\n@overload\ndef mem_info() -> None:\n    \"\"\"Print information about currently used memory.  If the *verbose* argument\n    is given then extra information is printed.\n\n    The information that is printed is implementation dependent, but currently\n    includes the amount of stack and heap used.  In verbose mode it prints out\n    the entire heap indicating which blocks are used and which are free.\n    \"\"\"\n    ...\n\n\n@overload\ndef mem_info(verbose: Any) -> None:\n    ...\n\n\n@overload\ndef qstr_info() -> None:\n    \"\"\"Print information about currently interned strings.  If the *verbose*\n    argument is given then extra information is printed.\n\n    The information that is printed is implementation dependent, but currently\n    includes the number of interned strings and the amount of RAM they use.  In\n    verbose mode it prints out the names of all RAM-interned strings.\n    \"\"\"\n    ...\n\n\n@overload\ndef qstr_info(verbose) -> None:\n    ...\n\n\ndef stack_use() -> int:\n    \"\"\"Return an integer representing the current amount of stack that is being\n    used.  The absolute value of this is not particularly useful, rather it\n    should be used to compute differences in stack usage at different points.\n    \"\"\"\n    ...\n\n\ndef heap_lock() -> None:\n    \"\"\"Lock the heap.  When locked no memory allocation can occur and a\n    `MemoryError` will be raised if any heap allocation is attempted.\n\n    These functions can be nested, ie `heap_lock()` can be called multiple times\n    in a row and the lock-depth will increase, and then `heap_unlock()` must be\n    called the same number of times to make the heap available again.\n    \"\"\"\n    ...\n\n\n\ndef heap_unlock() -> None:\n    \"\"\"Unlock the heap.  When locked no memory allocation can occur and a\n    `MemoryError` will be raised if any heap allocation is attempted.\n\n    These functions can be nested, ie `heap_lock()` can be called multiple times\n    in a row and the lock-depth will increase, and then `heap_unlock()` must be\n    called the same number of times to make the heap available again.\n    \"\"\"\n    ...\n\n\n\ndef kbd_intr(chr: int) -> None:\n    \"\"\"Set the character that will raise a `KeyboardInterrupt` exception.  By\n    default this is set to 3 during script execution, corresponding to Ctrl-C.\n    Passing -1 to this function will disable capture of Ctrl-C, and passing 3\n    will restore it.\n\n    This function can be used to prevent the capturing of Ctrl-C on the\n    incoming stream of characters that is usually used for the REPL, in case\n    that stream is used for other purposes.\n    \"\"\"\n    ...\n\n\ndef schedule(func: Callable[[_T], Any], arg: _T) -> None:\n    \"\"\"Schedule the function *func* to be executed \"very soon\".  The function\n    is passed the value *arg* as its single argument.  \"Very soon\" means that\n    the MicroPython runtime will do its best to execute the function at the\n    earliest possible time, given that it is also trying to be efficient, and\n    that the following conditions hold:\n\n    - A scheduled function will never preempt another scheduled function.\n    - Scheduled functions are always executed \"between opcodes\" which means\n      that all fundamental Python operations (such as appending to a list)\n      are guaranteed to be atomic.\n    - A given port may define \"critical regions\" within which scheduled\n      functions will never be executed.  Functions may be scheduled within\n      a critical region but they will not be executed until that region\n      is exited.  An example of a critical region is a preempting interrupt\n      handler (an IRQ).\n\n    A use for this function is to schedule a callback from a preempting IRQ.\n    Such an IRQ puts restrictions on the code that runs in the IRQ (for example\n    the heap may be locked) and scheduling a function to call later will lift\n    those restrictions.\n\n    Note: If `schedule()` is called from a preempting IRQ, when memory\n    allocation is not allowed and the callback to be passed to `schedule()` is\n    a bound method, passing this directly will fail. This is because creating a\n    reference to a bound method causes memory allocation. A solution is to\n    create a reference to the method in the class constructor and to pass that\n    reference to `schedule()`. This is discussed in detail here\n    :ref:`reference documentation <isr_rules>` under \"Creation of Python\n    objects\".\n\n    There is a finite stack to hold the scheduled functions and `schedule()`\n    will raise a `RuntimeError` if the stack is full.\n    \"\"\"\n    ...",
    "/typeshed/stdlib/music.pyi": "\n\n\n\"\"\"\nMicroPython on the BBC micro:bit comes with a powerful music and\nsound module. It\u2019s very easy to generate bleeps and bloops from\nthe device if you attach a speaker. Use crocodile clips to attach\npin 0 and GND to the positive and negative inputs on the speaker -\nit doesn\u2019t matter which way round they are connected to the speaker.\n\nMusical Notation\n\n    An individual note is specified thus:\n\n    NOTE[octave][:duration]\n\n    For example, A1:4 refers to the note \u201cA\u201d in octave 1 that lasts for four ticks\n     (a tick is an arbitrary length of time defined by a tempo setting function -\n     see below). If the note name R is used then it is treated as a rest (silence).\n\n    Accidentals (flats and sharps) are denoted by the b\n    (flat - a lower case b) and # (sharp - a hash symbol).\n    For example, Ab is A-flat and C# is C-sharp.\n\n    Note names are case-insensitive.\n\n    The octave and duration parameters are states that carry over to\n    subsequent notes until re-specified. The default states are octave = 4\n    (containing middle C) and duration = 4 (a crotchet, given the default\n    tempo settings - see below).\n\n    For example, if 4 ticks is a crotchet, the following list is crotchet,\n    quaver, quaver, crotchet based arpeggio:\n\n    ['c1:4', 'e:2', 'g', 'c2:4']\n\n    The opening of Beethoven\u2019s 5th Symphony would be encoded thus:\n\n    ['r4:2', 'g', 'g', 'g', 'eb:8', 'r:2', 'f', 'f', 'f', 'd:8']\n\n    The definition and scope of an octave conforms to the table\n    listed on this page about scientific pitch notation. For example, middle \u201cC\u201d is\n    c4' and concert \u201cA\u201d (440) is 'a4'. Octaves start on the note \u201cC\u201d.\n    The definition and scope of an octave conforms to the table\n    listed on this page about scientific pitch notation. For example, middle\n    \u201cC\u201d is 'c4' and concert \u201cA\u201d (440) is 'a4'. Octaves start on the note \u201cC\u201d.\n\n\n        Built in Melodies\n\n        For the purposes of education and entertainment, the module contains\n        several example tunes that are expressed as Python lists. They can be used like this:\n\n     import music\n     music.play(music.NYAN)\n\n\n    All the tunes are either out of copyright, composed by\n    Nicholas H.Tollervey and\n    released to the public domain or have an unknown composer and are\n    covered by a fair (educational) use provision.\n\n    They are:\n\n    DADADADUM - the opening to Beethoven\u2019s 5th Symphony in C minor.\n    ENTERTAINER - the opening fragment of Scott Joplin\u2019s\n                  Ragtime classic \u201cThe Entertainer\u201d.\n    PRELUDE - the opening of the first Prelude in C Major of\n              J.S.Bach\u2019s 48 Preludes and Fugues.\n    ODE - the \u201cOde to Joy\u201d theme from Beethoven\u2019s 9th Symphony in D minor.\n    NYAN - the Nyan Cat theme (http://www.nyan.cat/). The composer is unknown.\n           This is fair use for educational porpoises (as they say in New York).\n    RINGTONE - something that sounds like a mobile phone ringtone. To be used\n               to indicate an incoming message.\n    FUNK - a funky bass line for secret agents and criminal masterminds.\n    BLUES - a boogie-woogie 12-bar blues walking bass.\n    BIRTHDAY - \u201cHappy Birthday to You...\u201d for copyright status see:\n                http://www.bbc.co.uk/news/world-us-canada-34332853\n    WEDDING - the bridal chorus from Wagner\u2019s opera \u201cLohengrin\u201d.\n    FUNERAL - the \u201cfuneral march\u201d otherwise known as Fr\u00e9d\u00e9ric Chopin\u2019s\n            Piano Sonata No. 2 in B\u266d minor, Op. 35.\n    PUNCHLINE - a fun fragment that signifies a joke has been made.\n    PYTHON - John Philip Sousa\u2019s march \u201cLiberty Bell\u201d aka, the theme for\n             \u201cMonty Python\u2019s Flying Circus\u201d (after which the Python\n            programming language is named).\n    BADDY - silent movie era entrance of a baddy.\n    CHASE - silent movie era chase scene.\n    BA_DING - a short signal to indicate something has happened.\n    WAWAWAWAA - a very sad trombone.\n    JUMP_UP - for use in a game, indicating upward movement.\n    JUMP_DOWN - for use in a game, indicating downward movement.\n    POWER_UP - a fanfare to indicate an achievement unlocked.\n    POWER_DOWN - a sad fanfare to indicate an achievement lost.\n\n    Example\n\n        Plays a simple tune using the Micropython music module.\n        This example requires a speaker/buzzer/headphones connected to P0 and GND.\n\n    from microbit import *\n    import music\n\n    # play Prelude in C.\n    notes = [\n        'c4:1', 'e', 'g', 'c5', 'e5', 'g4', 'c5', 'e5', 'c4', 'e', 'g', 'c5', 'e5', 'g4', 'c5', 'e5',\n        'c4', 'd', 'g', 'd5', 'f5', 'g4', 'd5', 'f5', 'c4', 'd', 'g', 'd5', 'f5', 'g4', 'd5', 'f5',\n        'b3', 'd4', 'g', 'd5', 'f5', 'g4', 'd5', 'f5', 'b3', 'd4', 'g', 'd5', 'f5', 'g4', 'd5', 'f5',\n        'c4', 'e', 'g', 'c5', 'e5', 'g4', 'c5', 'e5', 'c4', 'e', 'g', 'c5', 'e5', 'g4', 'c5', 'e5',\n        'c4', 'e', 'a', 'e5', 'a5', 'a4', 'e5', 'a5', 'c4', 'e', 'a', 'e5', 'a5', 'a4', 'e5', 'a5',\n        'c4', 'd', 'f#', 'a', 'd5', 'f#4', 'a', 'd5', 'c4', 'd', 'f#', 'a', 'd5', 'f#4', 'a', 'd5',\n        'b3', 'd4', 'g', 'd5', 'g5', 'g4', 'd5', 'g5', 'b3', 'd4', 'g', 'd5', 'g5', 'g4', 'd5', 'g5',\n        'b3', 'c4', 'e', 'g', 'c5', 'e4', 'g', 'c5', 'b3', 'c4', 'e', 'g', 'c5', 'e4', 'g', 'c5',\n        'b3', 'c4', 'e', 'g', 'c5', 'e4', 'g', 'c5', 'b3', 'c4', 'e', 'g', 'c5', 'e4', 'g', 'c5',\n        'a3', 'c4', 'e', 'g', 'c5', 'e4', 'g', 'c5', 'a3', 'c4', 'e', 'g', 'c5', 'e4', 'g', 'c5',\n        'd3', 'a', 'd4', 'f#', 'c5', 'd4', 'f#', 'c5', 'd3', 'a', 'd4', 'f#', 'c5', 'd4', 'f#', 'c5',\n        'g3', 'b', 'd4', 'g', 'b', 'd', 'g', 'b', 'g3', 'b3', 'd4', 'g', 'b', 'd', 'g', 'b'\n    ]\n\n    music.play(notes)\n    \"\"\"\nfrom typing import Tuple, Union, List\n\nfrom . microbit import pin0, MicroBitAnalogDigitalPin\n\nDADADADUM = 0\nENTERTAINER = 1\nPRELUDE = 2\nODE = 3\nNYAN = 4\nRINGTONE = 5\nFUNK = 6\nBLUES = 7\nBIRTHDAY = 8\nWEDDING = 9\nFUNERAL = 10\nPUNCHLINE = 11\nPYTHON = 12\nBADDY = 12\nCHASE = 13\nBA_DING = 14\nWAWAWAWAA = 15\nJUMP_UP = 16\nJUMP_DOWN = 17\nPOWER_UP = 18\nPOWER_DOWN = 19\n\n\ndef set_tempo(ticks: int = 4, bpm: int = 120) -> None:\n    \"\"\"\n    Sets the approximate tempo for playback.\n\n    A number of ticks (expressed as an integer) constitute a beat.\n    Each beat is to be played at a certain frequency per minute\n    (expressed as the more familiar BPM - beats per minute -\n     also as an integer).\n\n    Suggested default values allow the following useful behaviour:\n\n        music.set_tempo() - reset the tempo to default of ticks = 4, bpm = 120\n        music.set_tempo(ticks=8) - change the \u201cdefinition\u201d of a beat\n        music.set_tempo(bpm=180) - just change the tempo\n\n    To work out the length of a tick in milliseconds is very simple arithmetic:\n    60000/bpm/ticks_per_beat . For the default values that\u2019s\n    60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.\n    \"\"\"\n\n\ndef get_tempo(self) -> Tuple[int, int]:\n    \"\"\"\n    Gets the current tempo as a tuple of integers: (ticks, bpm).\n    \"\"\"\n\n\ndef play(music: Union[str, List[str]],\n         pin: MicroBitAnalogDigitalPin = pin0, wait: bool=True, loop: bool=False) -> None:\n    \"\"\"\n    Sets the approximate tempo for playback.\n\n    A number of ticks (expressed as an integer) constitute a beat.\n    Each beat is to be played at a certain frequency per\n    minute (expressed as the more familiar BPM - beats per minute -\n    also as an integer).\n\n    Suggested default values allow the following useful behaviour:\n\n        music.set_tempo() - reset the tempo to default of ticks = 4, bpm = 120\n        music.set_tempo(ticks=8) - change the \u201cdefinition\u201d of a beat\n        music.set_tempo(bpm=180) - just change the tempo\n\n    To work out the length of a tick in milliseconds is very simple arithmetic:\n    60000/bpm/ticks_per_beat . For the default values that\u2019s 60000/120/4 =\n    125 milliseconds or 1 beat = 500 milliseconds.\n    \"\"\"\n\n\ndef pitch(frequency: int, len=-1, pin: MicroBitAnalogDigitalPin = pin0,\n          wait: bool=True) -> None:\n    \"\"\"\n\n    Plays a pitch at the integer frequency given for the specified\n    number of milliseconds. For example, if the frequency is set to 440 and\n    the length to 1000 then we hear a standard concert A for one second.\n\n    If wait is set to True, this function is blocking.\n\n    If len is negative the pitch is played continuously until\n    either the blocking call is interrupted or, in the case of a background call,\n    a new frequency is set or stop is called (see below).\n    \"\"\"\n\n\ndef stop(pin: MicroBitAnalogDigitalPin = pin0) -> None:\n    \"\"\"\n    Stops all music playback on a given pin.\n    \"\"\"\n\n\ndef reset() -> None:\n    \"\"\"\n    Resets the state of the following attributes in the following way:\n\n            ticks = 4\n            bpm = 120\n            duration = 4\n            octave = 4\n    \"\"\"\n",
    "/typeshed/stdlib/neopixel.pyi": "\"\"\"\nThe neopixel module lets you use Neopixel (WS2812) individually\naddressable RGB LED strips with the Microbit.\n\nNote to use the neopixel module, you need to import it separately with:\n\nimport neopixel\n\nNote\n\nFrom our tests, the Microbit Neopixel module can drive up to around 256\nNeopixels. Anything above that and you may experience weird bugs and issues.\n\nNeoPixels are fun strips of multi-coloured programmable LEDs.\nThis module contains everything to plug them into a micro:bit\nand create funky displays, art and games\n\n\n\nWarning\n\nDo not use the 3v connector on the Microbit to power any more than\n8 Neopixels at a time.\n\nIf you wish to use more than 8 Neopixels, you must use a separate\n3v-5v power supply for the Neopixel power pin.\n\n\nOperations\n\nWriting the colour doesn\u2019t update the display (use show() for that).\n\nnp[0] = (255, 0, 128)  # first element\nnp[-1] = (0, 255, 0)  # last element\nnp.show()  # only now will the updated value be shown\n\nTo read the colour of a specific pixel just reference it.\n\nprint(np[0])\n\nUsing Neopixels\n\nInteract with Neopixels as if they were a list of tuples.\nEach tuple represents the RGB (red, green and blue) mix of colours\nfor a specific pixel. The RGB values can range between 0 to 255.\n\nFor example, initialise a strip of 8 neopixels on a strip connected\nto pin0 like this:\n\nimport neopixel\nnp = neopixel.NeoPixel(pin0, 8)\n\nSet pixels by indexing them (like with a Python list). For instance,\nto set the first pixel to full brightness red, you would use:\n\nnp[0] = (255, 0, 0)\n\nOr the final pixel to purple:\n\nnp[-1] = (255, 0, 255)\n\nGet the current colour value of a pixel by indexing it. For example,\nto print the first pixel\u2019s RGB value use:\n\nprint(np[0])\n\nFinally, to push the new colour data to your Neopixel strip, use the .show() function:\n\nnp.show()\n\nIf nothing is happening, it\u2019s probably because you\u2019ve forgotten this final step..!\n\nNote\n\nIf you\u2019re not seeing anything change on your Neopixel strip,\nmake sure you have show() at least somewhere otherwise your updates won\u2019t be shown.\n\n\n\"\"\"\nfrom . microbit import MicroBitAnalogDigitalPin\n\ndef NeoPixel(pin: MicroBitAnalogDigitalPin, n: int)-> None:\n    \"\"\"\n    Initialise a new strip of n number of neopixel LEDs controlled via pin pin.\n    Each pixel is addressed by a position (starting from 0).\n\n    Neopixels are given RGB (red, green, blue) values between 0-255 as a tuple.\n    For example, (255,255,255) is white.\n    \"\"\"\n\ndef clear()->None:\n    \"\"\"\n    Clear all the pixels.\n    \"\"\"\n\ndef show()->None:\n    \"\"\"\n    Show the pixels. Must be called for any updates to become visible.\n    \"\"\"",
    "/typeshed/stdlib/os.pyi": "from uos import *",
    "/typeshed/stdlib/radio.pyi": "\"\"\"The ``radio`` module allows devices to work together via simple wireless\nnetworks.\n\nThe radio module is conceptually very simple:\n\n* Broadcast messages are of a certain configurable length (up to 251 bytes).\n* Messages received are read from a queue of configurable size (the larger the queue the more RAM is used). If the queue is full, new messages are ignored.\n* Messages are broadcast and received on a preselected channel (numbered 0-100).\n* Broadcasts are at a certain level of power - more power means more range.\n* Messages are filtered by address (like a house number) and group (like a named recipient at the specified address).\n* The rate of throughput can be one of three pre-determined settings.\n* Send and receieve bytes to work with arbitrary data.\n* As a convenience for children, it's easy to send and receive messages as strings.\n* The default configuration is both sensible and compatible with other platforms that target the BBC micro:bit.\n\nTo access this module you need to::\n\n    import radio\n\nWe assume you have done this for the examples below.\n\"\"\"\n\n\nfrom typing import Optional\n\n\nRATE_250KBIT: int\n\"\"\"Constant used to indicate a throughput of 256 Kbit a second.\"\"\"\n\nRATE_1MBIT: int\n\"\"\"Constant used to indicate a throughput of 1 MBit a second.\"\"\"\n\nRATE_2MBIT: int\n\"\"\"Constant used to indicate a throughput of 2 MBit a second.\"\"\"\n\n\ndef on() -> None:\n    \"\"\"Turns the radio on. This needs to be explicitly called since the radio\n    draws power and takes up memory that you may otherwise need.\n    \"\"\"\n\n\ndef off() -> None:\n    \"\"\"Turns off the radio, thus saving power and memory.\"\"\"\n\n\ndef config(length: int = 32, queue: int = 3, channel: int = 7,\n           power: int = 6, address: int = 0x75626974, group: int = 0,\n           data_rate: int = RATE_1MBIT) -> None:\n    \"\"\"Configures various keyword based settings relating to the radio. The\n    available settings and their sensible default values are listed below.\n\n    The ``length`` (default=32) defines the maximum length, in bytes, of a\n    message sent via the radio. It can be up to 251 bytes long (254 - 3 bytes\n    for S0, LENGTH and S1 preamble).\n\n    The ``queue`` (default=3) specifies the number of messages that can be\n    stored on the incoming message queue. If there are no spaces left on the\n    queue for incoming messages, then the incoming message is dropped.\n\n    The ``channel`` (default=7) can be an integer value from 0 to 100\n    (inclusive) that defines an arbitrary \"channel\" to which the radio is\n    tuned. Messages will be sent via this channel and only messages received\n    via this channel will be put onto the incoming message queue. Each step is\n    1MHz wide, based at 2400MHz.\n\n    The ``power`` (default=6) is an integer value from 0 to 7 (inclusive) to\n    indicate the strength of signal used when broadcasting a message. The\n    higher the value the stronger the signal, but the more power is consumed\n    by the device. The numbering translates to positions in the following list\n    of dBm (decibel milliwatt) values: -30, -20, -16, -12, -8, -4, 0, 4.\n\n    The ``address`` (default=0x75626974) is an arbitrary name, expressed as a\n    32-bit address, that's used to filter incoming packets at the hardware\n    level, keeping only those that match the address you set. The default used\n    by other micro:bit related platforms is the default setting used here.\n\n    The ``group`` (default=0) is an 8-bit value (0-255) used with the\n    ``address`` when filtering messages. Conceptually, \"address\" is like a\n    house/office address and \"group\" is like the person at that address to\n    which you want to send your message.\n\n    The ``data_rate`` (default=radio.RATE_1MBIT) indicates the speed at which\n    data throughput takes place. Can be one of the following contants defined\n    in the ``radio`` module : ``RATE_250KBIT``, ``RATE_1MBIT`` or\n    ``RATE_2MBIT``.\n\n    If ``config`` is not called then the defaults described above are assumed.\n    \"\"\"\n\n\ndef reset() -> None:\n    \"\"\"Reset the settings to their default values (as listed in the documentation\n    for the ``config`` function above).\n    \"\"\"\n\n\ndef send_bytes(message: bytes) -> None:\n    \"\"\"Sends a message containing bytes.\"\"\"\n\n\ndef receive_bytes() -> Optional[bytes]:\n    \"\"\"Receive the next incoming message on the message queue. Returns ``None`` if\n    there are no pending messages. Messages are returned as bytes.\n    \"\"\"\n\n\ndef receive_bytes_into(buffer: bytearray) -> Optional[int]:\n    \"\"\"Receive the next incoming message on the message queue. Copies the message\n    into ``buffer``, trimming the end of the message if necessary.\n    Returns ``None`` if there are no pending messages, otherwise it returns the length\n    of the message (which might be more than the length of the buffer).\n    \"\"\"\n\n\ndef send(message: str) -> None:\n    \"\"\"Sends a message string. This is the equivalent of\n    ``send_bytes(bytes(message, 'utf8'))`` but with ``b'\\x01\\x00\\x01'``\n    prepended to the front (to make it compatible with other platforms that\n    target the micro:bit).\n    \"\"\"\n\n\ndef receive() -> Optional[str]:\n    \"\"\"Works in exactly the same way as ``receive_bytes`` but returns\n    whatever was sent.\n\n    Currently, it's equivalent to ``str(receive_bytes(), 'utf8')`` but with a\n    check that the the first three bytes are ``b'\\x01\\x00\\x01'`` (to make it\n    compatible with other platforms that may target the micro:bit). It strips\n    the prepended bytes before converting to a string.\n\n    A ``ValueError`` exception is raised if conversion to string fails.\n    \"\"\"\n\n",
    "/typeshed/stdlib/random.pyi": "from urandom import *",
    "/typeshed/stdlib/speech.pyi": "\"\"\"\nSpeech\n\nWarning\n\nWARNING! THIS IS ALPHA CODE.\n\nWe reserve the right to change this API as development continues.\n\nThe quality of the speech is not great, merely \u201cgood enough\u201d.\nGiven the constraints of the device you may encounter memory errors\nand / or unexpected extra sounds during playback. It\u2019s early days\nand we\u2019re improving the code for the speech synthesiser all the time.\n Bug reports and pull requests are most welcome.\n\nThis module makes microbit talk, sing and make other\nspeech like sounds provided that you connect a speaker to your board.\n\n\n\nNote\n\nThis work is based upon the amazing reverse engineering efforts of\nSebastian Macke based upon an old text-to-speech (TTS) program called\nSAM (Software Automated Mouth) originally released in 1982 for the\nCommodore 64. The result is a small C library that we have\nadopted and adapted for the micro:bit. You can find out more from his homepage.\nMuch of the information in this document was gleaned from the\noriginal user\u2019s manual which can be found here.\n\nThe speech synthesiser can produce around 2.5 seconds\nworth of sound from up to 255 characters of textual input.\n\nTo access this module you need to:\n\nimport speech\n\nSee http://microbit-micropython.readthedocs.io/en/latest/speech.html\nfor details\n\"\"\"\n\ndef translate(words: str) ->None:\n    \"\"\"\n    Given English words in the string words, return a string\n    containing a best guess at the appropriate phonemes to pronounce.\n    The output is generated from this text to phoneme translation table.\n\n    This function should be used to generate a first approximation of phonemes\n    that can be further hand-edited to improve accuracy, inflection and emphasis.\n    \"\"\"\n\ndef pronounce(phonemes: str, pitch: int=64, speed: int=72,\n              mouth: int=128, throat: int=128)->None:\n    \"\"\"\n    Pronounce the phonemes in the string phonemes. See below for details of how\n    to use phonemes to finely control the output of the speech synthesiser.\n    Override the optional pitch, speed, mouth and throat settings to change\n    the timbre (quality) of the voice.\n    \"\"\"\n\ndef say(words: str, pitch: int=64, speed: int=72,\n              mouth: int=128, throat: int=128)->None:\n    \"\"\"\n    Say the English words in the string words. The result is semi-accurate\n    for English.\n    Override the optional pitch, speed, mouth and throat settings to change\n    the timbre (quality) of the voice. This is a short-hand equivalent of:\n    speech.pronounce(speech.translate(words))\n    \"\"\"\n\ndef sing(phonemes: str, pitch: int=64, speed: int=72,\n              mouth: int=128, throat: int=128)->None:\n    \"\"\"\n    Sing the phonemes contained in the string phonemes. Changing the pitch\n    and duration of the note is described below. Override the optional pitch,\n    speed, mouth and throat settings to change the timbre (quality) of the voice.\n    \"\"\"",
    "/typeshed/stdlib/struct.pyi": "from ustruct import *",
    "/typeshed/stdlib/sys.pyi": "from usys import *",
    "/typeshed/stdlib/time.pyi": "from utime import *",
    "/typeshed/stdlib/types.pyi": "import sys\nimport typing\nfrom importlib.abc import _LoaderProtocol\nfrom importlib.machinery import ModuleSpec\nfrom typing import (\n    Any,\n    AsyncGenerator,\n    Awaitable,\n    Callable,\n    Dict,\n    Generator,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    Optional,\n    Tuple,\n    Type,\n    TypeVar,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, final\n\n# Note, all classes \"defined\" here require special handling.\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_V_co = TypeVar(\"_V_co\", covariant=True)\n\nclass _Cell:\n    cell_contents: Any\n\nclass FunctionType:\n    __closure__: Tuple[_Cell, ...] | None\n    __code__: CodeType\n    __defaults__: Tuple[Any, ...] | None\n    __dict__: Dict[str, Any]\n    __globals__: Dict[str, Any]\n    __name__: str\n    __qualname__: str\n    __annotations__: Dict[str, Any]\n    __kwdefaults__: Dict[str, Any]\n    def __init__(\n        self,\n        code: CodeType,\n        globals: Dict[str, Any],\n        name: str | None = ...,\n        argdefs: Tuple[object, ...] | None = ...,\n        closure: Tuple[_Cell, ...] | None = ...,\n    ) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, obj: object | None, type: type | None) -> MethodType: ...\n\nLambdaType = FunctionType\n\nclass CodeType:\n    \"\"\"Create a code object.  Not for the faint of heart.\"\"\"\n\n    co_argcount: int\n    if sys.version_info >= (3, 8):\n        co_posonlyargcount: int\n    co_kwonlyargcount: int\n    co_nlocals: int\n    co_stacksize: int\n    co_flags: int\n    co_code: bytes\n    co_consts: Tuple[Any, ...]\n    co_names: Tuple[str, ...]\n    co_varnames: Tuple[str, ...]\n    co_filename: str\n    co_name: str\n    co_firstlineno: int\n    co_lnotab: bytes\n    co_freevars: Tuple[str, ...]\n    co_cellvars: Tuple[str, ...]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            argcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def replace(\n            self,\n            *,\n            co_argcount: int = ...,\n            co_posonlyargcount: int = ...,\n            co_kwonlyargcount: int = ...,\n            co_nlocals: int = ...,\n            co_stacksize: int = ...,\n            co_flags: int = ...,\n            co_firstlineno: int = ...,\n            co_code: bytes = ...,\n            co_consts: Tuple[Any, ...] = ...,\n            co_names: Tuple[str, ...] = ...,\n            co_varnames: Tuple[str, ...] = ...,\n            co_freevars: Tuple[str, ...] = ...,\n            co_cellvars: Tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_lnotab: bytes = ...,\n        ) -> CodeType: ...\n\nclass MappingProxyType(Mapping[_KT, _VT_co], Generic[_KT, _VT_co]):\n    __hash__: None  # type: ignore\n    def __init__(self, mapping: Mapping[_KT, _VT_co]) -> None: ...\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def copy(self) -> Dict[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __reversed__(self) -> Iterator[_KT]: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT_co | _T2]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT_co | _T2]: ...\n\nclass SimpleNamespace:\n    def __init__(self, **kwargs: Any) -> None: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __delattr__(self, name: str) -> None: ...\n\nclass ModuleType:\n    __name__: str\n    __file__: str\n    __dict__: Dict[str, Any]\n    __loader__: Optional[_LoaderProtocol]\n    __package__: Optional[str]\n    __spec__: Optional[ModuleSpec]\n    def __init__(self, name: str, doc: Optional[str] = ...) -> None: ...\n\nclass GeneratorType(Generator[_T_co, _T_contra, _V_co]):\n    gi_code: CodeType\n    gi_frame: FrameType\n    gi_running: bool\n    gi_yieldfrom: Optional[GeneratorType[_T_co, _T_contra, Any]]\n    def __iter__(self) -> GeneratorType[_T_co, _T_contra, _V_co]: ...\n    def __next__(self) -> _T_co: ...\n    def close(self) -> None: ...\n    def send(self, __arg: _T_contra) -> _T_co: ...\n    @overload\n    def throw(\n        self, __typ: Type[BaseException], __val: typing.Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n\nclass AsyncGeneratorType(AsyncGenerator[_T_co, _T_contra]):\n    ag_await: Optional[Awaitable[Any]]\n    ag_frame: FrameType\n    ag_running: bool\n    ag_code: CodeType\n    def __aiter__(self) -> AsyncGeneratorType[_T_co, _T_contra]: ...\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def asend(self, __val: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self, __typ: Type[BaseException], __val: typing.Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> Awaitable[_T_co]: ...\n    def aclose(self) -> Awaitable[None]: ...\n\nclass CoroutineType:\n    cr_await: Optional[Any]\n    cr_code: CodeType\n    cr_frame: FrameType\n    cr_running: bool\n    def close(self) -> None: ...\n    def send(self, __arg: Any) -> Any: ...\n    @overload\n    def throw(\n        self, __typ: Type[BaseException], __val: typing.Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> Any: ...\n    @overload\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> Any: ...\n\nclass _StaticFunctionType:\n    \"\"\"Fictional type to correct the type of MethodType.__func__.\n\n    FunctionType is a descriptor, so mypy follows the descriptor protocol and\n    converts MethodType.__func__ back to MethodType (the return type of\n    FunctionType.__get__). But this is actually a special case; MethodType is\n    implemented in C and its attribute access doesn't go through\n    __getattribute__.\n\n    By wrapping FunctionType in _StaticFunctionType, we get the right result;\n    similar to wrapping a function in staticmethod() at runtime to prevent it\n    being bound as a method.\n    \"\"\"\n\n    def __get__(self, obj: Optional[object], type: Optional[type]) -> FunctionType: ...\n\nclass MethodType:\n    __closure__: Optional[Tuple[_Cell, ...]]  # inherited from the added function\n    __defaults__: Optional[Tuple[Any, ...]]  # inherited from the added function\n    __func__: _StaticFunctionType\n    __self__: object\n    __name__: str  # inherited from the added function\n    __qualname__: str  # inherited from the added function\n    def __init__(self, func: Callable[..., Any], obj: object) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nclass BuiltinFunctionType:\n    __self__: typing.Union[object, ModuleType]\n    __name__: str\n    __qualname__: str\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nBuiltinMethodType = BuiltinFunctionType\n\nif sys.version_info >= (3, 7):\n    class WrapperDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    class MethodWrapperType:\n        __self__: object\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __ne__(self, other: Any) -> bool: ...\n    class MethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    class ClassMethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n\nclass TracebackType:\n    if sys.version_info >= (3, 7):\n        def __init__(self, tb_next: Optional[TracebackType], tb_frame: FrameType, tb_lasti: int, tb_lineno: int) -> None: ...\n        tb_next: Optional[TracebackType]\n    else:\n        @property\n        def tb_next(self) -> Optional[TracebackType]: ...\n    # the rest are read-only even in 3.7\n    @property\n    def tb_frame(self) -> FrameType: ...\n    @property\n    def tb_lasti(self) -> int: ...\n    @property\n    def tb_lineno(self) -> int: ...\n\nclass FrameType:\n    f_back: Optional[FrameType]\n    f_builtins: Dict[str, Any]\n    f_code: CodeType\n    f_globals: Dict[str, Any]\n    f_lasti: int\n    f_lineno: int\n    f_locals: Dict[str, Any]\n    f_trace: Optional[Callable[[FrameType, str, Any], Any]]\n    if sys.version_info >= (3, 7):\n        f_trace_lines: bool\n        f_trace_opcodes: bool\n    def clear(self) -> None: ...\n\nclass GetSetDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nclass MemberDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nif sys.version_info >= (3, 7):\n    def new_class(\n        name: str,\n        bases: Iterable[object] = ...,\n        kwds: Optional[Dict[str, Any]] = ...,\n        exec_body: Optional[Callable[[Dict[str, Any]], None]] = ...,\n    ) -> type: ...\n    def resolve_bases(bases: Iterable[object]) -> Tuple[Any, ...]: ...\n\nelse:\n    def new_class(\n        name: str,\n        bases: Tuple[type, ...] = ...,\n        kwds: Optional[Dict[str, Any]] = ...,\n        exec_body: Optional[Callable[[Dict[str, Any]], None]] = ...,\n    ) -> type: ...\n\ndef prepare_class(\n    name: str, bases: Tuple[type, ...] = ..., kwds: Optional[Dict[str, Any]] = ...\n) -> Tuple[type, Dict[str, Any], Dict[str, Any]]: ...\n\n# Actually a different type, but `property` is special and we want that too.\nDynamicClassAttribute = property\n\ndef coroutine(func: Callable[..., Any]) -> CoroutineType: ...\n\nif sys.version_info >= (3, 9):\n    class GenericAlias:\n        __origin__: type\n        __args__: Tuple[Any, ...]\n        __parameters__: Tuple[Any, ...]\n        def __init__(self, origin: type, args: Any) -> None: ...\n        def __getattr__(self, name: str) -> Any: ...  # incomplete\n\nif sys.version_info >= (3, 10):\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n    EllipsisType = ellipsis  # noqa F811 from builtins\n    from builtins import _NotImplementedType\n\n    NotImplementedType = _NotImplementedType  # noqa F811 from builtins\n    class Union:\n        __args__: Tuple[Any, ...]\n        def __or__(self, obj: Any) -> Union: ...\n        def __ror__(self, obj: Any) -> Union: ...\n",
    "/typeshed/stdlib/typing.pyi": "import collections  # Needed by aliases like DefaultDict, see mypy issue 2986\nimport sys\nfrom abc import ABCMeta, abstractmethod\nfrom types import BuiltinFunctionType, CodeType, FrameType, FunctionType, MethodType, ModuleType, TracebackType\nfrom typing_extensions import Literal as _Literal\n\nif sys.version_info >= (3, 7):\n    from types import MethodDescriptorType, MethodWrapperType, WrapperDescriptorType\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n# Definitions of special type checking related constructs.  Their definitions\n# are not used, so their value does not matter.\n\nAny = object()\n\nclass TypeVar:\n    __name__: str\n    __bound__: Optional[Type[Any]]\n    __constraints__: Tuple[Type[Any], ...]\n    __covariant__: bool\n    __contravariant__: bool\n    def __init__(\n        self,\n        name: str,\n        *constraints: Type[Any],\n        bound: Union[None, Type[Any], str] = ...,\n        covariant: bool = ...,\n        contravariant: bool = ...,\n    ) -> None: ...\n\n_promote = object()\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> object: ...\n\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n\ndef overload(func: _F) -> _F: ...\n\nUnion: _SpecialForm = ...\nOptional: _SpecialForm = ...\nTuple: _SpecialForm = ...\nGeneric: _SpecialForm = ...\n# Protocol is only present in 3.8 and later, but mypy needs it unconditionally\nProtocol: _SpecialForm = ...\nCallable: _SpecialForm = ...\nType: _SpecialForm = ...\nClassVar: _SpecialForm = ...\nif sys.version_info >= (3, 8):\n    Final: _SpecialForm = ...\n    def final(f: _F) -> _F: ...\n    Literal: _SpecialForm = ...\n    # TypedDict is a (non-subscriptable) special form.\n    TypedDict: object\n\nif sys.version_info < (3, 7):\n    class GenericMeta(type): ...\n\nif sys.version_info >= (3, 10):\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Optional[Type[Any]]\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: Union[None, Type[Any], str] = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n\n# Return type that indicates a function does not return.\n# This type is equivalent to the None type, but the no-op Union is necessary to\n# distinguish the None type from the None value.\nNoReturn = Union[None]\n\n# These type variables are used by the container types.\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_KT = TypeVar(\"_KT\")  # Key type.\n_VT = TypeVar(\"_VT\")  # Value type.\n_T_co = TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_V_co = TypeVar(\"_V_co\", covariant=True)  # Any type covariant containers.\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)  # Ditto contravariant.\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\ndef no_type_check(arg: _F) -> _F: ...\ndef no_type_check_decorator(decorator: _F) -> _F: ...\n\n# Type aliases and type constructors\n\nclass _Alias:\n    # Class for defining generic aliases for library types.\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\nList = _Alias()\nDict = _Alias()\nDefaultDict = _Alias()\nSet = _Alias()\nFrozenSet = _Alias()\nCounter = _Alias()\nDeque = _Alias()\nChainMap = _Alias()\n\nif sys.version_info >= (3, 7):\n    OrderedDict = _Alias()\n\nif sys.version_info >= (3, 9):\n    Annotated: _SpecialForm = ...\n\n# Predefined type variables.\nAnyStr = TypeVar(\"AnyStr\", str, bytes)\n\n# Abstract base classes.\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n@runtime_checkable\nclass SupportsInt(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __int__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsFloat(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __float__(self) -> float: ...\n\n@runtime_checkable\nclass SupportsComplex(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n\n@runtime_checkable\nclass SupportsBytes(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __bytes__(self) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    @runtime_checkable\n    class SupportsIndex(Protocol, metaclass=ABCMeta):\n        @abstractmethod\n        def __index__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsAbs(Protocol[_T_co]):\n    @abstractmethod\n    def __abs__(self) -> _T_co: ...\n\n@runtime_checkable\nclass SupportsRound(Protocol[_T_co]):\n    @overload\n    @abstractmethod\n    def __round__(self) -> int: ...\n    @overload\n    @abstractmethod\n    def __round__(self, ndigits: int) -> _T_co: ...\n\n@runtime_checkable\nclass Sized(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n@runtime_checkable\nclass Hashable(Protocol, metaclass=ABCMeta):\n    # TODO: This is special, in that a subclass of a hashable class may not be hashable\n    #   (for example, list vs. object). It's not obvious how to represent this. This class\n    #   is currently mostly useless for static checking.\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\n@runtime_checkable\nclass Iterable(Protocol[_T_co]):\n    @abstractmethod\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Iterator(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __next__(self) -> _T_co: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Reversible(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass Generator(Iterator[_T_co], Generic[_T_co, _T_contra, _V_co]):\n    def __next__(self) -> _T_co: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    def close(self) -> None: ...\n    def __iter__(self) -> Generator[_T_co, _T_contra, _V_co]: ...\n    @property\n    def gi_code(self) -> CodeType: ...\n    @property\n    def gi_frame(self) -> FrameType: ...\n    @property\n    def gi_running(self) -> bool: ...\n    @property\n    def gi_yieldfrom(self) -> Optional[Generator[Any, Any, Any]]: ...\n\n@runtime_checkable\nclass Awaitable(Protocol[_T_co]):\n    @abstractmethod\n    def __await__(self) -> Generator[Any, None, _T_co]: ...\n\nclass Coroutine(Awaitable[_V_co], Generic[_T_co, _T_contra, _V_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_await(self) -> Optional[Any]: ...\n    @property\n    def cr_code(self) -> CodeType: ...\n    @property\n    def cr_frame(self) -> FrameType: ...\n    @property\n    def cr_running(self) -> bool: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    @abstractmethod\n    def close(self) -> None: ...\n\n# NOTE: This type does not exist in typing.py or PEP 484.\n# The parameters correspond to Generator, but the 4th is the original type.\nclass AwaitableGenerator(\n    Awaitable[_V_co], Generator[_T_co, _T_contra, _V_co], Generic[_T_co, _T_contra, _V_co, _S], metaclass=ABCMeta\n): ...\n\n@runtime_checkable\nclass AsyncIterable(Protocol[_T_co]):\n    @abstractmethod\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\nclass AsyncGenerator(AsyncIterator[_T_co], Generic[_T_co, _T_contra]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def asend(self, __value: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def aclose(self) -> Awaitable[None]: ...\n    @abstractmethod\n    def __aiter__(self) -> AsyncGenerator[_T_co, _T_contra]: ...\n    @property\n    def ag_await(self) -> Any: ...\n    @property\n    def ag_code(self) -> CodeType: ...\n    @property\n    def ag_frame(self) -> FrameType: ...\n    @property\n    def ag_running(self) -> bool: ...\n\n@runtime_checkable\nclass Container(Protocol[_T_co]):\n    @abstractmethod\n    def __contains__(self, __x: object) -> bool: ...\n\n@runtime_checkable\nclass Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):\n    # Implement Sized (but don't have it as a base class).\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n_Collection = Collection[_T_co]\n\nclass Sequence(_Collection[_T_co], Reversible[_T_co], Generic[_T_co]):\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...\n    # Mixin methods\n    def index(self, value: Any, start: int = ..., stop: int = ...) -> int: ...\n    def count(self, value: Any) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass MutableSequence(Sequence[_T], Generic[_T]):\n    @abstractmethod\n    def insert(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> MutableSequence[_T]: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: int) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: slice) -> None: ...\n    # Mixin methods\n    def append(self, value: _T) -> None: ...\n    def clear(self) -> None: ...\n    def extend(self, values: Iterable[_T]) -> None: ...\n    def reverse(self) -> None: ...\n    def pop(self, index: int = ...) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __iadd__(self, x: Iterable[_T]) -> MutableSequence[_T]: ...\n\nclass AbstractSet(_Collection[_T_co], Generic[_T_co]):\n    @abstractmethod\n    def __contains__(self, x: object) -> bool: ...\n    # Mixin methods\n    def __le__(self, s: AbstractSet[Any]) -> bool: ...\n    def __lt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __gt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __ge__(self, s: AbstractSet[Any]) -> bool: ...\n    def __and__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def __sub__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def isdisjoint(self, other: Iterable[Any]) -> bool: ...\n\nclass MutableSet(AbstractSet[_T], Generic[_T]):\n    @abstractmethod\n    def add(self, value: _T) -> None: ...\n    @abstractmethod\n    def discard(self, value: _T) -> None: ...\n    # Mixin methods\n    def clear(self) -> None: ...\n    def pop(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __ior__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __iand__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __isub__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n\nclass MappingView(Sized):\n    def __init__(self, mapping: Mapping[Any, Any]) -> None: ...  # undocumented\n    def __len__(self) -> int: ...\n\nclass ItemsView(MappingView, AbstractSet[Tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, _VT_co]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n\nclass KeysView(MappingView, AbstractSet[_KT_co], Generic[_KT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, Any]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT_co]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n\nclass ValuesView(MappingView, Iterable[_VT_co], Generic[_VT_co]):\n    def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_VT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_VT_co]: ...\n\n@runtime_checkable\nclass ContextManager(Protocol[_T_co]):\n    def __enter__(self) -> _T_co: ...\n    def __exit__(\n        self,\n        __exc_type: Optional[Type[BaseException]],\n        __exc_value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n    ) -> Optional[bool]: ...\n\n@runtime_checkable\nclass AsyncContextManager(Protocol[_T_co]):\n    def __aenter__(self) -> Awaitable[_T_co]: ...\n    def __aexit__(\n        self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Awaitable[Optional[bool]]: ...\n\nclass Mapping(_Collection[_KT], Generic[_KT, _VT_co]):\n    # TODO: We wish the key type could also be covariant, but that doesn't work,\n    # see discussion in https: //github.com/python/typing/pull/273.\n    @abstractmethod\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    # Mixin methods\n    @overload\n    def get(self, key: _KT) -> Optional[_VT_co]: ...\n    @overload\n    def get(self, key: _KT, default: Union[_VT_co, _T]) -> Union[_VT_co, _T]: ...\n    def items(self) -> AbstractSet[Tuple[_KT, _VT_co]]: ...\n    def keys(self) -> AbstractSet[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def __contains__(self, o: object) -> bool: ...\n\nclass MutableMapping(Mapping[_KT, _VT], Generic[_KT, _VT]):\n    @abstractmethod\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    @abstractmethod\n    def __delitem__(self, v: _KT) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: Union[_VT, _T] = ...) -> Union[_VT, _T]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, key: _KT, default: _VT = ...) -> _VT: ...\n    # 'update' used to take a Union, but using overloading is better.\n    # The second overloaded type here is a bit too general, because\n    # Mapping[Tuple[_KT, _VT], W] is a subclass of Iterable[Tuple[_KT, _VT]],\n    # but will always have the behavior of the first overloaded type\n    # at runtime, leading to keys of a mix of types _KT and Tuple[_KT, _VT].\n    # We don't currently have any way of forcing all Mappings to use\n    # the first overload, but by using overloading rather than a Union,\n    # mypy will commit to using the first overload when the argument is\n    # known to be a Mapping with unknown type parameters, which is closer\n    # to the behavior we want. See mypy issue  #1430.\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n\nText = str\n\nTYPE_CHECKING = True\n\nclass IO(Iterator[AnyStr], Generic[AnyStr]):\n    # TODO use abstract properties\n    @property\n    def mode(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    @abstractmethod\n    def fileno(self) -> int: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def isatty(self) -> bool: ...\n    @abstractmethod\n    def read(self, n: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readable(self) -> bool: ...\n    @abstractmethod\n    def readline(self, limit: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readlines(self, hint: int = ...) -> list[AnyStr]: ...\n    @abstractmethod\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    @abstractmethod\n    def seekable(self) -> bool: ...\n    @abstractmethod\n    def tell(self) -> int: ...\n    @abstractmethod\n    def truncate(self, size: Optional[int] = ...) -> int: ...\n    @abstractmethod\n    def writable(self) -> bool: ...\n    @abstractmethod\n    def write(self, s: AnyStr) -> int: ...\n    @abstractmethod\n    def writelines(self, lines: Iterable[AnyStr]) -> None: ...\n    @abstractmethod\n    def __next__(self) -> AnyStr: ...\n    @abstractmethod\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    @abstractmethod\n    def __enter__(self) -> IO[AnyStr]: ...\n    @abstractmethod\n    def __exit__(\n        self, t: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Optional[bool]: ...\n\nclass BinaryIO(IO[bytes]):\n    @abstractmethod\n    def __enter__(self) -> BinaryIO: ...\n\nclass TextIO(IO[str]):\n    # TODO use abstractproperty\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def encoding(self) -> str: ...\n    @property\n    def errors(self) -> Optional[str]: ...\n    @property\n    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython\n    @property\n    def newlines(self) -> Any: ...  # None, str or tuple\n    @abstractmethod\n    def __enter__(self) -> TextIO: ...\n\nclass ByteString(Sequence[int], metaclass=ABCMeta): ...\n\nclass Match(Generic[AnyStr]):\n    pos: int\n    endpos: int\n    lastindex: Optional[int]\n    lastgroup: Optional[AnyStr]\n    string: AnyStr\n\n    # The regular expression object whose match() or search() method produced\n    # this match instance.\n    re: Pattern[AnyStr]\n    def expand(self, template: AnyStr) -> AnyStr: ...\n    # group() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def group(self, __group: _Literal[0] = ...) -> AnyStr: ...\n    @overload\n    def group(self, __group: str | int) -> AnyStr | Any: ...\n    @overload\n    def group(self, __group1: str | int, __group2: str | int, *groups: str | int) -> Tuple[AnyStr | Any, ...]: ...\n    # Each item of groups()'s return tuple is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groups(self) -> Tuple[AnyStr | Any, ...]: ...\n    @overload\n    def groups(self, default: _T) -> Tuple[AnyStr | _T, ...]: ...\n    # Each value in groupdict()'s return dict is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groupdict(self) -> dict[str, AnyStr | Any]: ...\n    @overload\n    def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...\n    def start(self, __group: Union[int, str] = ...) -> int: ...\n    def end(self, __group: Union[int, str] = ...) -> int: ...\n    def span(self, __group: Union[int, str] = ...) -> Tuple[int, int]: ...\n    @property\n    def regs(self) -> Tuple[Tuple[int, int], ...]: ...  # undocumented\n    # __getitem__() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def __getitem__(self, __key: _Literal[0]) -> AnyStr: ...\n    @overload\n    def __getitem__(self, __key: int | str) -> AnyStr | Any: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Pattern(Generic[AnyStr]):\n    flags: int\n    groupindex: Mapping[str, int]\n    groups: int\n    pattern: AnyStr\n    def search(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def match(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def fullmatch(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def split(self, string: AnyStr, maxsplit: int = ...) -> list[AnyStr]: ...\n    def findall(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> list[Any]: ...\n    def finditer(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Iterator[Match[AnyStr]]: ...\n    @overload\n    def sub(self, repl: AnyStr, string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def sub(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def subn(self, repl: AnyStr, string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    @overload\n    def subn(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# Functions\n\nif sys.version_info >= (3, 7):\n    _get_type_hints_obj_allowed_types = Union[\n        object,\n        Callable[..., Any],\n        FunctionType,\n        BuiltinFunctionType,\n        MethodType,\n        ModuleType,\n        WrapperDescriptorType,\n        MethodWrapperType,\n        MethodDescriptorType,\n    ]\nelse:\n    _get_type_hints_obj_allowed_types = Union[\n        object, Callable[..., Any], FunctionType, BuiltinFunctionType, MethodType, ModuleType,\n    ]\n\nif sys.version_info >= (3, 9):\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: Optional[Dict[str, Any]] = ...,\n        localns: Optional[Dict[str, Any]] = ...,\n        include_extras: bool = ...,\n    ) -> Dict[str, Any]: ...\n\nelse:\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types, globalns: Optional[Dict[str, Any]] = ..., localns: Optional[Dict[str, Any]] = ...\n    ) -> Dict[str, Any]: ...\n\nif sys.version_info >= (3, 8):\n    def get_origin(tp: Any) -> Optional[Any]: ...\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n\n@overload\ndef cast(typ: Type[_T], val: Any) -> _T: ...\n@overload\ndef cast(typ: str, val: Any) -> Any: ...\n@overload\ndef cast(typ: object, val: Any) -> Any: ...\n\n# Type constructors\n\n# NamedTuple is special-cased in the type checker\nclass NamedTuple(Tuple[Any, ...]):\n    _field_types: collections.OrderedDict[str, Type[Any]]\n    _field_defaults: Dict[str, Any] = ...\n    _fields: Tuple[str, ...]\n    _source: str\n    def __init__(self, typename: str, fields: Iterable[Tuple[str, Any]] = ..., **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def _asdict(self) -> Dict[str, Any]: ...\n    else:\n        def _asdict(self) -> collections.OrderedDict[str, Any]: ...\n    def _replace(self: _T, **kwargs: Any) -> _T: ...\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __or__(self: _T, __value: _T) -> _T: ...\n    def __ior__(self: _T, __value: _T) -> _T: ...\n\ndef NewType(name: str, tp: Type[_T]) -> Type[_T]: ...\n\n# This itself is only available during type checking\ndef type_check_only(func_or_cls: _F) -> _F: ...\n\nif sys.version_info >= (3, 7):\n    class ForwardRef:\n        __forward_arg__: str\n        __forward_code__: CodeType\n        __forward_evaluated__: bool\n        __forward_value__: Optional[Any]\n        __forward_is_argument__: bool\n        def __init__(self, arg: str, is_argument: bool = ...) -> None: ...\n        def _evaluate(self, globalns: Optional[Dict[str, Any]], localns: Optional[Dict[str, Any]]) -> Optional[Any]: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __hash__(self) -> int: ...\n        def __repr__(self) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def is_typeddict(tp: Any) -> bool: ...\n",
    "/typeshed/stdlib/typing_extensions.pyi": "import abc\nimport sys\nfrom typing import (\n    TYPE_CHECKING as TYPE_CHECKING,\n    Any,\n    AsyncContextManager as AsyncContextManager,\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    Callable,\n    ChainMap as ChainMap,\n    ClassVar as ClassVar,\n    ContextManager as ContextManager,\n    Coroutine as Coroutine,\n    Counter as Counter,\n    DefaultDict as DefaultDict,\n    Deque as Deque,\n    Dict,\n    ItemsView,\n    KeysView,\n    Mapping,\n    NewType as NewType,\n    NoReturn as NoReturn,\n    Optional,\n    Text as Text,\n    Tuple,\n    Type as Type,\n    TypeVar,\n    Union,\n    ValuesView,\n    _Alias,\n    overload as overload,\n)\n\n_T = TypeVar(\"_T\")\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n\n# This alias for above is kept here for backwards compatibility.\nruntime = runtime_checkable\nProtocol: _SpecialForm = ...\nFinal: _SpecialForm = ...\n\ndef final(f: _F) -> _F: ...\n\nLiteral: _SpecialForm = ...\n\ndef IntVar(name: str) -> Any: ...  # returns a new TypeVar\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n\n# TypedDict is a (non-subscriptable) special form.\nTypedDict: object = ...\n\nOrderedDict = _Alias()\n\ndef get_type_hints(\n    obj: Callable[..., Any],\n    globalns: Optional[Dict[str, Any]] = ...,\n    localns: Optional[Dict[str, Any]] = ...,\n    include_extras: bool = ...,\n) -> Dict[str, Any]: ...\n\nif sys.version_info >= (3, 7):\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n    def get_origin(tp: Any) -> Optional[Any]: ...\n\nAnnotated: _SpecialForm = ...\n_AnnotatedAlias: Any = ...  # undocumented\n\n@runtime_checkable\nclass SupportsIndex(Protocol, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __index__(self) -> int: ...\n\n# PEP 612 support for Python < 3.9\nif sys.version_info >= (3, 10):\n    from typing import Concatenate as Concatenate, ParamSpec as ParamSpec, TypeAlias as TypeAlias, TypeGuard as TypeGuard\nelse:\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Optional[Type[Any]]\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: Union[None, Type[Any], str] = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n\n# PEP 646\nUnpack: _SpecialForm = ...\n\nclass TypeVarTuple:\n    __name__: str\n    def __init__(self, name: str) -> None: ...\n\n# PEP 655\nRequired: _SpecialForm = ...\nNotRequired: _SpecialForm = ...\n",
    "/typeshed/stdlib/uarray.pyi": "import sys\nfrom typing import Any, BinaryIO, Generic, Iterable, List, MutableSequence, Text, Tuple, TypeVar, Union, overload\nfrom typing_extensions import Literal\n\n_IntTypeCode = Literal[\"b\", \"B\", \"h\", \"H\", \"i\", \"I\", \"l\", \"L\", \"q\", \"Q\"]\n_FloatTypeCode = Literal[\"f\", \"d\"]\n_UnicodeTypeCode = Literal[\"u\"]\n_TypeCode = Union[_IntTypeCode, _FloatTypeCode, _UnicodeTypeCode]\n\n_T = TypeVar(\"_T\", int, float, Text)\n\nif sys.version_info >= (3,):\n    typecodes: str\n\nclass array(MutableSequence[_T], Generic[_T]):\n    typecode: _TypeCode\n    itemsize: int\n    @overload\n    def __init__(self: array[int], typecode: _IntTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...\n    @overload\n    def __init__(self: array[float], typecode: _FloatTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...\n    @overload\n    def __init__(self: array[Text], typecode: _UnicodeTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...\n    @overload\n    def __init__(self, typecode: str, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...\n    def append(self, __v: _T) -> None: ...\n    def decode(self) -> str: ...\n    def extend(self, __bb: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> array[_T]: ...\n    @overload  # type: ignore  # Overrides MutableSequence\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: array[_T]) -> None: ...\n    def __delitem__(self, i: Union[int, slice]) -> None: ...\n    def __add__(self, x: array[_T]) -> array[_T]: ...\n    def __ge__(self, other: array[_T]) -> bool: ...\n    def __gt__(self, other: array[_T]) -> bool: ...\n    def __iadd__(self, x: array[_T]) -> array[_T]: ...  # type: ignore  # Overrides MutableSequence\n    def __imul__(self, n: int) -> array[_T]: ...\n    def __le__(self, other: array[_T]) -> bool: ...\n    def __lt__(self, other: array[_T]) -> bool: ...\n    def __mul__(self, n: int) -> array[_T]: ...\n    def __rmul__(self, n: int) -> array[_T]: ...\n    if sys.version_info < (3,):\n        def __delslice__(self, i: int, j: int) -> None: ...\n        def __getslice__(self, i: int, j: int) -> array[_T]: ...\n        def __setslice__(self, i: int, j: int, y: array[_T]) -> None: ...\n\nArrayType = array\n",
    "/typeshed/stdlib/uerrno.pyi": "EACCES = 13\nEADDRINUSE = 112\nEAGAIN = 11\nEALREADY = 120\nEBADF = 9\nECONNABORTED = 113\nECONNREFUSED = 111\nECONNRESET = 104\nEEXIST = 17\nEHOSTUNREACH = 118\nEINPROGRESS = 119\nEINVAL = 22\nEIO = 5\nEISDIR = 21\nENOBUFS = 105\nENODEV = 19\nENOENT = 2\nENOMEM = 12\nENOTCONN = 128\nEOPNOTSUPP = 95\nEPERM = 1\nETIMEDOUT = 116\nerrorcode = None\n",
    "/typeshed/stdlib/uos.pyi": "# Copyright (c) 2019, Digi International, Inc.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nfrom typing import Any, Iterator, List, Tuple\n\nsep: str = ...\n\n\ndef chdir(path: str) -> None:\n    \"\"\"\n    Changes current directory.\n\n    :param path: Path to change to.\n    \"\"\"\n    ...\n\ndef getcwd() -> str:\n    \"\"\"\n    Gets the current directory.\n\n    :return: Current directory.\n    \"\"\"\n    ...\n\ndef ilistdir(path: str=\".\") -> Iterator[Tuple]:\n    \"\"\"\n    Returns an iterator which then yields tuples corresponding to the entries\n    in the directory that it is listing. With no argument it lists the current\n    directory, otherwise it lists the directory given by ``path``.\n\n    The tuples have the form ``(name, type, inode[, size])``:\n\n    * ``name`` is a string (or bytes if dir is a bytes object) and is the name\n      of the entry.\n    * ``type`` is an integer that specifies the type of the entry, with 0x4000\n      for directories and 0x8000 for regular files.\n    * ``inode`` is an integer corresponding to the inode of the file, and may\n      be 0 for filesystems that don't have such a notion.\n    * Some platforms may return a 4-tuple that includes the entry's size. For\n      file entries, ``size`` is an integer representing the size of the file or\n      -1 if unknown. Its meaning is currently undefined for directory entries.\n\n    :param path: Path to list its elements.\n\n    :return: An iterator with a tuple for each entry in the path.\n    \"\"\"\n    ...\n\ndef listdir(path: str=\".\") -> List:\n    \"\"\"\n    Lists the specified path or the current one if ``path`` is not provided.\n\n    :param path: The path to list. If this parameter is not provided, the\n        method lists the current path.\n\n    :return: List containing the name of the elements in the path.\n    \"\"\"\n    ...\n\ndef mkdir(path: str) -> None:\n    \"\"\"\n    Creates a new directory.\n\n    :param path: Name of the directory to create.\n    \"\"\"\n    ...\n\ndef mount(fsobj, mount_point, *, readonly) -> None:\n    \"\"\"\n    Mount the filesystem object *fsobj* at the location in the VFS given by the\n    *mount_point* string.  *fsobj* can be a a VFS object that has a ``mount()``\n    method, or a block device.  If it's a block device then the filesystem type\n    is automatically detected (an exception is raised if no filesystem was\n    recognised).  *mount_point* may be ``'/'`` to mount *fsobj* at the root,\n    or ``'/<name>'`` to mount it at a subdirectory under the root.\n\n    If *readonly* is ``True`` then the filesystem is mounted read-only.\n\n    During the mount process the method ``mount()`` is called on the filesystem\n    object.\n\n    Will raise ``OSError(EPERM)`` if *mount_point* is already mounted.\n    \"\"\"\n    ...\n\ndef remove(path: str) -> None:\n    \"\"\"\n    Removes a file.\n\n    :param path: Path of the file to remove.\n    \"\"\"\n    ...\n\ndef rename(old_path: str, new_path: str) -> None:\n    \"\"\"\n    Renames a file or directory.\n\n    :param old_path: Name of the file to rename.\n    :param new_path: New name of the file.\n    \"\"\"\n    ...\n\ndef rmdir(dir: str) -> None:\n    \"\"\"\n    Removes a directory. Fails if ``dir`` is not empty.\n\n    :param dir: Path of the directory to remove.\n    \"\"\"\n    ...\n\ndef stat(path: str) -> Tuple:\n    \"\"\"\n    Get the status of a file or directory.\n    \"\"\"\n\ndef statvfs(path: str) -> Tuple:\n    \"\"\"\n    Gets the status of a fileystem.\n\n    Returns a tuple with the filesystem information in the following order:\n\n    * ``f_bsize`` \u2013 file system block size\n    * ``f_frsize`` \u2013 fragment size\n    * ``f_blocks`` \u2013 size of fs in f_frsize units\n    * ``f_bfree`` \u2013 number of free blocks\n    * ``f_bavail`` \u2013 number of free blocks for unpriviliged users\n    * ``f_files`` \u2013 number of inodes\n    * ``f_ffree`` \u2013 number of free inodes\n    * ``f_favail`` \u2013 number of free inodes for unpriviliged users\n    * ``f_flag`` \u2013 mount flags\n    * ``f_namemax`` \u2013 maximum filename length\n\n    :param path: Path of the filesystem to get its status.\n\n    :return: Tuple with the status of a filesystem.\n    \"\"\"\n    ...\n\ndef umount(mount_point: Any) -> None:\n    \"\"\"\n    Unmount a filesystem.\n\n    :param mount_point: can be a string naming the mount location, or a previously-mounted filesystem object.\n\n    \"\"\"\n    ...\n\ndef uname() -> Tuple:\n    \"\"\"\n    Gets the information about the machine or operating system.\n\n    Return a tuple (possibly a named tuple) containing information about \n    the underlying machine and/or its operating system. The tuple has \n    five fields in the following order, each of them being a string:\n\n    * ``sysname`` \u2013 the name of the underlying system\n    * ``nodename`` \u2013 the network name (can be the same as ``sysname``)\n    * ``release`` \u2013 the version of the underlying system\n    * ``version`` \u2013 the MicroPython version and build date\n    * ``machine`` \u2013 an identifier for the underlying hardware (eg board, CPU)\n\n    :return: Tuple with information about the machine or operating system.\n    \"\"\"\n    ...\n\n\n",
    "/typeshed/stdlib/urandom.pyi": "\"\"\"\nGenerate pseudo-random numbers.\n\"\"\"\nfrom typing import Any, TypeVar, Sequence, Union\n\n_T = TypeVar(\"_T\")\n\ndef choice(seq: Sequence[_T]) -> _T: \n    \"\"\"\n    Return a random element from the non-empty sequence ``seq``. \n    If ``seq`` is empty, raises ``IndexError``.\n    \"\"\"\n    ...\n\ndef getrandbits(k: int) -> int: \n    \"\"\"\n    Returns a python ``long`` int with ``k`` random bits. This method is \n    supplied with the MersenneTwister generator and some other generators \n    may also provide it as an optional part of the API. When available, \n    ``getrandbits()`` enables ``randrange()`` to handle arbitrarily large \n    ranges.\n    \"\"\"\n    ...\n\ndef randint(a: int, b: int) -> int: \n    \"\"\"\n    Return a random integer N such that ``a <= N <= b``.\n    \"\"\"\n    ...\n\ndef random() -> float:\n    \"\"\"\n    Return the next random floating point number in the range [0.0, 1.0).\n    \"\"\"\n    ...\n\ndef randrange(start: int, stop: Union[int, None] = ..., step: int = ...) -> int: \n    \"\"\"\n    Return a randomly selected element from ``range(start, stop, step)``. This is \n    equivalent to ``choice(range(start, stop, step))``, but doesn\u2019t actually build a \n    range object.\n    \"\"\"\n    ...\n\ndef seed(a: Any = ..., version: int = ...) -> None: \n    \"\"\"\n    Initialize internal state of the random number generator.\n\n    None or no argument seeds from current time or from an operating system specific \n    randomness source if available (see the ``os.urandom()`` function for details \n    on availability).\n\n    If a is not ``None`` or an ``int`` or a ``long``, then ``hash(a)`` is used instead. \n    Note that the hash values for some types are nondeterministic when ``PYTHONHASHSEED`` \n    is enabled.\n    \"\"\"\n    ...\n\ndef uniform(a: float, b: float) -> float: \n    \"\"\"\n    Return a random floating point number N such that ``a <= N <= b`` for ``a <= b`` \n    and ``b <= N <= a`` for ``b < a``.\n\n    The end-point value ``b`` may or may not be included in the range depending on \n    floating-point rounding in the equation ``a + (b-a) * random()``.\n    \"\"\"\n    ...\n\n",
    "/typeshed/stdlib/ustruct.pyi": "# Copyright (c) 2019, Digi International, Inc.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nfrom typing import Any, Tuple\n\n\ndef calcsize(fmt: str) -> int:\n    \"\"\"\n    Returns the number of bytes needed to store the given ``fmt``.\n\n    :param fmt: Identifier of the typecode to get its size.\n\n    :return: The number of bytes needed.\n    \"\"\"\n    ...\n\ndef pack(fmt: str, v1: Any, *vn: Any) -> bytes:\n    \"\"\"\n    Returns a bytes object containing the values v1, v2, ... packed according\n    to the format string ``fmt``.\n\n    :param fmt: Format string sequence of the values to pack.\n    :param v1: Value to pack.\n    :param vn: Additional values to pack.\n\n    :return: Bytes object with the values packed according to the given format.\n    \"\"\"\n    ...\n\ndef pack_into(fmt: str, buff: Any, offset: int, v1: Any, *vn: Any) -> None:\n    \"\"\"\n    Packs the values v1, v2, ... according to the format string ``fmt`` and\n    writes the packed bytes into the writable buffer ``buf`` starting at\n    ``offset``.\n\n    **Note**: The offset is a required argument.\n\n    :param fmt: Format string sequence of the values to pack.\n    :param buff: Buffer to write the packed values into.\n    :param offset: Starting offset to pack values within the buffer.\n    :param v1: Value to pack.\n    :param vn: Additional values to pack.\n    \"\"\"\n    ...\n\ndef unpack(fmt: str, buffer: Any) -> Tuple:\n    \"\"\"\n    Returns a tuple containing values unpacked according to the format string\n    ``fmt``. The buffer's size in bytes must be ``calcsize(fmt)``.\n\n    :param fmt: Format string sequence of the packed values.\n    :param buffer: Buffer containing the packed values to unpack.\n\n    :return: Tuple containing the unpacked values.\n    \"\"\"\n    ...\n\ndef unpack_from(fmt: str, buffer: Any, offset: int=0) -> None:\n    \"\"\"\n    Returns a tuple containing values unpacked according to the format string\n    ``fmt``.  The buffer's size, minus ``offset``, must be at least\n    ``calcsize(fmt)``.\n\n    :param fmt: Format string sequence of the packed values.\n    :param buffer: Buffer containing the packed values to unpack.\n    :param offset: Offset within buffer to start unpacking values.\n\n    :return: Tuple containing the unpacked values.\n    \"\"\"\n    ...",
    "/typeshed/stdlib/usys.pyi": "# Copyright (c) 2019, Digi International, Inc.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nfrom typing import Any, Dict, List, Optional, Tuple\n\n\nargv: List[str] = ...\nbyteorder: str = ...\nimplementation: Tuple[str, Tuple[int, int, int], int] = ...\nmaxsize: int = ...\nmodules: Dict[str, Any] = ...  # technically [str, Module]\npath: List[str] = ...\nplatform: str = ...\nversion: str = ...\nversion_info: Tuple[int, int, int] = ...\n\n\ndef exit(arg: Optional[object] = None, /) -> None:\n    \"\"\"\n    Raise a ``SystemExit`` exception, with the given argument if specified.\n\n    Note that calling ``sys.exit()`` while at the MicroPython REPL\n    (``>>>`` prompt) has no effect.\n    \"\"\"\n\n\ndef print_exception(exc: BaseException) -> None:\n    \"\"\"\n    Print the given exception and its traceback to stdout.\n\n    This is a simplified version of CPython's ``traceback.print_exception()``\n    function.\n    \"\"\"\n",
    "/typeshed/stdlib/utime.pyi": "# Copyright (c) 2019, Digi International, Inc.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nfrom typing import Optional, Union\n\ndef gmtime(secs: Optional[int]=None) -> tuple:\n    \"\"\"\n    Converts a time expressed in seconds since the Epoch into an 8-tuple which\n    contains:\n\n    * ``year``\n    * ``month``\n    * ``mday``\n    * ``hour``\n    * ``minute``\n    * ``second``\n    * ``weekday``\n    * ``yearday``\n\n    :param secs: The time to convert. If not provided or ``None``, then the\n        current time from the RTC is used.\n\n    :return: The tuple containing the converted time.\n    \"\"\"\n    ...\n\ndef localtime(secs: Optional[int]=None) -> tuple:\n    \"\"\"\n    Converts a time expressed in seconds since the Epoch into an 8-tuple which\n    contains:\n\n    * ``year``\n    * ``month``\n    * ``mday``\n    * ``hour``\n    * ``minute``\n    * ``second``\n    * ``weekday``\n    * ``yearday``\n\n    :param secs: The time to convert. If not provided or ``None``, then the\n        current time from the RTC is used.\n\n    :return: The tuple containing the converted time.\n    \"\"\"\n    ...\n\ndef mktime(local_time: tuple) -> int:\n    \"\"\"\n    This is inverse function of localtime. Its argument is a full 8-tuple\n    which expresses a time as per localtime. It returns an integer which is\n    the number of seconds since Jan 1, 2000.\n\n    :param local_time: Full 8-tuple which expresses a time as per localtime.\n\n    :return: Amount of seconds since Epoch for the given time.\n    \"\"\"\n    ...\n\ndef time() -> int:\n    \"\"\"\n    Returns the number of seconds, as an integer, since the Epoch, assuming\n    that underlying RTC is set and maintained. If an RTC is not set, this\n    function returns number of seconds since a port-specific reference point\n    in time (for embedded boards without a battery-backed RTC, usually since\n    power up or reset).\n\n    If you want to develop portable MicroPython application, you should not\n    rely on this function to provide higher than second precision. If you need\n    higher precision, use ``ticks_ms()`` and ``ticks_us()`` functions, if you\n    need calendar time, ``localtime()`` without an argument is a better choice.\n\n    :return: Number of seconds, as an integer, since the Epoch.\n    \"\"\"\n    ...\n\ndef time_ns() -> int:\n    \"\"\"\n    Returns the number of nanoseconds, as an integer, since the Epoch, assuming\n    that underlying RTC is set and maintained. If an RTC is not set, this\n    function returns number of seconds since a port-specific reference point\n    in time (for embedded boards without a battery-backed RTC, usually since\n    power up or reset).\n\n    If you want to develop portable MicroPython application, you should not\n    rely on this function to provide higher than second precision. If you need\n    higher precision, use ``ticks_ms()`` and ``ticks_us()`` functions, if you\n    need calendar time, ``localtime()`` without an argument is a better choice.\n\n    :return: Number of seconds, as an integer, since the Epoch.\n    \"\"\"\n    ...\n\ndef sleep(seconds: Union[int, float]) -> None:\n    \"\"\"\n    Sleeps for the given number of seconds. Some boards may accept seconds\n    as a floating-point number to sleep for a fractional number of seconds.\n    Note that other boards may not accept a floating-point argument, for\n    compatibility with them use ``sleep_ms()`` and ``sleep_us()`` functions.\n\n    :param seconds: Amount of time to sleep for.\n    \"\"\"\n    ...\n\ndef sleep_ms(ms: int) -> None:\n    \"\"\"\n    Delays for given number of milliseconds, should be positive or 0.\n\n    :param ms: Delay in milliseconds.\n    \"\"\"\n    ...\n\ndef sleep_us(us: int) -> None:\n    \"\"\"\n    Delays for given number of microseconds, should be positive or 0.\n\n    :param us: Delay in microseconds\n    \"\"\"\n    ...\n\ndef ticks_ms() -> int:\n    \"\"\"\n    Returns the uptime of the XBee module in milliseconds.\n\n    :return: The uptime of the module in milliseconds.\n    \"\"\"\n    ...\n\ndef ticks_us() -> int:\n    \"\"\"\n    Returns the uptime of the XBee module in microseconds.\n\n    :return: The uptime of the module in microseconds.\n    \"\"\"\n    ...\n\ndef ticks_cpu() -> int:\n    \"\"\"\n    Returns the uptime of the module in microseconds but with a higher\n    resolution (faster).\n\n    :return: The uptime of the module in microseconds.\n    \"\"\"\n    ...\n\ndef ticks_add(ticks: int, delta: int) -> int:\n    \"\"\"\n    Offsets ticks value by a given number, which can be either positive or\n    negative. Given a ticks value, this function allows to calculate ticks\n    value delta ticks before or after it, following modular-arithmetic\n    definition of tick values (see ``ticks_ms()``).\n\n    This method is useful for calculating deadlines for events/tasks.\n\n    **Note**: You must use ``ticks_diff()`` function to work with deadlines.\n\n    :param ticks: Number obtained from a direct result of call to\n        ``ticks_ms()``, ``ticks_us()``, or ``ticks_cpu()`` functions (or from\n        previous call to ``ticks_add()``)\n    :param delta: Arbitrary integer number or numeric expression.\n\n    :return: Returns the result of the add operation.\n    \"\"\"\n    ...\n\ndef ticks_diff(ticks1: int, ticks2: int) -> int:\n    \"\"\"\n    Measures the period (ticks) difference between values returned from\n    ``ticks_ms()``, ``ticks_us()``, or ``ticks_cpu()`` functions, as a signed\n    value which may wrap around, so directly subtracting them is not supported.\n\n    The argument order is the same as for subtraction operator,\n    ``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - ticks2``.\n\n    :param ticks1: Ticks that precede in time the value of ``ticks2``.\n    :param ticks2: Second (newer) ticks value.\n\n    :return: The difference between the given ticks values.\n    \"\"\"\n    ...",
    "/typeshed/stdlib/_typeshed/__init__.pyi": "# Utility types for typeshed\n#\n# See the README.md file in this directory for more information.\n\nimport array\nimport mmap\nimport sys\nfrom os import PathLike\nfrom typing import AbstractSet, Any, Container, Iterable, Protocol, Tuple, TypeVar, Union\nfrom typing_extensions import Literal, final\n\n_KT = TypeVar(\"_KT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_KT_contra = TypeVar(\"_KT_contra\", contravariant=True)\n_VT = TypeVar(\"_VT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\n# Use for \"self\" annotations:\n#   def __enter__(self: Self) -> Self: ...\nSelf = TypeVar(\"Self\")  # noqa Y001\n\n# stable\nclass IdentityFunction(Protocol):\n    def __call__(self, __x: _T) -> _T: ...\n\nclass SupportsLessThan(Protocol):\n    def __lt__(self, __other: Any) -> bool: ...\n\nSupportsLessThanT = TypeVar(\"SupportsLessThanT\", bound=SupportsLessThan)  # noqa: Y001\n\nclass SupportsDivMod(Protocol[_T_contra, _T_co]):\n    def __divmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsRDivMod(Protocol[_T_contra, _T_co]):\n    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsLenAndGetItem(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __getitem__(self, __k: int) -> _T_co: ...\n\n# Mapping-like protocols\n\n# stable\nclass SupportsItems(Protocol[_KT_co, _VT_co]):\n    def items(self) -> AbstractSet[Tuple[_KT_co, _VT_co]]: ...\n\n# stable\nclass SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):\n    def keys(self) -> Iterable[_KT]: ...\n    def __getitem__(self, __k: _KT) -> _VT_co: ...\n\n# stable\nclass SupportsGetItem(Container[_KT_contra], Protocol[_KT_contra, _VT_co]):\n    def __getitem__(self, __k: _KT_contra) -> _VT_co: ...\n\n# stable\nclass SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):\n    def __setitem__(self, __k: _KT_contra, __v: _VT) -> None: ...\n    def __delitem__(self, __v: _KT_contra) -> None: ...\n\n# These aliases are simple strings in Python 2.\nStrPath = Union[str, PathLike[str]]  # stable\nBytesPath = Union[bytes, PathLike[bytes]]  # stable\nStrOrBytesPath = Union[str, bytes, PathLike[str], PathLike[bytes]]  # stable\n\nOpenTextModeUpdating = Literal[\n    \"r+\",\n    \"+r\",\n    \"rt+\",\n    \"r+t\",\n    \"+rt\",\n    \"tr+\",\n    \"t+r\",\n    \"+tr\",\n    \"w+\",\n    \"+w\",\n    \"wt+\",\n    \"w+t\",\n    \"+wt\",\n    \"tw+\",\n    \"t+w\",\n    \"+tw\",\n    \"a+\",\n    \"+a\",\n    \"at+\",\n    \"a+t\",\n    \"+at\",\n    \"ta+\",\n    \"t+a\",\n    \"+ta\",\n    \"x+\",\n    \"+x\",\n    \"xt+\",\n    \"x+t\",\n    \"+xt\",\n    \"tx+\",\n    \"t+x\",\n    \"+tx\",\n]\nOpenTextModeWriting = Literal[\"w\", \"wt\", \"tw\", \"a\", \"at\", \"ta\", \"x\", \"xt\", \"tx\"]\nOpenTextModeReading = Literal[\"r\", \"rt\", \"tr\", \"U\", \"rU\", \"Ur\", \"rtU\", \"rUt\", \"Urt\", \"trU\", \"tUr\", \"Utr\"]\nOpenTextMode = Union[OpenTextModeUpdating, OpenTextModeWriting, OpenTextModeReading]\nOpenBinaryModeUpdating = Literal[\n    \"rb+\",\n    \"r+b\",\n    \"+rb\",\n    \"br+\",\n    \"b+r\",\n    \"+br\",\n    \"wb+\",\n    \"w+b\",\n    \"+wb\",\n    \"bw+\",\n    \"b+w\",\n    \"+bw\",\n    \"ab+\",\n    \"a+b\",\n    \"+ab\",\n    \"ba+\",\n    \"b+a\",\n    \"+ba\",\n    \"xb+\",\n    \"x+b\",\n    \"+xb\",\n    \"bx+\",\n    \"b+x\",\n    \"+bx\",\n]\nOpenBinaryModeWriting = Literal[\"wb\", \"bw\", \"ab\", \"ba\", \"xb\", \"bx\"]\nOpenBinaryModeReading = Literal[\"rb\", \"br\", \"rbU\", \"rUb\", \"Urb\", \"brU\", \"bUr\", \"Ubr\"]\nOpenBinaryMode = Union[OpenBinaryModeUpdating, OpenBinaryModeReading, OpenBinaryModeWriting]\n\n# stable\nclass HasFileno(Protocol):\n    def fileno(self) -> int: ...\n\nFileDescriptor = int  # stable\nFileDescriptorLike = Union[int, HasFileno]  # stable\n\n# stable\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsReadline(Protocol[_T_co]):\n    def readline(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsNoArgReadline(Protocol[_T_co]):\n    def readline(self) -> _T_co: ...\n\n# stable\nclass SupportsWrite(Protocol[_T_contra]):\n    def write(self, __s: _T_contra) -> Any: ...\n\nReadableBuffer = Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]  # stable\nWriteableBuffer = Union[bytearray, memoryview, array.array[Any], mmap.mmap]  # stable\n\n# stable\nif sys.version_info >= (3, 10):\n    from types import NoneType as NoneType\nelse:\n    # Used by type checkers for checks involving None (does not exist at runtime)\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n",
    "/typeshed/stdlib/microbit/__init__.pyi": "\"\"\"micro:bit Micropython API\n\nEverything directly related to interacting with the hardware lives in the\n`microbit` module.  For ease of use it's recommended you start all scripts\nwith::\n\n    from microbit import *\n\nThe following documentation assumes you have done this.\n\nThere are a few functions available directly::\n\n    # sleep for the given number of milliseconds.\n    sleep(ms)\n    # returns the number of milliseconds since the micro:bit was last switched on.\n    running_time()\n    # makes the micro:bit enter panic mode (this usually happens when the DAL runs\n    # out of memory, and causes a sad face to be drawn on the display). The error\n    # code can be any arbitrary integer value.\n    panic(error_code)\n    # resets the micro:bit.\n    reset()\n\nThe rest of the functionality is provided by objects and classes in the\nmicrobit module, as described below.\n\nNote that the API exposes integers only (ie no floats are needed, but they may\nbe accepted).  We thus use milliseconds for the standard time unit.\n\"\"\"\n\nfrom . import (display as display, uart as uart, spi as spi, i2c as i2c,\n               accelerometer as accelerometer, compass as compass)\n\nfrom typing import Any, List, overload\n\n\ndef panic(n: int) -> None:\n    \"\"\"Enter a panic mode. Requires restart. Pass in an arbitrary integer <= 255\n    to indicate a status::\n\n        microbit.panic(255)\n    \"\"\"\n\n\ndef reset() -> None:\n    \"\"\"Restart the board.\"\"\"\n\n\ndef sleep(n: int) -> None:\n    \"\"\"Wait for ``n`` milliseconds. One second is 1000 milliseconds, so::\n\n        microbit.sleep(1000)\n\n    will pause the execution for one second.  ``n`` can be an integer or\n    a floating point number.\n    \"\"\"\n\n\ndef running_time() -> int:\n    \"\"\"Return the number of milliseconds since the board was switched on or\n    restarted.\n    \"\"\"\n\n\ndef temperature() -> int:\n    \"\"\"Return the temperature of the micro:bit in degrees Celcius.\"\"\"\n\n\nclass Button:\n    \"\"\"Represents a button.\n\n    .. note::\n        This class is not actually available to the user, it is only used by\n        the two button instances, which are provided already initialized.\n        \"\"\"\n\n    def is_pressed(self) -> bool:\n        \"\"\"Returns ``True`` if the specified button ``button`` is pressed, and\n        ``False`` otherwise.\n        \"\"\"\n\n    def was_pressed(self) -> bool:\n        \"\"\"Returns ``True`` or ``False`` to indicate if the button was pressed\n        since the device started or the last time this method was called.\n        \"\"\"\n\n    def get_presses(self) -> int:\n        \"\"\"Returns the running total of button presses, and resets this total\n        to zero before returning.\n        \"\"\"\n\n\nbutton_a: Button\n\"\"\"A ``Button`` instance (see below) representing the left button.\"\"\"\n\nbutton_b: Button\n\"\"\"Represents the right button.\"\"\"\n\n\nclass MicroBitDigitalPin:\n    \"\"\"\n    The pull mode for a pin is automatically configured when the pin changes to an\n    input mode. Input modes are when you call ``read_analog`` / ``read_digital`` /\n    ``is_touched``. The pull mode for these is, respectively, ``NO_PULL``,\n    ``PULL_DOWN``, ``PULL_UP``. Only when in ``read_digital`` mode can you call\n    ``set_pull`` to change the pull mode from the default.\n    \"\"\"\n\n    NO_PULL: int = 0\n    PULL_UP: int = 1\n    PULL_DOWN: int = 2\n\n    def read_digital(self) -> int:\n        \"\"\"Return 1 if the pin is high, and 0 if it's low.\"\"\"\n\n    def set_pull(self, value: int = (NO_PULL or PULL_UP or PULL_DOWN)) -> None:\n        \"\"\"Set the pull state to one of three possible values: ``pin.PULL_UP``,\n        ``pin.PULL_DOWN`` or ``pin.NO_PULL`` (where ``pin`` is an instance of\n        a pin). See below for discussion of default pull states.\n        \"\"\"\n\n    def write_digital(self, value: int) -> None:\n        \"\"\"Set the pin to high if ``value`` is 1, or to low, if it is 0.\"\"\"\n\n    def write_analog(self, value: int) -> None:\n        \"\"\"Output a PWM signal on the pin, with the duty cycle proportional to\n        the provided ``value``. The ``value`` may be either an integer or a\n        floating point number between 0 (0% duty cycle) and 1023 (100% duty).\n        \"\"\"\n\n    def set_analog_period(self, period: int) -> None:\n        \"\"\"Set the period of the PWM signal being output to ``period`` in\n        milliseconds. The minimum valid value is 1ms.\n        \"\"\"\n\n    def set_analog_period_microseconds(self, period: int) -> None:\n        \"\"\"Set the period of the PWM signal being output to ``period`` in\n        microseconds. The minimum valid value is 35\u00b5s.\n        \"\"\"\n\nclass MicroBitAnalogDigitalPin(MicroBitDigitalPin):\n    def read_analog(self) -> int:\n        \"\"\"Read the voltage applied to the pin, and return it as an integer\n        between 0 (meaning 0V) and 1023 (meaning 3.3V).\n        \"\"\"\n\nclass MicroBitTouchPin(MicroBitAnalogDigitalPin):\n    def is_touched(self) -> bool:\n        \"\"\"Return ``True`` if the pin is being touched with a finger, otherwise\n        return ``False``.\n\n        This test is done by measuring the capacitance of the pin together with\n        whatever is connected to it. Human body has quite a large capacitance,\n        so touching the pin gives a dramatic change in reading, which can be\n        detected.\n        \"\"\"\n\npin0: MicroBitTouchPin\n\"\"\"Pad 0.\"\"\"\n\npin1: MicroBitTouchPin\n\"\"\"Pad 1.\"\"\"\n\npin2: MicroBitTouchPin\n\"\"\"Pad 2.\"\"\"\n\npin3: MicroBitAnalogDigitalPin\n\"\"\"Column 1.\"\"\"\n\npin4: MicroBitAnalogDigitalPin\n\"\"\"Column 2.\"\"\"\n\npin5: MicroBitDigitalPin\n\"\"\"Button A.\"\"\"\n\npin6: MicroBitDigitalPin\n\"\"\"Row 2.\"\"\"\n\npin7: MicroBitDigitalPin\n\"\"\"Row 1.\"\"\"\n\npin8: MicroBitDigitalPin\n\npin9: MicroBitDigitalPin\n\"\"\"Row 3.\"\"\"\n\npin10: MicroBitAnalogDigitalPin\n\"\"\"Column 3.\"\"\"\n\npin11: MicroBitDigitalPin\n\"\"\"Button B.\"\"\"\n\npin12: MicroBitDigitalPin\n\npin13: MicroBitDigitalPin\n\"\"\"SPI MOSI.\"\"\"\n\npin14: MicroBitDigitalPin\n\"\"\"SPI MISO.\"\"\"\n\npin15: MicroBitDigitalPin\n\"\"\"SPI SCK.\"\"\"\n\npin16: MicroBitDigitalPin\n\npin19: MicroBitDigitalPin\n\"\"\"I2C SCL.\"\"\"\n\npin20: MicroBitDigitalPin\n\"\"\"I2C SDA.\"\"\"\n\n\nclass Image:\n    \"\"\"The ``Image`` class is used to create images that can be displayed\n    easily on the device's LED matrix. Given an image object it's possible to\n    display it via the ``display`` API::\n\n        display.show(Image.HAPPY)\n    \"\"\"\n\n    HEART: Image\n    HEART_SMALL: Image\n    HAPPY: Image\n    SMILE: Image\n    SAD: Image\n    CONFUSED: Image\n    ANGRY: Image\n    ASLEEP: Image\n    SURPRISED: Image\n    SILLY: Image\n    FABULOUS: Image\n    MEH: Image\n    YES: Image\n    NO: Image\n    CLOCK12: Image\n    CLOCK11: Image\n    CLOCK10: Image\n    CLOCK9: Image\n    CLOCK8: Image\n    CLOCK7: Image\n    CLOCK6: Image\n    CLOCK5: Image\n    CLOCK4: Image\n    CLOCK3: Image\n    CLOCK2: Image\n    CLOCK1: Image\n    ARROW_N: Image\n    ARROW_NE: Image\n    ARROW_E: Image\n    ARROW_SE: Image\n    ARROW_S: Image\n    ARROW_SW: Image\n    ARROW_W: Image\n    ARROW_NW: Image\n    TRIANGLE: Image\n    TRIANGLE_LEFT: Image\n    CHESSBOARD: Image\n    DIAMOND: Image\n    DIAMOND_SMALL: Image\n    SQUARE: Image\n    SQUARE_SMALL: Image\n    RABBIT: Image\n    COW: Image\n    MUSIC_CROTCHET: Image\n    MUSIC_QUAVER: Image\n    MUSIC_QUAVERS: Image\n    PITCHFORK: Image\n    XMAS: Image\n    PACMAN: Image\n    TARGET: Image\n    TSHIRT: Image\n    ROLLERSKATE: Image\n    DUCK: Image\n    HOUSE: Image\n    TORTOISE: Image\n    BUTTERFLY: Image\n    STICKFIGURE: Image\n    GHOST: Image\n    SWORD: Image\n    GIRAFFE: Image\n    SKULL: Image\n    UMBRELLA: Image\n    SNAKE: Image\n\n    ALL_CLOCKS: List[Image]\n    ALL_ARROWS: List[Image]\n\n    @overload\n    def __init__(self, string: str) -> None:\n        \"\"\"``string`` has to consist of digits 0-9 arranged into lines,\n        describing the image, for example::\n\n            image = Image(\"90009:\"\n                          \"09090:\"\n                          \"00900:\"\n                          \"09090:\"\n                          \"90009\")\n\n        will create a 5\u00d75 image of an X. The end of a line is indicated by a\n        colon. It's also possible to use a newline (\\n) to indicate the end of\n        a line like this::\n\n            image = Image(\"90009\\n\"\n                          \"09090\\n\"\n                          \"00900\\n\"\n                          \"09090\\n\"\n                          \"90009\")\n        \"\"\"\n\n    @overload\n    def __init__(self, width: int = None, height: int = None,\n                 buffer: Any = None) -> None:\n        \"\"\"Create an empty image with ``width`` columns and ``height`` rows.\n        Optionally ``buffer`` can be an array of ``width``\u00d7``height`` integers\n        in range 0-9 to initialize the image.\n        \"\"\"\n\n    def width(self) -> int:\n        \"\"\"Return the number of columns in the image.\"\"\"\n\n    def height(self) -> int:\n        \"\"\"Return the numbers of rows in the image.\"\"\"\n\n    def set_pixel(self, x: int, y: int, value: int) -> None:\n        \"\"\"Set the brightness of the pixel at column ``x`` and row ``y`` to the\n        ``value``, which has to be between 0 (dark) and 9 (bright).\n\n        This method will raise an exception when called on any of the built-in\n        read-only images, like ``Image.HEART``.\n        \"\"\"\n\n    def get_pixel(self, x: int, y: int) -> int:\n        \"\"\"Return the brightness of pixel at column ``x`` and row ``y`` as an\n        integer between 0 and 9.\n        \"\"\"\n\n    def shift_left(self, n: int) -> Image:\n        \"\"\"Return a new image created by shifting the picture left by ``n``\n        columns.\n        \"\"\"\n\n    def shift_right(self, n: int) -> Image:\n        \"\"\"Same as ``image.shift_left(-n)``.\"\"\"\n\n    def shift_up(self, n: int) -> Image:\n        \"\"\"Return a new image created by shifting the picture up by ``n``\n        rows.\n        \"\"\"\n\n    def shift_down(self, n: int) -> Image:\n        \"\"\"Same as ``image.shift_up(-n)``.\"\"\"\n\n    def crop(self, x: int, y: int, w: int, h: int) -> Image:\n        \"\"\"Return a new image by cropping the picture to a width of ``w`` and a\n        height of ``h``, starting with the pixel at column ``x`` and row\n        ``y``.\n        \"\"\"\n\n    def copy(self) -> Image:\n        \"\"\"Return an exact copy of the image.\"\"\"\n\n    def invert(self) -> Image:\n        \"\"\"Return a new image by inverting the brightness of the pixels in the\n        source image.\"\"\"\n\n    def fill(self, value: int) -> None:\n        \"\"\"Set the brightness of all the pixels in the image to the\n        ``value``, which has to be between 0 (dark) and 9 (bright).\n\n        This method will raise an exception when called on any of the built-in\n        read-only images, like ``Image.HEART``.\n        \"\"\"\n\n    def blit(self, src: Image, x: int, y: int, w: int, h: int, xdest: int = 0,\n             ydest: int = 0) -> None:\n        \"\"\"Copy the rectangle defined by ``x``, ``y``, ``w``, ``h`` from the\n        image ``src`` into this image at ``xdest``, ``ydest``. Areas in the\n        source rectangle, but outside the source image are treated as having a\n        value of 0.\n\n        ``shift_left()``, ``shift_right()``, ``shift_up()``, ``shift_down()``\n        and ``crop()`` can are all implemented by using ``blit()``.\n\n        For example, img.crop(x, y, w, h) can be implemented as::\n\n            def crop(self, x, y, w, h):\n                res = Image(w, h)\n                res.blit(self, x, y, w, h)\n                return res\n        \"\"\"\n\n    def __repr__(self) -> str:\n        \"\"\"Get a compact string representation of the image.\"\"\"\n\n    def __str__(self) -> str:\n        \"\"\"Get a readable string representation of the image.\"\"\"\n\n    def __add__(self, other: Image) -> Image:\n        \"\"\"Create a new image by adding the brightness values from the two\n        images for each pixel.\n        \"\"\"\n\n    def __mul__(self, n: float) -> Image:\n        \"\"\"Create a new image by multiplying the brightness of each pixel by\n        ``n``.\n        \"\"\"\n",
    "/typeshed/stdlib/microbit/accelerometer.pyi": "\"\"\"This object gives you access to the on-board accelerometer. The accelerometer\nalso provides convenience functions for detecting gestures. The\nrecognised gestures are: ``up``, ``down``, ``left``, ``right``, ``face up``,\n``face down``, ``freefall``, ``3g``, ``6g``, ``8g``, ``shake``.\n\"\"\"\n\n\nfrom typing import Tuple\n\n\ndef get_x() -> int:\n    \"\"\"Get the acceleration measurement in the ``x`` axis, as a positive or\n    negative integer, depending on the direction.\n    \"\"\"\n\n\ndef get_y() -> int:\n    \"\"\"Get the acceleration measurement in the ``y`` axis, as a positive or\n    negative integer, depending on the direction.\n    \"\"\"\n\n\ndef get_z() -> int:\n    \"\"\"Get the acceleration measurement in the ``z`` axis, as a positive or\n    negative integer, depending on the direction.\n    \"\"\"\n\n\ndef get_values() -> Tuple[int, int, int]:\n    \"\"\"Get the acceleration measurements in all axes at once, as a three-element\n    tuple of integers ordered as X, Y, Z.\n    \"\"\"\n\n\ndef current_gesture() -> str:\n    \"\"\"Return the name of the current gesture.\n\n    .. note::\n\n        MicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n        ``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n        ``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\n        represented as strings.\"\"\"\n\n\ndef is_gesture(name: str) -> bool:\n    \"\"\"Return True or False to indicate if the named gesture is currently\n    active.\"\"\"\n\n\ndef was_gesture(name: str) -> bool:\n    \"\"\"Return True or False to indicate if the named gesture was active since the\n    last call.\n    \"\"\"\n\n\ndef get_gestures() -> Tuple[str, ...]:\n    \"\"\"Return a tuple of the gesture history. The most recent is listed last.\n    Also clears the gesture history before returning.\n    \"\"\"",
    "/typeshed/stdlib/microbit/compass.pyi": "\"\"\"This module lets you access the built-in electronic compass. Before using,\nthe compass should be calibrated, otherwise the readings may be wrong.\n\n.. warning::\n\n    Calibrating the compass will cause your program to pause until calibration\n    is complete. Calibration consists of a little game to draw a circle on the\n    LED display by rotating the device.\n\"\"\"\n\n\ndef calibrate() -> None:\n    \"\"\"Starts the calibration process. An instructive message will be scrolled\n    to the user after which they will need to rotate the device in order to\n    draw a circle on the LED display.\n    \"\"\"\n\n\ndef is_calibrated() -> bool:\n    \"\"\"Returns ``True`` if the compass has been successfully calibrated, and\n    returns ``False`` otherwise.\n    \"\"\"\n\n\ndef clear_calibration() -> None:\n    \"\"\"Undoes the calibration, making the compass uncalibrated again.\"\"\"\n\n\ndef get_x() -> int:\n    \"\"\"Gives the reading of the magnetic force on the ``x`` axis, as a\n    positive or negative integer, depending on the direction of the\n    force.\n    \"\"\"\n\n\ndef get_y() -> int:\n    \"\"\"Gives the reading of the magnetic force on the ``x`` axis, as a\n    positive or negative integer, depending on the direction of the\n    force.\n    \"\"\"\n\n\ndef get_z() -> int:\n    \"\"\"Gives the reading of the magnetic force on the ``x`` axis, as a\n    positive or negative integer, depending on the direction of the\n    force.\n    \"\"\"\n\n\ndef heading() -> int:\n    \"\"\"Gives the compass heading, calculated from the above readings, as an\n    integer in the range from 0 to 360, representing the angle in degrees,\n    clockwise, with north as 0.\n    If the compass has not been calibrated, then this will call ``calibrate``.\n    \"\"\"\n\n\ndef get_field_strength() -> int:\n    \"\"\"Returns an integer indication of the magnitude of the magnetic field\n    around the device.\"\"\"\n",
    "/typeshed/stdlib/microbit/display.pyi": "\"\"\"This module controls the 5\u00d75 LED display on the front of your board. It can\nbe used to display images, animations and even text.\n\nTo continuously scroll a string across the display, and do it in the background,\nyou can use::\n\n    import microbit\n\n    microbit.display.scroll('Hello!', wait=False, loop=True)\n\"\"\"\n\nfrom . import Image\nfrom typing import overload, Iterable\n\ndef get_pixel(x: int, y: int) -> int:\n    \"\"\"Return the brightness of the LED at column ``x`` and row ``y`` as an\n    integer between 0 (off) and 9 (bright).\n    \"\"\"\n\ndef set_pixel(x: int, y: int, value: int) -> None:\n    \"\"\"Set the brightness of the LED at column ``x`` and row ``y`` to ``value``,\n    which has to be an integer between 0 and 9.\n    \"\"\"\n\ndef clear() -> None:\n    \"\"\"Set the brightness of all LEDs to 0 (off).\"\"\"\n\n\n@overload\ndef show(image: Image) -> None:\n    \"\"\"Display the ``image``.\"\"\"\n\n\n@overload\ndef show(iterable: Iterable[Image, str], delay: int = 400, *,\n         wait: bool = True, loop: bool =False, clear: bool = False) -> None:\n    \"\"\"Display images or letters from the ``iterable`` in sequence, with\n    ``delay`` milliseconds between them.\n\n    If ``wait`` is ``True``, this function will block until the animation is\n    finished, otherwise the animation will happen in the background.\n\n    If ``loop`` is ``True``, the animation will repeat forever.\n\n    If ``clear`` is ``True``, the display will be cleared after the iterable\n    has finished.\n\n    Note that the ``wait``, ``loop`` and ``clear`` arguments must be specified\n    using their keyword.\n\n    .. note::\n\n        If using a generator as the ``iterable``, then take care not to\n        allocate any memory in the generator as allocating memory in an\n        interrupt is prohibited and will raise a ``MemoryError``.\n    \"\"\"\n\n\ndef scroll(string: str, delay: int = 150, *, wait: bool = True,\n           loop: bool = False, monospace: bool = False) -> None:\n    \"\"\"Similar to ``show``, but scrolls the ``string`` horizontally instead. The\n    ``delay`` parameter controls how fast the text is scrolling.\n\n    If ``wait`` is ``True``, this function will block until the animation is\n    finished, otherwise the animation will happen in the background.\n\n    If ``loop`` is ``True``, the animation will repeat forever.\n\n    If ``monospace`` is ``True``, the characters will all take up 5 pixel-columns\n    in width, otherwise there will be exactly 1 blank pixel-column between each\n    character as they scroll.\n\n    Note that the ``wait``, ``loop`` and ``monospace`` arguments must be specified\n    using their keyword.\n    \"\"\"\n\n\ndef on() -> None:\n    \"\"\"Use on() to turn on the display.\"\"\"\n\n\ndef off() -> None:\n    \"\"\"Use off() to turn off the display (thus allowing you to re-use the GPIO\n    pins associated with the display for other purposes).\n    \"\"\"\n\n\ndef is_on() -> bool:\n    \"\"\"Returns ``True`` if the display is on, otherwise returns ``False``.\"\"\"\n",
    "/typeshed/stdlib/microbit/i2c.pyi": "\"\"\"The ``i2c`` module lets you communicate with devices connected to your board\nusing the I\u00b2C bus protocol. There can be multiple slave devices connected at\nthe same time, and each one has its own unique address, that is either fixed\nfor the device or configured on it. Your board acts as the I\u00b2C master.\n\nWe use 7-bit addressing for devices because of the reasons stated\n`here <http://www.totalphase.com/support/articles/200349176-7-bit-8-bit-and-10-bit-I2C-Slave-Addressing>`_.\n\nThis may be different to other micro:bit related solutions.\n\nHow exactly you should communicate with the devices, that is, what bytes to\nsend and how to interpret the responses, depends on the device in question and\nshould be described separately in that device's documentation.\n\nYou should connect the device's ``SCL`` pin to micro:bit pin 19, and the\ndevice's ``SDA`` pin to micro:bit pin 20. You also must connect the device's\nground to the micro:bit ground (pin ``GND``). You may need to power the device\nusing an external power supply or the micro:bit.\n\nThere are internal pull-up resistors on the I\u00b2C lines of the board, but with\nparticularly long wires or large number of devices you may need to add\nadditional pull-up resistors, to ensure noise-free communication.\n\"\"\"\n\nfrom . import pin19, pin20\nfrom typing import Union\nfrom . import pin19, pin20\n\n\ndef init(freq: int = 100000, sda: int = pin20, scl: int = pin19) -> None:\n    \"\"\"Re-initialize peripheral with the specified clock frequency ``freq`` on the\n    specified ``sda`` and ``scl`` pins.\n\n    .. warning::\n\n        Changing the I\u00b2C pins from defaults will make the accelerometer and\n        compass stop working, as they are connected internally to those pins.\n    \"\"\"\n\n\ndef read(addr: int, n: int, repeat: bool = False) -> bytes:\n    \"\"\"Read ``n`` bytes from the device with 7-bit address ``addr``. If ``repeat``\n    is ``True``, no stop bit will be sent.\n    \"\"\"\n\n\ndef write(addr: int, buf: Union[bytes, bytearray], repeat=False) -> None:\n    \"\"\"Write bytes from ``buf`` to the device with 7-bit address ``addr``. If\n    ``repeat`` is ``True``, no stop bit will be sent.\n    \"\"\"",
    "/typeshed/stdlib/microbit/spi.pyi": "\"\"\"The ``spi`` module lets you talk to a device connected to your board using\na serial peripheral interface (SPI) bus. SPI uses a so-called master-slave\narchitecture with a single master. You will need to specify the connections\nfor three signals:\n\n* SCLK : Serial Clock (output from master).\n* MOSI : Master Output, Slave Input (output from master).\n* MISO : Master Input, Slave Output (output from slave).\n\"\"\"\n\n\nfrom . import pin13, pin14, pin15, MicroBitDigitalPin\nfrom typing import Union\n\n\ndef init(baudrate: int = 1000000, bits: int = 8, mode: int = 0,\n         sclk: MicroBitDigitalPin = pin13,\n         mosi: MicroBitDigitalPin = pin15,\n         miso: MicroBitDigitalPin = pin14) -> None:\n    \"\"\"Initialize SPI communication with the specified parameters on the\n    specified ``pins``. Note that for correct communication, the parameters\n    have to be the same on both communicating devices.\n\n    The ``baudrate`` defines the speed of communication.\n\n    The ``bits`` defines the size of bytes being transmitted. Currently only\n    ``bits=8`` is supported. However, this may change in the future.\n\n    The ``mode`` determines the combination of clock polarity and phase\n    according to the following convention, with polarity as the high order bit\n    and phase as the low order bit:\n\n    +----------+-----------------+--------------+\n    | SPI Mode | Polarity (CPOL) | Phase (CPHA) |\n    +==========+=================+==============+\n    | 0        | 0               | 0            |\n    +----------+-----------------+--------------+\n    | 1        | 0               | 1            |\n    +----------+-----------------+--------------+\n    | 2        | 1               | 0            |\n    +----------+-----------------+--------------+\n    | 3        | 1               | 1            |\n    +----------+-----------------+--------------+\n\n    Polarity (aka CPOL) 0 means that the clock is at logic value 0 when idle\n    and goes high (logic value 1) when active; polarity 1 means the clock is\n    at logic value 1 when idle and goes low (logic value 0) when active. Phase\n    (aka CPHA) 0 means that data is sampled on the leading edge of the clock,\n    and 1 means on the trailing edge\n    (viz. https://en.wikipedia.org/wiki/Signal_edge).\n\n    The ``sclk``, ``mosi`` and ``miso`` arguments specify the pins to use for\n    each type of signal.\n    \"\"\"\n\n\ndef read(nbytes: int) -> bytes:\n    \"\"\"Read at most ``nbytes``. Returns what was read.\"\"\"\n\n\ndef write(buffer: Union[bytes, bytearray]) -> None:\n    \"\"\"Write the ``buffer`` of bytes to the bus.\"\"\"\n\n\ndef write_readinto(out: Union[bytes, bytearray], in_: bytearray) -> None:\n    \"\"\"Write the ``out`` buffer to the bus and read any response into the ``in``\n   buffer. The length of the buffers should be the same. The buffers can be\n   the same object.\"\"\"",
    "/typeshed/stdlib/microbit/uart.pyi": "\"\"\"The ``uart`` module lets you talk to a device connected to your board using\na serial interface.\n\"\"\"\n\nfrom . import MicroBitDigitalPin\nfrom typing import Optional, Union\n\n\ndef init(baudrate: int = 9600, bits: int = 8, parity: int = None,\n         stop: int = 1, *, tx: MicroBitDigitalPin = None,\n         rx: MicroBitDigitalPin = None) -> None:\n    \"\"\"Initialize serial communication with the specified parameters on the\n    specified ``tx`` and ``rx`` pins. Note that for correct communication, the\n    parameters have to be the same on both communicating devices.\n\n    .. warning::\n\n        Initializing the UART on external pins will cause the Python console on\n        USB to become unaccessible, as it uses the same hardware. To bring the\n        console back you must reinitialize the UART without passing anything for\n        ``tx'' or ``rx'' (or passing ``None'' to these arguments).  This means\n        that calling ``uart.init(115200)'' is enough to restore the Python console.\n\n    The ``baudrate`` defines the speed of communication. Common baud\n    rates include:\n\n        * 9600\n        * 14400\n        * 19200\n        * 28800\n        * 38400\n        * 57600\n        * 115200\n\n    The ``bits`` defines the size of bytes being transmitted, and the board\n    only supports 8. The ``parity`` parameter defines how parity is checked,\n    and it can be ``None``, ``microbit.uart.ODD`` or ``microbit.uart.EVEN``.\n    The ``stop`` parameter tells the number of stop bits, and has to be 1 for\n    this board.\n\n    If ``tx`` and ``rx`` are not specified then the internal USB-UART TX/RX pins\n    are used which connect to the USB serial convertor on the micro:bit, thus\n    connecting the UART to your PC.  You can specify any other pins you want by\n    passing the desired pin objects to the ``tx`` and ``rx`` parameters.\n\n    .. note::\n\n        When connecting the device, make sure you \"cross\" the wires -- the TX\n        pin on your board needs to be connected with the RX pin on the device,\n        and the RX pin -- with the TX pin on the device. Also make sure the\n        ground pins of both devices are connected.\n    \"\"\"\n\n\ndef any() -> bool:\n    \"\"\"Return ``True`` if any characters waiting, else ``False``.\"\"\"\n\n\ndef read(nbytes: int = None) -> bytes:\n    \"\"\"Read characters.  If ``nbytes`` is specified then read at most that many\n    bytes.\"\"\"\n\n\ndef readall() -> Optional[bytes]:\n    \"\"\"Read as much data as possible.\n\n    Return value: a bytes object or ``None`` on timeout.\n    \"\"\"\n\n\ndef readinto(buf: bytearray, nbytes: int = None) -> Optional[int]:\n    \"\"\"Read bytes into the ``buf``.  If ``nbytes`` is specified then read at most\n    that many bytes.  Otherwise, read at most ``len(buf)`` bytes.\n\n    Return value: number of bytes read and stored into ``buf`` or ``None`` on\n    timeout.\n    \"\"\"\n\n\ndef readline() -> Optional[bytes]:\n    \"\"\"Read a line, ending in a newline character.\n\n    Return value: the line read or ``None`` on timeout. The newline character is\n    included in the returned bytes.\n    \"\"\"\n\ndef write(buf: Union[bytes, bytearray]) -> Optional[int]:\n    \"\"\"Write the buffer of bytes to the bus.\n\n    Return value: number of bytes written or ``None`` on timeout.\n    \"\"\"\n\nODD: int\nEVEN: int",
    "/typeshed/stdlib/collections/__init__.pyi": "import sys\nfrom _typeshed import Self\nfrom typing import Any, Dict, Generic, List, NoReturn, Optional, Tuple, Type, TypeVar, Union, overload\n\nif sys.version_info >= (3, 10):\n    from typing import (\n        Callable,\n        ItemsView,\n        Iterable,\n        Iterator,\n        KeysView,\n        Mapping,\n        MutableMapping,\n        MutableSequence,\n        Reversible,\n        Sequence,\n        ValuesView,\n    )\nelse:\n    from _collections_abc import *\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n\n# namedtuple is special-cased in the type checker; the initializer is ignored.\nif sys.version_info >= (3, 7):\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n        defaults: Optional[Iterable[Any]] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nelse:\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        verbose: bool = ...,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nclass UserDict(MutableMapping[_KT, _VT]):\n    data: Dict[_KT, _VT]\n    def __init__(self, __dict: Optional[Mapping[_KT, _VT]] = ..., **kwargs: _VT) -> None: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, key: _KT) -> _VT: ...\n    def __setitem__(self, key: _KT, item: _VT) -> None: ...\n    def __delitem__(self, key: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __contains__(self, key: object) -> bool: ...\n    def copy(self: _S) -> _S: ...\n    @classmethod\n    def fromkeys(cls: Type[_S], iterable: Iterable[_KT], value: Optional[_VT] = ...) -> _S: ...\n\nclass UserList(MutableSequence[_T]):\n    data: List[_T]\n    def __init__(self, initlist: Optional[Iterable[_T]] = ...) -> None: ...\n    def __lt__(self, other: object) -> bool: ...\n    def __le__(self, other: object) -> bool: ...\n    def __gt__(self, other: object) -> bool: ...\n    def __ge__(self, other: object) -> bool: ...\n    def __contains__(self, item: object) -> bool: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    def __getitem__(self: Self, i: slice) -> Self: ...\n    @overload\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, i: slice, o: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: Union[int, slice]) -> None: ...\n    def __add__(self: _S, other: Iterable[_T]) -> _S: ...\n    def __iadd__(self: _S, other: Iterable[_T]) -> _S: ...\n    def __mul__(self: _S, n: int) -> _S: ...\n    def __imul__(self: _S, n: int) -> _S: ...\n    def append(self, item: _T) -> None: ...\n    def insert(self, i: int, item: _T) -> None: ...\n    def pop(self, i: int = ...) -> _T: ...\n    def remove(self, item: _T) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self: _S) -> _S: ...\n    def count(self, item: _T) -> int: ...\n    def index(self, item: _T, *args: Any) -> int: ...\n    def reverse(self) -> None: ...\n    def sort(self, *args: Any, **kwds: Any) -> None: ...\n    def extend(self, other: Iterable[_T]) -> None: ...\n\n_UserStringT = TypeVar(\"_UserStringT\", bound=UserString)\n\nclass UserString(Sequence[str]):\n    data: str\n    def __init__(self, seq: object) -> None: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __complex__(self) -> complex: ...\n    def __getnewargs__(self) -> Tuple[str]: ...\n    def __lt__(self, string: Union[str, UserString]) -> bool: ...\n    def __le__(self, string: Union[str, UserString]) -> bool: ...\n    def __gt__(self, string: Union[str, UserString]) -> bool: ...\n    def __ge__(self, string: Union[str, UserString]) -> bool: ...\n    def __contains__(self, char: object) -> bool: ...\n    def __len__(self) -> int: ...\n    # It should return a str to implement Sequence correctly, but it doesn't.\n    def __getitem__(self: _UserStringT, i: Union[int, slice]) -> _UserStringT: ...  # type: ignore\n    def __add__(self: _UserStringT, other: object) -> _UserStringT: ...\n    def __mul__(self: _UserStringT, n: int) -> _UserStringT: ...\n    def __mod__(self: _UserStringT, args: Any) -> _UserStringT: ...\n    def capitalize(self: _UserStringT) -> _UserStringT: ...\n    def casefold(self: _UserStringT) -> _UserStringT: ...\n    def center(self: _UserStringT, width: int, *args: Any) -> _UserStringT: ...\n    def count(self, sub: Union[str, UserString], start: int = ..., end: int = ...) -> int: ...\n    if sys.version_info >= (3, 8):\n        def encode(self: UserString, encoding: Optional[str] = ..., errors: Optional[str] = ...) -> bytes: ...\n    else:\n        def encode(self: _UserStringT, encoding: Optional[str] = ..., errors: Optional[str] = ...) -> _UserStringT: ...\n    def endswith(self, suffix: Union[str, Tuple[str, ...]], start: Optional[int] = ..., end: Optional[int] = ...) -> bool: ...\n    def expandtabs(self: _UserStringT, tabsize: int = ...) -> _UserStringT: ...\n    def find(self, sub: Union[str, UserString], start: int = ..., end: int = ...) -> int: ...\n    def format(self, *args: Any, **kwds: Any) -> str: ...\n    def format_map(self, mapping: Mapping[str, Any]) -> str: ...\n    def index(self, sub: str, start: int = ..., end: int = ...) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isalnum(self) -> bool: ...\n    def isdecimal(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def isidentifier(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isnumeric(self) -> bool: ...\n    def isprintable(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, seq: Iterable[str]) -> str: ...\n    def ljust(self: _UserStringT, width: int, *args: Any) -> _UserStringT: ...\n    def lower(self: _UserStringT) -> _UserStringT: ...\n    def lstrip(self: _UserStringT, chars: Optional[str] = ...) -> _UserStringT: ...\n    @staticmethod\n    @overload\n    def maketrans(x: Union[Dict[int, _T], Dict[str, _T], Dict[Union[str, int], _T]]) -> Dict[int, _T]: ...\n    @staticmethod\n    @overload\n    def maketrans(x: str, y: str, z: str = ...) -> Dict[int, Union[int, None]]: ...\n    def partition(self, sep: str) -> Tuple[str, str, str]: ...\n    if sys.version_info >= (3, 9):\n        def removeprefix(self: _UserStringT, __prefix: Union[str, UserString]) -> _UserStringT: ...\n        def removesuffix(self: _UserStringT, __suffix: Union[str, UserString]) -> _UserStringT: ...\n    def replace(\n        self: _UserStringT, old: Union[str, UserString], new: Union[str, UserString], maxsplit: int = ...\n    ) -> _UserStringT: ...\n    def rfind(self, sub: Union[str, UserString], start: int = ..., end: int = ...) -> int: ...\n    def rindex(self, sub: Union[str, UserString], start: int = ..., end: int = ...) -> int: ...\n    def rjust(self: _UserStringT, width: int, *args: Any) -> _UserStringT: ...\n    def rpartition(self, sep: str) -> Tuple[str, str, str]: ...\n    def rstrip(self: _UserStringT, chars: Optional[str] = ...) -> _UserStringT: ...\n    def split(self, sep: Optional[str] = ..., maxsplit: int = ...) -> List[str]: ...\n    def rsplit(self, sep: Optional[str] = ..., maxsplit: int = ...) -> List[str]: ...\n    def splitlines(self, keepends: bool = ...) -> List[str]: ...\n    def startswith(self, prefix: Union[str, Tuple[str, ...]], start: Optional[int] = ..., end: Optional[int] = ...) -> bool: ...\n    def strip(self: _UserStringT, chars: Optional[str] = ...) -> _UserStringT: ...\n    def swapcase(self: _UserStringT) -> _UserStringT: ...\n    def title(self: _UserStringT) -> _UserStringT: ...\n    def translate(self: _UserStringT, *args: Any) -> _UserStringT: ...\n    def upper(self: _UserStringT) -> _UserStringT: ...\n    def zfill(self: _UserStringT, width: int) -> _UserStringT: ...\n\nclass deque(MutableSequence[_T], Generic[_T]):\n    @property\n    def maxlen(self) -> Optional[int]: ...\n    def __init__(self, iterable: Iterable[_T] = ..., maxlen: Optional[int] = ...) -> None: ...\n    def append(self, x: _T) -> None: ...\n    def appendleft(self, x: _T) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> deque[_T]: ...\n    def count(self, x: _T) -> int: ...\n    def extend(self, iterable: Iterable[_T]) -> None: ...\n    def extendleft(self, iterable: Iterable[_T]) -> None: ...\n    def insert(self, i: int, x: _T) -> None: ...\n    def index(self, x: _T, start: int = ..., stop: int = ...) -> int: ...\n    def pop(self) -> _T: ...  # type: ignore\n    def popleft(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def reverse(self) -> None: ...\n    def rotate(self, n: int = ...) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    # These methods of deque don't really take slices, but we need to\n    # define them as taking a slice to satisfy MutableSequence.\n    @overload\n    def __getitem__(self, index: int) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> MutableSequence[_T]: ...\n    @overload\n    def __setitem__(self, i: int, x: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    @overload\n    def __delitem__(self, i: int) -> None: ...\n    @overload\n    def __delitem__(self, s: slice) -> None: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __iadd__(self: _S, iterable: Iterable[_T]) -> _S: ...\n    def __add__(self, other: deque[_T]) -> deque[_T]: ...\n    def __mul__(self, other: int) -> deque[_T]: ...\n    def __imul__(self, other: int) -> None: ...\n\nclass Counter(Dict[_T, int], Generic[_T]):\n    @overload\n    def __init__(self, __iterable: None = ..., **kwargs: int) -> None: ...\n    @overload\n    def __init__(self, __mapping: Mapping[_T, int]) -> None: ...\n    @overload\n    def __init__(self, __iterable: Iterable[_T]) -> None: ...\n    def copy(self: _S) -> _S: ...\n    def elements(self) -> Iterator[_T]: ...\n    def most_common(self, n: Optional[int] = ...) -> List[Tuple[_T, int]]: ...\n    @classmethod\n    def fromkeys(cls, iterable: Any, v: Optional[int] = ...) -> NoReturn: ...  # type: ignore\n    @overload\n    def subtract(self, __iterable: None = ...) -> None: ...\n    @overload\n    def subtract(self, __mapping: Mapping[_T, int]) -> None: ...\n    @overload\n    def subtract(self, __iterable: Iterable[_T]) -> None: ...\n    # The Iterable[Tuple[...]] argument type is not actually desirable\n    # (the tuples will be added as keys, breaking type safety) but\n    # it's included so that the signature is compatible with\n    # Dict.update. Not sure if we should use '# type: ignore' instead\n    # and omit the type from the union.\n    @overload\n    def update(self, __m: Mapping[_T, int], **kwargs: int) -> None: ...\n    @overload\n    def update(self, __m: Union[Iterable[_T], Iterable[Tuple[_T, int]]], **kwargs: int) -> None: ...\n    @overload\n    def update(self, __m: None = ..., **kwargs: int) -> None: ...\n    def __add__(self, other: Counter[_T]) -> Counter[_T]: ...\n    def __sub__(self, other: Counter[_T]) -> Counter[_T]: ...\n    def __and__(self, other: Counter[_T]) -> Counter[_T]: ...\n    def __or__(self, other: Counter[_T]) -> Counter[_T]: ...  # type: ignore\n    def __pos__(self) -> Counter[_T]: ...\n    def __neg__(self) -> Counter[_T]: ...\n    def __iadd__(self, other: Counter[_T]) -> Counter[_T]: ...\n    def __isub__(self, other: Counter[_T]) -> Counter[_T]: ...\n    def __iand__(self, other: Counter[_T]) -> Counter[_T]: ...\n    def __ior__(self, other: Counter[_T]) -> Counter[_T]: ...  # type: ignore\n\nclass _OrderedDictKeysView(KeysView[_KT], Reversible[_KT]):\n    def __reversed__(self) -> Iterator[_KT]: ...\n\nclass _OrderedDictItemsView(ItemsView[_KT, _VT], Reversible[Tuple[_KT, _VT]]):\n    def __reversed__(self) -> Iterator[Tuple[_KT, _VT]]: ...\n\nclass _OrderedDictValuesView(ValuesView[_VT], Reversible[_VT]):\n    def __reversed__(self) -> Iterator[_VT]: ...\n\nclass OrderedDict(Dict[_KT, _VT], Reversible[_KT], Generic[_KT, _VT]):\n    def popitem(self, last: bool = ...) -> Tuple[_KT, _VT]: ...\n    def move_to_end(self, key: _KT, last: bool = ...) -> None: ...\n    def copy(self: _S) -> _S: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    def keys(self) -> _OrderedDictKeysView[_KT]: ...\n    def items(self) -> _OrderedDictItemsView[_KT, _VT]: ...\n    def values(self) -> _OrderedDictValuesView[_VT]: ...\n\nclass defaultdict(Dict[_KT, _VT], Generic[_KT, _VT]):\n    default_factory: Optional[Callable[[], _VT]]\n    @overload\n    def __init__(self, **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, default_factory: Optional[Callable[[], _VT]]) -> None: ...\n    @overload\n    def __init__(self, default_factory: Optional[Callable[[], _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, default_factory: Optional[Callable[[], _VT]], map: Mapping[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self, default_factory: Optional[Callable[[], _VT]], map: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, default_factory: Optional[Callable[[], _VT]], iterable: Iterable[Tuple[_KT, _VT]]) -> None: ...\n    @overload\n    def __init__(\n        self, default_factory: Optional[Callable[[], _VT]], iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT\n    ) -> None: ...\n    def __missing__(self, key: _KT) -> _VT: ...\n    # TODO __reversed__\n    def copy(self: _S) -> _S: ...\n\nclass ChainMap(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    maps: List[Mapping[_KT, _VT]]\n    def __init__(self, *maps: Mapping[_KT, _VT]) -> None: ...\n    def new_child(self, m: Optional[Mapping[_KT, _VT]] = ...) -> ChainMap[_KT, _VT]: ...\n    @property\n    def parents(self) -> ChainMap[_KT, _VT]: ...\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    def __delitem__(self, v: _KT) -> None: ...\n    def __getitem__(self, k: _KT) -> _VT: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def __missing__(self, key: _KT) -> _VT: ...  # undocumented\n",
    "/typeshed/stdlib/collections/abc.pyi": "from _collections_abc import *\nfrom _collections_abc import __all__ as __all__\n",
    "/src/pyrightconfig.json": "{ \n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"include\": [\"src/\"],\n  \"reportMissingModuleSource\": false,\n  \"reportWildcardImportFromLibrary\": false\n }\n"
  }
}